<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
<!ENTITY ltwarning "<p class='box'>Note: If the four characters '&amp;', 'l', 't', ';' appear consecutively in any of the factors of the verification string S (e.g., a service discovery identity of 'SomeClient&amp;lt;http://jabber.org/protocol/muc') then that string of characters MUST be treated as literally '&amp;lt;' and MUST NOT be converted to the character '&lt;', because completing such a conversion would open the protocol to trivial attacks.</p>">
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
  <header>
    <title>Entity Capabilities</title>
    <abstract>This document defines an XMPP protocol extension for broadcasting and dynamically discovering client, device, or generic entity capabilities. In order to minimize network impact, the transport mechanism is standard XMPP presence broadcast (thus forestalling the need for polling related to service discovery data), the capabilities information can be cached either within a session or across sessions, and the format has been kept as small as possible.</abstract>
    &LEGALNOTICE;
    <number>0115</number>
    <status>Draft</status>
    <type>Standards Track</type>
    <sig>Standards</sig>
    <dependencies>
      <spec>XMPP Core</spec>
      <spec>XMPP IM</spec>
      <spec>XEP-0030</spec>
    </dependencies>
    <supersedes/>
    <supersededby/>
    <shortname>caps</shortname>
    <schemaloc>
      <url>http://www.xmpp.org/schemas/caps.xsd</url>
    </schemaloc>
    &hildjj;
    &stpeter;
    &remko;
    <author>
      <firstname>Jacek</firstname>
      <surname>Konieczny</surname>
      <email>jajcus@jajcus.net</email>
      <jid>jajcus@jabber.bnet.pl</jid>
    </author>
    <revision>
      <version>1.5.1</version>
      <date>2016-10-06</date>
      <initials>egp</initials>
      <remark><p>Added registrar consideration about stream features.</p></remark>
    </revision>
    <revision>
      <version>1.5</version>
      <date>2008-02-26</date>
      <initials>jjh/psa</initials>
      <remark>
        <ul>
          <li>Defined SHA-1 as mandatory to implement</li>
          <li>Specified that inclusion of hash attribute is required</li>
          <li>Defined the nature of possible preimage attacks</li>
          <li>More clearly specified security considerations</li>
          <li>More clearly specified implementation notes</li>
          <li>Modified generation method to incorporate service discovery extensions</li>
          <li>More clearly specified processing method</li>
          <li>Clarified meaning and construction of caps node attribute and disco node attribute</li>
          <li>Specified that node attribute shall be included in disco#info request for backwards-compatibility</li>
          <li>Clarified handling of the legacy format to assist developers</li>
          <li>Added service discovery feature for caps optimization to prevent confusion regarding server support of caps vs. caps optimization</li>
        </ul>
      </remark>
    </revision>
    <revision>
      <version>1.4</version>
      <date>2007-08-13</date>
      <initials>psa/jk/jjh</initials>
      <remark><p>In response to persistent security concerns over caps poisoning, redefined ver attribute to be a hash of the service discovery identity and features in a way that is backwards-compatible with the legacy format.</p></remark>
    </revision>
    <revision>
      <version>1.3</version>
      <date>2007-04-10</date>
      <initials>psa/rt/jjh</initials>
      <remark><p>Added developer-friendly introduction; specified that ext names must be stable across application versions; further clarified examples; added stream feature use case; removed message example (send directed presence instead).</p></remark>
    </revision>
    <revision>
      <version>1.2</version>
      <date>2007-02-15</date>
      <initials>psa</initials>
      <remark><p>Clarified motivation and handling of service discovery requests.</p></remark>
    </revision>
    <revision>
      <version>1.1</version>
      <date>2004-10-29</date>
      <initials>psa</initials>
      <remark><p>Clarified meaning of service discovery results for client#ver and client#ext.</p></remark>
    </revision>
    <revision>
      <version>1.0</version>
      <date>2004-08-01</date>
      <initials>psa</initials>
      <remark><p>Per a vote of the Jabber Council, advanced status to Draft.</p></remark>
    </revision>
    <revision>
      <version>0.7</version>
      <date>2004-06-29</date>
      <initials>jjh/psa</initials>
      <remark><p>Added several items to the Security Considerations; clarified naming requirements regarding 'node', 'ver', and 'ext' attributes.</p></remark>
    </revision>
    <revision>
      <version>0.6</version>
      <date>2004-04-25</date>
      <initials>psa</initials>
      <remark><p>Made a number of editorial adjustments.</p></remark>
    </revision>
    <revision>
      <version>0.5</version>
      <date>2004-01-05</date>
      <initials>psa</initials>
      <remark><p>Specified that the protocol can be used whenever presence is used (e.g., by gateways); improved the XML schema; made several editorial adjustments.</p></remark>
    </revision>
    <revision>
      <version>0.4</version>
      <date>2003-09-04</date>
      <initials>jjh</initials>
      <remark><p>IQ eets must be to a resource, since they are intended to go to a particular session.</p></remark>
    </revision>
    <revision>
      <version>0.3</version>
      <date>2003-09-02</date>
      <initials>jjh</initials>
      <remark><p>Servers MUST strip extras changed to MAY, due to implementer feedback.</p></remark>
    </revision>
    <revision>
      <version>0.2</version>
      <date>2003-08-28</date>
      <initials>jjh</initials>
      <remark><p>Add more clarifying assumptions and requirements, make it clear that clients don't have to send capabilities every time if the server is optimizing.</p></remark>
    </revision>
    <revision>
      <version>0.1</version>
      <date>2003-08-27</date>
      <initials>jjh</initials>
      <remark><p>Initial version.</p></remark>
    </revision>
  </header>
  <section1 topic='Introduction' anchor='intro'>
    <section2 topic='Motivation' anchor='motivation'>
      <p>It is often desirable for an XMPP application (commonly but not necessarily a client) to take different actions depending on the capabilities of another application from which it receives presence information. Examples include:</p>
      <ul>
        <li>Showing a different set of icons depending on the capabilities of other entities.</li>
        <li>Not sending &xep0071; or other rich content to plaintext clients such as cell phones.</li>
        <li>Allowing the initiation of a Voice over IP (VoIP) session only to clients that support &xep0166; and &xep0167;.</li>
        <li>Not showing a "Send a File" button if another user's client does not support &xep0096;.</li>
        <li>Filtering &xep0060; notifications based on advertised subscriber interests.</li>
      </ul>
      <p>In the past, after logging in some Jabber clients sent one &xep0030; and one &xep0092; request to each entity from which they received presence. That "disco/version flood" resulted in an excessive use of bandwidth and was impractical on a larger scale, particularly for users with large rosters. Therefore this document defines a more robust and scalable solution: namely, a presence-based mechanism <note>Entity capabilities is not limited to clients, and can be used by any entity that exchanges presence with another entity, e.g., a gateway. However, this specification mainly uses the example of clients.</note> for exchanging information about entity capabilities. Clients should not engage in the older "disco/version flood" behavior and instead should use Entity Capabilities as specified herein.</p>
    </section2>
    <section2 topic='How It Works' anchor='howitworks'>
      <p>This section provides a friendly introduction to entity capabilities ("caps").</p>
      <p>Imagine that you are a Shakespearean character named Juliet and one of your contacts, a handsome fellow named Romeo, becomes available. His client wants to publish its capabilities, and does this by adding to its presence packets a &lt;c/&gt; element with special attributes. As a result, your client receives the following presence packet:</p>
      <code><![CDATA[
<presence from='romeo@montague.lit/orchard'>
  <c xmlns='http://jabber.org/protocol/caps'
     hash='sha-1'
     node='http://code.google.com/p/exodus'
     ver='QgayPKawpkPSDYmwT/WM94uAlu0='/>
</presence>
      ]]></code>
      <p>The 'node' attribute represents the client software Romeo is using. The 'ver' attribute is a specially-constructed string (called a "verification string") that represents the entity's service discovery identity (category and type as registered at &DISCOCATEGORIES;, as well as, optionally, xml:lang and name) and supported features (as registered at &DISCOFEATURES; as well as, optionally, extended service discovery information data registered at &FORMTYPES;).</p>
      <p>At this point, your client has no idea what the capabilities are of someone with a verification string 'QgayPKawpkPSDYmwT/WM94uAlu0='. Your client therefore sends a service discovery query to Romeo, asking what his client can do.</p>
      <code><![CDATA[
<iq from='juliet@capulet.lit/chamber'
    id='disco1'
    to='romeo@montague.lit/orchard'
    type='get'>
  <query xmlns='http://jabber.org/protocol/disco#info'
         node='http://code.google.com/p/exodus#QgayPKawpkPSDYmwT/WM94uAlu0='/>
</iq>
      ]]></code>
      <p>The response is:</p>
      <code><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='disco1'
    to='juliet@capulet.lit/chamber'
    type='result'>
  <query xmlns='http://jabber.org/protocol/disco#info'
         node='http://code.google.com/p/exodus#QgayPKawpkPSDYmwT/WM94uAlu0='>
    <identity category='client' name='Exodus 0.9.1' type='pc'/>
    <feature var='http://jabber.org/protocol/caps'/>
    <feature var='http://jabber.org/protocol/disco#info'/>
    <feature var='http://jabber.org/protocol/disco#items'/>
    <feature var='http://jabber.org/protocol/muc'/>
  </query>
</iq>
      ]]></code>
      <p>At this point, your client knows that a contact who advertises a verification string of 'QgayPKawpkPSDYmwT/WM94uAlu0=' supports &xep0045; and the other features returned by Romeo because the contact in fact uses the same version of the same client software as Romeo, with the same enabled features, plugins, presented client name(s), and the like (i.e., the same input to the verification string <link url='#ver-gen'>generation method</link>). <note>The string can be relied upon because of how it is generated and checked, as explained later in this document.</note> Your client remembers this information, so that it does not need to explicitly query the capabilities of a contact with the same verification string. For example, your Nurse may use the same client that Romeo does:</p>
      <code><![CDATA[
<presence from='nurse@capulet.lit/chamber'>
  <c xmlns='http://jabber.org/protocol/caps'
     hash='sha-1'
     node='http://code.google.com/p/exodus'
     ver='QgayPKawpkPSDYmwT/WM94uAlu0='/>
</presence>
      ]]></code>
      <p>Therefore you know that she also supports the same features that Romeo does.</p>
      <p>On the other hand, for a person with the following presence ...</p>
      <code><![CDATA[
<presence from='benvolio@capulet.lit/230193'>
  <c xmlns='http://jabber.org/protocol/caps'
     hash='sha-1'
     node='http://psi-im.org'
     ver='q07IKJEyjvHSyhy//CH0CxmKi8w='/>
</presence>
      ]]></code>
      <p>... or the following presence ...</p>
      <code><![CDATA[
<presence from='bard@shakespeare.lit/globe'>
  <c xmlns='http://jabber.org/protocol/caps'
     hash='sha-1'
     node='http://www.chatopus.com'
     ver='zHyEOgxTrkpSdGcQKH8EFPLsriY='/>
</presence>
      ]]></code>
      <p>... you have no information about what this contact's client is capable of unless you have cached previous entity capabilities information; therefore you need to query for capabilities explicitly again via service discovery.</p>
    </section2>
  </section1>
  <section1 topic='Assumptions' anchor='assumptions'>
    <p>This document makes several assumptions:</p>
    <ul>
      <li>The identity of the client I am using is of interest to the people in my roster.</li>
      <li>Clients for the people on my roster might want to make user interface decisions based on my capabilities.</li>
      <li>Members of a community tend to cluster around a small set of clients with a small set of capabilities. More specifically, multiple people in my roster use the same client, and they upgrade versions relatively slowly (commonly a few times a year, perhaps once a week at most, certainly not once a minute).</li>
      <li>Some clients are running on networks without server-to-server connectivity enabled and without access to the Internet via HTTP.</li>
      <li>Conversations are possible between users who are not on each other's rosters.</li>
      <li>Client capabilities may change over the course of a presence session, as features are enabled or disabled.</li>
    </ul>
  </section1>

  <section1 topic='Requirements' anchor='reqs'>
    <p>The protocol defined herein addresses the following requirements:</p>
    <ol start='1'>
      <li>Clients must be able to participate even if they support only &xmppcore;, &xmppim;, and <cite>XEP-0030</cite>.</li>
      <li>Clients must be able to participate even if they are on networks without connectivity to other XMPP servers, services offering specialized XMPP extensions, or HTTP servers.<note>These first two requirements effectively eliminated <cite>XEP-0060</cite> as a possible implementation of entity capabilities.</note></li>
      <li>Clients must be able to retrieve information without querying every entity with which they communicate.</li>
      <li>Since presence is normally broadcast to many contacts, the byte size of the proposed extension must be as small as possible.</li>
      <li>It must be possible to write a XEP-0045 server implementation that passes the given information along.</li>
      <li>It must be possible to publish a change in capabilities within a single presence session.</li>
      <li>Server infrastructure above and beyond that defined in <cite>XMPP Core</cite> and <cite>XMPP IM</cite> must not be required for this approach to work, although additional server infrastructure may be used for optimization purposes.</li>
      <li>The defined mechanism must not be limited to clients but must be usable by servers, components, and other network entities.</li>
    </ol>
  </section1>

  <section1 topic='Protocol' anchor='protocol'>
    <p>Entity capabilities are encapsulated in a &lt;c/&gt; element qualified by the 'http://jabber.org/protocol/caps' namespace. The attributes of the &lt;c/&gt; element are as follows.</p>
    <table caption='Attributes'>
      <tr>
        <th>Name</th>
        <th>Definition</th>
        <th>Inclusion</th>
      </tr>
      <tr>
        <td>ext</td>
        <td>A set of nametokens specifying additional feature bundles; this attribute is deprecated (see the <link url='#legacy'>Legacy Format</link> section of this document).</td>
        <td>DEPRECATED</td>
      </tr>
      <tr>
        <td>hash</td>
        <td>The hashing algorithm used to generate the verification string; see <link url='#security-mti'>Mandatory-to-Implement Technologies</link> regarding supported hashing algorithms.</td>
        <td>REQUIRED</td>
      </tr>
      <tr>
        <td>node</td>
        <td>A URI that uniquely identifies a software application, typically a URL at the website of the project or company that produces the software. *</td>
        <td>REQUIRED</td>
      </tr>
      <tr>
        <td>ver</td>
        <td>A string that is used to verify the identity and supported features of the entity. **</td>
        <td>REQUIRED</td>
      </tr>
    </table>
    <p>* Note: It is RECOMMENDED for the value of the 'node' attribute to be an HTTP URL at which a user could find further information about the software product, such as "http://psi-im.org" for the Psi client; this enables a processing application to also determine a unique string for the generating application, which it could maintain in a list of known software implementations (e.g., associating the name received via the disco#info reply with the URL found in the caps data).</p>
    <p>**  Note: Before version 1.4 of this specification, the 'ver' attribute was used to specify the released version of the software; while the values of the 'ver' attribute that result from use of the algorithm specified herein are backwards-compatible, applications SHOULD appropriately handle the <link url='#legacy'>Legacy Format</link>.</p>
  </section1>

  <section1 topic='Verification String' anchor='ver'>
    <section2 topic='Generation Method' anchor='ver-gen'>
      <p>In order to help prevent poisoning of entity capabilities information, the value of the verification string MUST be generated according to the following method.</p>
      <p>Note: All sorting operations MUST be performed using "i;octet" collation as specified in Section 9.3 of &rfc4790;.</p>
      <ol start='1'>
        <li>Initialize an empty string S.</li>
        <li>Sort the service discovery identities <note>A registry of service discovery identities is located at &DISCOCATEGORIES;.</note> by category and then by type and then by xml:lang (if it exists), formatted as CATEGORY '/' [TYPE] '/' [LANG] '/' [NAME]. <note>The combination of category, type, and xml:lang forms a unique combination, so it is not necessary to also sort by name (the name merely provides some human-readable text associated with a category/type/lang).</note> Note that each slash is included even if the LANG or NAME is not included (in accordance with <cite>XEP-0030</cite>, the category and type MUST be included).</li>
        <li>For each identity, append the 'category/type/lang/name' to S, followed by the '&lt;' character.</li>
        <li>Sort the supported service discovery features. <note>A registry of service discovery features is located at &DISCOFEATURES;.</note></li>
        <li>For each feature, append the feature to S, followed by the '&lt;' character.</li>
        <li>If the service discovery information response includes <cite>XEP-0128</cite> data forms, sort the forms by the FORM_TYPE (i.e., by the XML character data of the &lt;value/&gt; element).</li>
        <li>For each extended service discovery information form:
          <ol start='1'>
            <li>Append the XML character data of the FORM_TYPE field's &lt;value/&gt; element, followed by the '&lt;' character.</li>
            <li>Sort the fields by the value of the "var" attribute.</li>
            <li>For each field other than FORM_TYPE:
              <ol start='1'>
                <li>Append the value of the "var" attribute, followed by the '&lt;' character.</li>
                <li>Sort values by the XML character data of the &lt;value/&gt; element.</li>
                <li>For each &lt;value/&gt; element, append the XML character data, followed by the '&lt;' character.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Ensure that S is encoded according to the UTF-8 encoding (&rfc3269;).</li>
        <li>Compute the verification string by hashing S using the algorithm specified in the 'hash' attribute (e.g., SHA-1 as defined in &rfc3174;). The hashed data MUST be generated with binary output and encoded using Base64 as specified in Section 4 of &rfc4648; (note: the Base64 output MUST NOT include whitespace and MUST set padding bits to zero). <note>The OpenSSL command for producing such output with SHA-1 is "echo -n 'S' | openssl dgst -binary -sha1 | openssl enc -nopad -base64".</note></li>
      </ol>
      &ltwarning;
    </section2>
    <section2 topic='Simple Generation Example' anchor='ver-gen-simple'>
      <p>Consider an entity whose category is "client", whose service discovery type is "pc", whose service discovery name is "Exodus 0.9.1", and whose supported features are "http://jabber.org/protocol/disco#info", "http://jabber.org/protocol/disco#items", and "http://jabber.org/protocol/muc". Using the SHA-1 algorithm, the verification string would be generated as follows (note: line breaks in the verification string are included only for the purposes of readability):</p>
      <ol start='1'>
        <li>
          <p>S = ''</p>
        </li>
        <li>
          <p>Only one identity: "client/pc"</p>
        </li>
        <li>
          <p>S = 'client/pc//Exodus 0.9.1&lt;'</p>
        </li>
        <li>
          <p>Sort the features: "http://jabber.org/protocol/caps", "http://jabber.org/protocol/disco#info", "http://jabber.org/protocol/disco#items", "http://jabber.org/protocol/muc".</p>
        </li>
        <li>
          <p>S = 'client/pc//Exodus 0.9.1&lt;http://jabber.org/protocol/caps&lt;http://jabber.org/protocol/disco#info&lt;
            <br />http://jabber.org/protocol/disco#items&lt;http://jabber.org/protocol/muc&lt;'</p>
        </li>
        <li>
          <p>ver = QgayPKawpkPSDYmwT/WM94uAlu0=</p>
        </li>
      </ol>
    </section2>
    <section2 topic='Complex Generation Example' anchor='ver-gen-complex'>
      <p>Consider a more complex example, where the entity includes several identities (with the service discovery name in different languages) as well as extended information formatted according to <cite>XEP-0128</cite>.</p>
      <code>
&lt;iq from='benvolio@capulet.lit/230193'
    id='disco1'
    to='juliet@capulet.lit/chamber'
    type='result'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://psi-im.org#q07IKJEyjvHSyhy//CH0CxmKi8w='&gt;
    &lt;identity xml:lang='en' category='client' name='Psi 0.11' type='pc'/&gt;
    &lt;identity xml:lang='el' category='client' name='&#936; 0.11' type='pc'/&gt;
    &lt;feature var='http://jabber.org/protocol/caps'/&gt;
    &lt;feature var='http://jabber.org/protocol/disco#info'/&gt;
    &lt;feature var='http://jabber.org/protocol/disco#items'/&gt;
    &lt;feature var='http://jabber.org/protocol/muc'/&gt;
    &lt;x xmlns='jabber:x:data' type='result'&gt;
      &lt;field var='FORM_TYPE' type='hidden'&gt;
        &lt;value&gt;urn:xmpp:dataforms:softwareinfo&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='ip_version'&gt;
        &lt;value&gt;ipv4&lt;/value&gt;
        &lt;value&gt;ipv6&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='os'&gt;
        &lt;value&gt;Mac&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='os_version'&gt;
        &lt;value&gt;10.5.1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='software'&gt;
        &lt;value&gt;Psi&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='software_version'&gt;
        &lt;value&gt;0.11&lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
      </code>
      <p>Using the SHA-1 algorithm, the verification string would be generated as follows (note: line breaks in the verification string are included only for the purposes of readability):</p>
      <ol start='1'>
        <li>
          <p>S = ''</p>
        </li>
        <li>
          <p>Two identities: "client/pc/Psi" and "client/pc/&#936;"</p>
        </li>
        <li>
          <p>S = 'client/pc/el/&#936;&#160;0.11&lt;client/pc/en/Psi&#160;0.11&lt;'</p>
        </li>
        <li>
          <p>Sort the features: "http://jabber.org/protocol/caps", http://jabber.org/protocol/disco#info", "http://jabber.org/protocol/disco#items", "http://jabber.org/protocol/muc".</p>
        </li>
        <li>
          <p>
            S = 'client/pc/el/&#936;&#160;0.11&lt;client/pc/en/Psi&#160;0.11&lt;http://jabber.org/protocol/caps&lt;http://jabber.org/protocol/disco#info&lt;
              <br />http://jabber.org/protocol/disco#items&lt;http://jabber.org/protocol/muc&lt;'.
          </p>
        </li>
        <li>
          <p>Sort the extended service discovery forms by FORM_TYPE (there is only one: "urn:xmpp:dataforms:softwareinfo").</p>
        </li>
        <li>
          <p>S = 'client/pc/el/&#936;&#160;0.11&lt;client/pc/en/Psi&#160;0.11&lt;http://jabber.org/protocol/caps&lt;http://jabber.org/protocol/disco#info&lt;
            <br />http://jabber.org/protocol/disco#items&lt;http://jabber.org/protocol/muc&lt;urn:xmpp:dataforms:softwareinfo&lt;'</p>
        </li>
        <li>
          <p>Sort the fields by var and append the value(s): "ip_version&lt;ipv4&lt;ipv6", "os&lt;Mac", "os_version&lt;10.5.1", "software&lt;Psi", "software_version&lt;0.11".</p>
        </li>
        <li>
          <p>S = 'client/pc/el/&#936;&#160;0.11&lt;client/pc/en/Psi&#160;0.11&lt;http://jabber.org/protocol/caps&lt;http://jabber.org/protocol/disco#info&lt;
            <br />http://jabber.org/protocol/disco#items&lt;http://jabber.org/protocol/muc&lt;urn:xmpp:dataforms:softwareinfo&lt;
            <br />ip_version&lt;ipv4&lt;ipv6&lt;os&lt;Mac&lt;os_version&lt;10.5.1&lt;software&lt;Psi&lt;software_version&lt;0.11&lt;'</p>
        </li>
        <li>
          <p>ver = q07IKJEyjvHSyhy//CH0CxmKi8w=</p>
        </li>
      </ol>
    </section2>
    <section2 topic='Processing Method' anchor='ver-proc'>
      <p>When an entity receives a value of the 'ver' attribute that appears to be a verification string generated in accordance with the generation method defined in this specification, it MUST process the 'ver' according to the following method.</p>
      <ol start='1'>
        <li>Verify that the &lt;c/&gt; element includes a 'hash' attribute. If it does not, ignore the 'ver' or treat it as generated in accordance with the <link url='#legacy'>Legacy Format</link> (if supported).</li>
        <li>If the value of the 'hash' attribute does not match one of the processing application's supported hash functions, do the following:
          <ol start='1'>
            <li>Send a service discovery information request to the generating entity.</li>
            <li>Receive a service discovery information response from the generating entity.</li>
            <li>Do not validate or globally cache the verification string as described below; instead, the processing application SHOULD associate the discovered identity+features <em>only</em> with the JabberID of the generating entity.</li>
          </ol>
        </li>
        <li>If the value of the 'hash' attribute matches one of the processing application's supported hash functions, validate the verification string by doing the following:
          <ol start='1'>
            <li>Send a service discovery information request to the generating entity.</li>
            <li>Receive a service discovery information response from the generating entity.</li>
            <li>If the response includes more than one service discovery identity with the same category/type/lang/name, consider the entire response to be ill-formed.</li>
            <li>If the response includes more than one service discovery feature with the same XML character data, consider the entire response to be ill-formed.</li>
            <li>If the response includes more than one extended service discovery information form with the same FORM_TYPE or the FORM_TYPE field contains more than one &lt;value/&gt; element with different XML character data, consider the entire response to be ill-formed.</li>
            <li>If the response includes an extended service discovery information form where the FORM_TYPE field is not of type "hidden" or the form does not include a FORM_TYPE field, ignore the form but continue processing.</li>
            <li>If the response is considered well-formed, reconstruct the hash by using the service discovery information response to generate a local hash in accordance with the <link url='#ver-gen'>Generation Method</link>).</li>
            <li>If the values of the received and reconstructed hashes match, the processing application MUST consider the result to be valid and SHOULD globally cache the result for all JabberIDs with which it communicates.</li>
            <li>If the values of the received and reconstructed hashes do not match, the processing application MUST consider the result to be invalid and MUST NOT globally cache the verification string; however, it SHOULD check the service discovery identity and supported features of another generating entity who advertises that value.</li>
          </ol>
        </li>
      </ol>
      &ltwarning;
    </section2>
  </section1>

  <section1 topic='Use Cases' anchor='usecases'>
    <section2 topic='Advertising Capabilities' anchor='advertise'>
      <p>Each time a generating entity sends presence, it annotates that presence with an entity identifier ('node' attribute) and identity and feature identifier ('ver' attribute). So that servers can remember the last presence for use in responding to probes, a client SHOULD include entity capabilities with every presence notification it sends.</p>
      <example caption='Presence with caps'><![CDATA[
<presence>
  <c xmlns='http://jabber.org/protocol/caps'
     hash='sha-1'
     node='http://code.google.com/p/exodus'
     ver='QgayPKawpkPSDYmwT/WM94uAlu0='/>
</presence>
      ]]></example>
       <p>If the supported features change during a generating entity's presence session (e.g., a user installs an updated version of a client plugin), the application MUST recompute the verification string and SHOULD send a new presence broadcast.</p>
      <example caption='Presence with recomputed ver attribute'><![CDATA[
<presence>
  <c xmlns='http://jabber.org/protocol/caps'
     hash='sha-1'
     node='http://code.google.com/p/exodus'
     ver='66/0NaeaBKkwk85efJTGmU47vXI='/>
</presence>
      ]]></example>
    </section2>

    <section2 topic="Discovering Capabilities" anchor='discover'>
      <p>An application (the "requesting entity") can learn what features another entity supports by sending a disco#info request (see <cite>XEP-0030</cite>) to the entity that generated the caps information (the "generating entity").</p>

      <example caption='Disco#info request'><![CDATA[
<iq from='juliet@capulet.lit/balcony'
    id='disco1'
    to='romeo@montague.lit/orchard'
    type='get'>
  <query xmlns='http://jabber.org/protocol/disco#info'
         node='http://code.google.com/p/exodus#QgayPKawpkPSDYmwT/WM94uAlu0='/>
</iq>
      ]]></example>

      <p>The disco#info request is sent by the requesting entity to the generating entity. The value of the 'to' attribute MUST be the exact JID of the generating entity, which in the case of a client will be the full JID &LOCALFULL;.</p>
      <p>Note: The generating entity SHOULD NOT include the "caps node" in the list of entities it returns in its disco#items responses; i.e., the caps node is a kind of virtual or phantom node, not a true items node that is associated with the generating entity for service discovery purposes.</p>
      <p>The disco 'node' attribute MUST be included for backwards-compatibility. The value of the 'node' attribute SHOULD be generated by concatenating the value of the caps 'node' attribute (e.g., "http://code.google.com/p/exodus") as provided by the generating entity, the "#" character, and the value of the caps 'ver' attribute (e.g., "QgayPKawpkPSDYmwT/WM94uAlu0=") as provided by the generating entity.</p>

      <p>The generating entity then returns all of the capabilities it supports.</p>

      <example caption='Disco#info response'><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='disco1'
    to='juliet@capulet.lit/balcony'
    type='result'>
  <query xmlns='http://jabber.org/protocol/disco#info'
         node='http://code.google.com/p/exodus#QgayPKawpkPSDYmwT/WM94uAlu0='>
    <identity category='client' type='pc'/>
    <feature var='http://jabber.org/protocol/disco#info'/>
    <feature var='http://jabber.org/protocol/disco#items'/>
    <feature var='http://jabber.org/protocol/muc'/>
  </query>
</iq>
      ]]></example>

      <p>Note: If the generating entity incorporated multiple identities with different xml:lang values in its verification string, it MUST return all of the identities even if the request specified a particular xml:lang.</p>

    </section2>

    <section2 topic='Stream Feature' anchor='stream'>
      <p>A server MAY include its entity capabilities in a stream feature element so that connecting clients and peer servers do not need to send service discovery requests each time they connect.</p>
      <example caption='Stream feature element including capabilities'><![CDATA[
<stream:features>
  <c xmlns='http://jabber.org/protocol/caps'
     hash='sha-1'
     node='http://jabberd.org'
     ver='ItBTI0XLDFvVxZ72NQElAzKS9sU='/>
</stream:features>
      ]]></example>
      <p>When a connected client or peer server sends a service discovery information request to determine the entity capabilities of a server that advertises capabilities via the stream feature, the requesting entity MUST send the disco#info request to the server's JID as provided in the 'from' attribute of the response stream header (the 'from' attribute was recommended by &rfc3920; and is required by &rfc6120;). To enable this functionality, a server that advertises support for entity capabilities MUST provide a 'from' address in its response stream headers, in accordance with <cite>RFC 6120</cite>.</p>
    </section2>
  </section1>

  <section1 topic='Determining Support' anchor='support'>
    <p>If an entity supports the entity capabilities protocol, it MUST advertise that fact by returning a feature of <strong>'http://jabber.org/protocol/caps'</strong> in response to a service discovery information request.</p>
    <example caption="Service discovery information request"><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='disco2'
    to='juliet@capulet.lit/balcony'
    type='get'>
  <query xmlns='http://jabber.org/protocol/disco#info'/>
</iq>
    ]]></example>
    <example caption="Service discovery information response"><![CDATA[
<iq from='juliet@capulet.lit/balcony'
    id='disco2'
    to='romeo@montague.lit/orchard'
    type='result'>
  <query xmlns='http://jabber.org/protocol/disco#info'>
    ...
    <feature var='http://jabber.org/protocol/caps'/>
    ...
  </query>
</iq>
    ]]></example>
    <p>If a server supports the <link url='#impl-optimize'>Caps Optimization</link> functionality, it MUST also return a feature of <strong>'http://jabber.org/protocol/caps#optimize'</strong> in response to service discovery information requests.</p>
    <example caption="Service discovery information request"><![CDATA[
<iq from='juliet@capulet.lit/balcony'
    id='disco3'
    to='capulet.lit'
    type='get'>
  <query xmlns='http://jabber.org/protocol/disco#info'/>
</iq>
    ]]></example>
    <example caption="Service discovery information response"><![CDATA[
<iq from='capulet.lit'
    id='disco3'
    to='juliet@capulet.lit/balcony'
    type='result'>
  <query xmlns='http://jabber.org/protocol/disco#info'>
    ...
    <feature var='http://jabber.org/protocol/caps#optimize'/>
    ...
  </query>
</iq>
    ]]></example>
  </section1>

  <section1 topic='Implementation Notes' anchor='impl'>
    <section2 topic='Hashing Algorithm Support' anchor='impl-hash'>
      <p>An application SHOULD maintain a list of hashing algorithms it supports, which MUST include the algorithm or algorithms listed in the <link url='#security-mti'>Mandatory-to-Implement Technologies</link> section of this document.</p>
    </section2>
    <section2 topic='Caching' anchor='impl-cache'>
      <p>It is RECOMMENDED for an application that processes entity capabilities information to cache associations between the verification string and discovered identity+features within the scope of one presence session. This obviates the need for extensive service discovery requests within a session.</p>
      <p>It is RECOMMENDED for an application to cache associations across presence sessions, since this obviates the need for extensive service discovery requests at the beginning of a session (this is especially helpful in bandwidth-constrained environments).</p>
    </section2>
    <section2 topic='Directed Presence' anchor='impl-presence'>
      <p>If two entities exchange messages but they do not normally exchange presence (i.e., via presence subscription), the entities MAY choose to send directed presence to each other, where the presence information SHOULD be annotated with the same capabilities information as each entity sends in presence broadcasts. Until and unless capabilities information has been received from another entity, an application MUST assume that the other entity does not support capabilities.</p>
    </section2>
    <section2 topic='Caps Optimization' anchor='impl-optimize'>
      <p>A server that is managing an connected client's presence session MAY optimize presence notification traffic sent through the server by stripping off redundant capabilities annotations (i.e., the &lt;c/&gt; element). Because of this, receivers of presence notifications MUST NOT expect an annotation on every presence notification they receive. If the server performs caps optimization, it MUST ensure that the first presence notification each subscriber receives contains the annotation. The server MUST also ensure that any changes in the caps information (e.g., an updated 'ver' attribute) are sent to all subscribers.</p>
      <p>If a connected client determines that its server supports caps optimization, it MAY choose to send the capabilities annotation only on the first presence packet, as well as whenever its capabilities change.</p>
    </section2>
  </section1>


  <section1 topic='Security Considerations' anchor='security'>
    <section2 topic='Mandatory-to-Implement Technologies' anchor='security-mti'>
      <p>The SHA-1 hashing algorithm is mandatory to implement. All implementations MUST support SHA-1.</p>
      <p>An implementation MAY support other algorithms. Any such algorithm SHOULD be registered in the &ianahashes;.</p>
      <p>In the future, the &COUNCIL; may, at its discretion, modify the mandatory-to-implement hashing algorithm if it determines that SHA-1 has become practically vulnerable to <link url='#security-preimage'>Preimage Attacks</link>.</p>
    </section2>
    <section2 topic='Preimage Attacks' anchor='security-preimage'>
      <p>As described in &rfc4270;, protocols that use the output of hash functions such as MD5 or SHA-1 can be vulnerable to collision attacks or preimage attacks or both. Because of how the hash output is used in entity capabilities, the protocol will not be subject to collision attacks even if the hash function used is found to be vulnerable to collision attacks. However, it is <em>possible</em> that the protocol might become subject to preimage attacks if the hash function used is found to be vulnerable to preimage attacks.</p>
      <p>In theory, such a preimage attack would take one of the following forms:</p>
      <ul>
        <li>Given knowledge of a particular value V of the 'ver' attribute, an attacker can find an input message X such that hash(X) yields V (this is known as a "first preimage attack").</li>
        <li>Given knowledge of a particular value S used as the input message to the hash function, an attacker can find a value S' that yields V (this is known as a "second preimage attack").</li>
      </ul>
      <p>In practice, a preimage attack would need to meet all of the following criteria in order to be effective against the entity capabilities protocol:</p>
      <ol start='1'>
        <li>The hashing algorithm used would need to be found not only theoretically but practically vulnerable to first or second preimage attacks (e.g., this is not yet true of the MD5 or SHA-1 algorithms, but may become true in the future).</li>
        <li>An attacker would need to find an input message X or S' that matches the hash V for a particular value of V or S, which may not be practical given that (a) the values of S used as input to the hash function in entity capabilities are relatively short and (b) cryptanalysis to date indicates that existing hash functions may not be vulnerable to preimage attacks except in the case of relatively long input messages (on the order of 2<span class='super'>55</span> blocks).</li>
        <li>The input message X or S' would need to conform to the structure of S as specified under <link url='#ver'>Verification String</link>, including the order of service discovery identity or identities followed by service discovery features, delimited by the '&lt;' character and sorted using "i;octet" collation.</li>
        <li>The input messsage X or S' would need to make it seem as if a desirable feature (e.g., end-to-end encryption) is not supported by other entities that advertise the same hash V even though the feature is indeed supported (i.e., the attacker would need to return a set of service discovery identities and features that match X or S', and have that set be plausible for an entity that communicates via XMPP), or make it seem as if an undesirable feature is supported even though the feature is not supported.</li>
        <li>The attacker would need to propagate the hash V before some other entity with the true input message S could broadcast presence with the relevant entity capabilities data and provide the true service discovery response (thus the attacker might need to subvert the development process of a particular software project or subvert the namespace issuance process of the &REGISTRAR;, or both).</li>
      </ol>
      <p>It currently seems extremely unlikely that an attacker could meet all of the foregoing conditions in the foreseeable future. However, the XMPP Council shall continue to monitor the state of cryptanalysis regarding the mandatory-to-implement hash function as well as the possibility that any vulnerabilities in that function might lead to practical threats against the entity capabilities protocol. If and when it becomes practical (or even possible) to launch effective preimage attacks against the entity capabilities protocol, the XMPP Council shall consider updating this specification to change the mandatory-to-implement hashing algorithm to a safer technology.</p>
      &ltwarning;
    </section2>
    <section2 topic='Caps Poisoning' anchor='security-poisoning'>
      <p>Adherence to the method defined in the <link url='#ver'>Verification String</link> section of this document for both generation and processing of the 'ver' attribute helps to guard against poisoning of entity capabilities information by malicious or improperly implemented entities.</p>
      <p>If the value of the 'ver' attribute is a verification string as defined herein (i.e., if the 'ver' attribute is not generated according to the <link url='#legacy'>Legacy Format</link>), inclusion of the 'hash' attribute is REQUIRED. Knowing explicitly that the value of the 'ver' attribute is a verification string enables the recipient to avoid spurious notification of invalid or poisoned hashes.</p>
    </section2>
    <section2 topic='Information Exposure' anchor='security-exposure'>
      <p>Use of entity capabilities might make it easier for an attacker to launch certain application-specific attacks, since the attacker could more easily determine the type of client being used as well as its capabilities. However, since most clients respond to Service Discovery and Software Version requests without performing access control checks, there is no new vulnerability. Entities that wish to restrict access to capabilities information SHOULD use &xep0016; to define appropriate communications blocking (e.g., an entity MAY choose to allow IQ requests only from "trusted" entities, such as those with whom it has a presence subscription of "both"); note, however, that such restrictions may be incompatible with the recommendation regarding <link url='#directed'>Directed Presence</link>.</p>
    </section2>
  </section1>

  <section1 topic='IANA Considerations' anchor='iana'>
    <p>This document requires no interaction with &IANA;. </p>
  </section1>

  <section1 topic='XMPP Registrar Considerations' anchor='registrar'>
    <section2 topic='Protocol Namespaces' anchor='ns'>
    <p>The &REGISTRAR; includes "http://jabber.org/protocol/caps" in its registry of protocol namespaces  (see &NAMESPACES;).</p>
    </section2>
    <section2 topic='Service Discovery Features' anchor='registrar-features'>
      <p>The XMPP Registrar includes "http://jabber.org/protocol/caps" and "http://jabber.org/protocol/caps#optimize" in its registry of service discovery features (see &DISCOFEATURES;).</p>
    </section2>
    <section2 topic='Stream Features' anchor='registrar-stream-features'>
      <p>The XMPP Registrar includes "http://jabber.org/protocol/caps" in its registry of stream features (see &STREAMFEATURES;).</p>
    </section2>
  </section1>

  <section1 topic='XML Schema' anchor='schema'>
    <code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='http://jabber.org/protocol/caps'
    xmlns='http://jabber.org/protocol/caps'
    elementFormDefault='qualified'>

  <xs:annotation>
    <xs:documentation>
      The protocol documented by this schema is defined in
      XEP-0115: http://www.xmpp.org/extensions/xep-0115.html
    </xs:documentation>
  </xs:annotation>

  <xs:element name='c'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='empty'>
          <xs:attribute name='ext' type='xs:NMTOKENS' use='optional'/>
          <xs:attribute name='hash' type='xs:NMTOKEN' use='required'/>
          <xs:attribute name='node' type='xs:string' use='required'/>
          <xs:attribute name='ver' type='xs:string' use='required'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
]]></code>
  </section1>

  <section1 topic='Legacy Format' anchor='legacy'>
    <p>Before Version 1.4 of this specification, the 'ver' attribute was generated differently, the 'ext' attribute was used more extensively, and the 'hash' attribute was absent. For historical purposes, Version 1.3 of this specification is archived at &lt;<link url='http://www.xmpp.org/extensions/attic/xep-0115-1.3.html'>http://www.xmpp.org/extensions/attic/xep-0115-1.3.html</link>&gt;. For backwards-compatibility with the legacy format, the 'node' attribute is REQUIRED and the 'ext' attribute MAY be included.</p>
    <p>An application can determine if the legacy format is in use by checking for the presence of the 'hash' attribute, which is REQUIRED in the current format.</p>
    <p>If a caps-processing application supports the legacy format, it SHOULD check the 'node', 'ver', and 'ext' combinations as specified in the archived version 1.3 of this specification, and MAY cache the results.</p>
    <p>If a caps-processing application does not support the legacy format, it SHOULD ignore the 'ver' value entirely (since the value cannot be verified) and SHOULD NOT cache it, since the application cannot validate the identity and features by checking the hash.</p>
  </section1>

  <section1 topic='Acknowledgements' anchor='ack'>
    <p>Thanks to Rachel Blackman, Dave Cridland, Richard Dobson, Olivier Goffart, Sergei Golovan, Justin Karneges, Ralph Meijer, Ian Paterson, Kevin Smith, Tomasz Sterna, Michal Vaner, and Matt Yacobucci for comments and suggestions.</p>
  </section1>

</xep>
