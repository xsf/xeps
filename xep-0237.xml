<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
  <title>Roster Versioning</title>
  <abstract>This specification defines a proposed modification to the XMPP roster protocol that enables versioning of rosters such that the server will not send the roster to the client if the roster has not changed, thus saving bandwidth during session establishment.</abstract>
  &LEGALNOTICE;
  <number>0237</number>
  <status>Proposed</status>
  <type>Standards Track</type>
  <sig>Standards</sig>
  <approver>Council</approver>
  <dependencies>
    <spec>XMPP Core</spec>
    <spec>XMPP IM</spec>
  </dependencies>
  <supersedes/>
  <supersededby/>
  <shortname>N/A</shortname>
  &stpeter;
  <revision>
    <version>0.7</version>
    <date>2009-04-17</date>
    <initials>psa</initials>
    <remark><p>Modified the underlying model per list consensus; added more detailed scenarios to illustrate usage.</p></remark>
  </revision>
  <revision>
    <version>0.6</version>
    <date>2009-03-31</date>
    <initials>psa</initials>
    <remark><p>Clarified definition of sequence number.</p></remark>
  </revision>
  <revision>
    <version>0.5</version>
    <date>2009-02-19</date>
    <initials>psa</initials>
    <remark><p>Reverted to a roster-specific method and modified presentation to enable incorporation into rfc3921bis.</p></remark>
  </revision>
  <revision>
    <version>0.4</version>
    <date>2008-09-17</date>
    <initials>psa</initials>
    <remark><p>Defined new namespace and generalized to handle service discovery and other use cases in addition to rosters.</p></remark>
  </revision>
  <revision>
    <version>0.3</version>
    <date>2008-04-21</date>
    <initials>psa</initials>
    <remark><p>Defined protocol solely in terms of full rosters and roster pushes (no more roster diffs); added implementation notes; clarified server behavior if cached version is unavailable.</p></remark>
  </revision>
  <revision>
    <version>0.2</version>
    <date>2008-03-06</date>
    <initials>psa</initials>
    <remark><p>Renamed to data sequencing; clarified server behavior.</p></remark>
  </revision>
  <revision>
    <version>0.1</version>
    <date>2008-03-05</date>
    <initials>psa</initials>
    <remark><p>Initial published version; per Council consensus, removed optionality regarding semantics of the version attribute.</p></remark>
  </revision>
  <revision>
    <version>0.0.3</version>
    <date>2008-03-05</date>
    <initials>psa</initials>
    <remark><p>Corrected semantics of version attribute (should be a strictly increasing sequence number but may be any unique identifier).</p></remark>
  </revision>
  <revision>
    <version>0.0.2</version>
    <date>2008-03-04</date>
    <initials>psa</initials>
    <remark><p>Clarified description of roster diff; added diff attribute and specified its use in roster results; specified use of version attribute in roster pushes.</p></remark>
  </revision>
  <revision>
    <version>0.0.1</version>
    <date>2008-03-04</date>
    <initials>psa</initials>
    <remark><p>First draft.</p></remark>
  </revision>
</header>

<section1 topic='Introduction' anchor='intro'>
  <p>Although XMPP rosters can become quite large, they change infrequently. Therefore it can be inefficient for the server to send the roster to the client during session establishment if the roster has not changed. This document defines a small modification to the XMPP roster protocol specified in &xmppim; that enables "versioning" of roster information; when the client requests the roster it specifies its latest version, and the server will simply inform the client that it is up to date if the roster has not changed.</p>
  <p>The basic model is that if the client request the roster and specifies a version number, the server returns an empty IQ-result. If the roster has changed, the server sends numbered roster pushes for each roster item that has been touched in any way since the version specified by the client. The client processes each roster push as it normally would, incrementing its local version number with each roster push.</p>
  &RFC3921BISNOTE;
</section1>

<section1 topic='Protocol' anchor='proto'>
  <section2 topic='Data Format' anchor='format'>
    <p>This document adds a new 'ver' attribute to the &QUERY; element qualified by the 'jabber:iq:roster' namespace, defined as follows:</p>
    <p class='def'><strong>Definition:</strong> The 'ver' attribute is a strictly increasing sequence number that is increased (but not necessarily incremented-by-one) with any modification to the roster data. The value of the attribute MUST be a non-negative 64-bit integer, MUST be changed only by the server, and MUST be treated by the client as opaque. The server MUST ensure that each change to the roster data will result in a different sequence number and that the sequence number associated with a given roster modification will be greater than the sequence number associated with any previous roster modification. (Note: This rule effectively disallows the use of the system clock as a sequence number, since if the system time changes, e.g. because of an adjustment based on an NTP &rfc0958; update, the next generated value might be less than the previous one.)</p>
    <p>For purposes of this specification, a "roster modification" is any change to the roster data that would result in a roster push to a connected client. Therefore internal states related to roster processing within the server that do not result in a roster push do not necessitate a change to the sequence number. If a series of roster modifications result in a roster item that does not differ from the version cached by the client (e.g., a change to the item's 'name' attribute and then a change back to the original value), the server MUST consider the item to have been changed and MUST send the item to the client (typically via a roster push).</p>
  </section2>
  <section2 topic='Client Request' anchor='request'>
    <p>If a client supports roster versioning, it SHOULD include the 'ver' element in its request for the roster, where the 'ver' attribute is set to the sequence number associated with its last cache of the roster.</p>
    <example caption="Roster get with sequence number"><![CDATA[
C: <iq from='romeo@montague.lit/home' id='r1h3vzp7' to='romeo@montague.lit' type='get'>
     <query xmlns='jabber:iq:roster' ver='299'/>
   </iq>
    ]]></example>
    <p>If the client has not yet cached the roster or the cache is lost or corrupted, but the client wishes to bootstrap the use of roster versioning, it MUST set the 'ver' attribute to a value of zero (0).</p>
    <p>Naturally, if the client does not support roster versioning or does not wish to bootstrap the use of roster versioning, it will behave like an RFC-3921-compliant client by not including the 'ver' attribute.</p>
  </section2>
  <section2 topic='Server Response' anchor='response-result'>
    <p>Whether or not the roster has changed since the version enumerated by the client, the server MUST either return the complete roster as described in RFC 3921 or return an empty IQ-result (thus indicating that roster changes will be sent via roster pushes, as described below). In general, unless returning the complete roster would use less bandwidth than sending individual roster pushes to the client (e.g., if the roster contains only a few items), the server SHOULD send an empty IQ-result and then send the modifications via roster pushes.</p>
    <example caption="Empty roster result"><![CDATA[
S: <iq from='romeo@montague.lit' id='r1h3vzp7' to='romeo@montague.lit/home' type='result'/>
    ]]></example>
    <p>Note: This empty IQ-result is different from an empty &QUERY;, thus disambiguating this usage from an empty roster.</p>
    <p>If the roster has not changed since the version enumerated by the client, the server will simply not send any roster pushes to the client (until and unless some relevant event triggers a push during the lifetime of the client's session).</p>
    <p>If the roster has changed since the version enumerated by the client, the server MUST then send one roster push to the client for each roster item that has been modified since the version enumerated by the client.</p>
    <example caption="Roster pushes"><![CDATA[
S: <iq from='romeo@montague.lit' id='ah382g67' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='303'>
       <item jid='shylock@shakespeare.lit' subscription='remove'/>
     </query>
   </iq>

S: <iq from='romeo@montague.lit' id='b2gs90j5' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='307'>
       <item jid='bill@shakespeare.lit' subscription='both'/>
     </query>
   </iq>

S: <iq from='romeo@montague.lit' id='c73gs419' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='311'>
       <item jid='nurse@shakespeare.lit' name='Nurse' subscription='to'>
         <group>Servants</group>
       </item>
     </query>
   </iq>

S: <iq from='romeo@montague.lit' id='dh361f35' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='315'>
       <item jid='juliet@shakespeare.lit' name='Juliet' subscription='both'>
         <group>Friends</group>
       </item>
     </query>
   </iq>
    ]]></example>
    <p>These "interim roster pushes" can be understood as follows:</p>
    <ol>
      <li>Imagine that the client had an active presence session for the entire time between its cached roster version (say, 299) and the new roster version (say, 315).</li>
      <li>During that time, the client might have received roster pushes related to roster version numbers 301, 303, 305, 307, 309, 311, 313, and 315 (the version numbers must be strictly increasing but there is no requirement that the sequence shall be continuous).</li>
      <li>However, some of those roster pushes might have contained intermediate updates to the same roster item (e.g., changes in the subscription state for bill@shakespeare.lit from "none" to "to" and from "to" to "both").</li>
      <li>The interim roster pushes would not include all of the intermediate steps, only the final result of all changes applied while the client was in fact offline (say, 303, 307, 311, and 315).</li>
    </ol>
    <p>The client MUST handle an "interim roster push" in the same way it handles any roster push (indeed, from the client's perspective it cannot tell the difference between an "interim" roster push and a "live" roster push). If the client's session ends before it receives all of the interim roster pushes, when requesting the roster after reconnection it SHOULD request the version associated with the last roster push it received, not the version associated with the last roster result it received.</p>
    <p>When roster versioning is enabled, the server MUST include the updated roster version number with each roster push. Roster pushes MUST occur in sequence order and the version number contained in a roster push MUST be unique.</p>
  </section2>
</section1>

<section1 topic='Examples' anchor='examples'>
  <p>This section provides a detailed scenario that illustrates the use of roster versioning. In this example the client gets disconnected before it the server has had a chance to send all of its roster pushes, but this is immaterial to the synchronization process.</p>
  <example caption="The roster synchronization process"><![CDATA[
C: <iq from='romeo@montague.lit/home' id='r1h3vzp7' to='romeo@montague.lit' type='get'>
     <query xmlns='jabber:iq:roster' ver='299'/>
   </iq>

S: <iq from='romeo@montague.lit' id='r1h3vzp7' to='romeo@montague.lit/home' type='result'/>

S: <iq from='romeo@montague.lit' id='ah382g67' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='303'>
       <item jid='shylock@shakespeare.lit' subscription='remove'/>
     </query>
   </iq>

S: <iq from='romeo@montague.lit' id='b2gs90j5' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='307'>
       <item jid='bill@shakespeare.lit' subscription='both'/>
     </query>
   </iq>

S: </stream:stream>

[ reconnection ]

C: <iq from='romeo@montague.lit/home' id='r2xa7gf9' to='romeo@montague.lit' type='get'>
     <query xmlns='jabber:iq:roster' ver='307'/>
   </iq>

S: <iq from='romeo@montague.lit' id='r2xa7gf9' to='romeo@montague.lit/home' type='result'/>

S: <iq from='romeo@montague.lit' id='c73gs419' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='311'>
       <item jid='nurse@shakespeare.lit' name='Nurse' subscription='to'>
         <group>Servants</group>
       </item>
     </query>
   </iq>

S: <iq from='romeo@montague.lit' id='dh361f35' to='romeo@montague.lit/home' type='set'>
     <query xmlns='jabber:iq:roster' ver='315'>
       <item jid='juliet@shakespeare.lit' name='Juliet' subscription='both'>
         <group>Friends</group>
       </item>
     </query>
   </iq>
    ]]></example>
</section1>

<section1 topic='Stream Feature' anchor='feature'>
  <p>If a server supports roster versioning, it MUST inform the connecting entity when returning stream features during the stream negotiation process; at the latest, when informing a client that resource binding is required. This is done by including a &lt;ver/&gt; element qualified by the 'urn:xmpp:features:rosterver' namespace.</p>
  <example caption="Stream features"><![CDATA[
<stream:features>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <required/>
  </bind>
  <ver xmlns='urn:xmpp:features:rosterver'>
    <optional/>
  </ver>
</stream:features>
  ]]></example>
</section1>

<section1 topic='Security Considerations' anchor='security'>
  <p>It is possible that client-side caching of roster information (rather than holding them in memory only for the life of the session) could introduce new vulnerabilities, such as misuse by malware. Implementations are advised to appropriately protect cached roster data.</p>
</section1>

<section1 topic='IANA Considerations' anchor='iana'>
  <p>This document requires no interaction with &IANA;.</p> 
</section1>

<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
  <section2 topic='Protocol Namespaces' anchor='ns'>
    <p>Until this specification advances to a status of Draft, the associated namespace for its stream feature shall be "urn:xmpp:features:rosterver". Upon advancement of this specification, the &REGISTRAR; shall issue a permanent namespace in accordance with the process defined in Section 4 of &xep0053;; the requested namespace is "urn:xmpp:seq", which is thought to be unique per the XMPP Registrar's requirements.</p>
  </section2>
</section1>

<section1 topic='XML Schemas' anchor='schemas'>
  <p>This specification proposes addition of the 'ver' attribute to the schema for the 'jabber:iq:roster' namespace.</p>
</section1>

<section1 topic='Acknowledgements' anchor='ack'>
  <p>Thanks to Dave Cridland, Richard Dobson, Leonid Evdokimov, Fabio Forno, Alexander Gnauck, Juha Hartikainen, Joe Hildebrand, Justin Karneges, Sachin Khandelwal, Curtis King, Pedro Melo, Matthew Wild, and Jiří Zárevúcký for their comments. The definition of a sequence number borrows concepts and text from &rfc4551;</p>
</section1>

</xep>
