<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
  <title>Server Dialback</title>
  <abstract>This specification defines the Server Dialback protocol, which is used between XMPP servers to provide identity verification. Server Dialback uses the Domain Name System (DNS) as the basis for verifying identity; the basic approach is that when a receiving server accepts a server-to-server connection from an initiating server, it does not process XMPP stanzas over the connection until it has verified the initiating server's identity. Additionally, the protocol is used to negotiate whether the receiving server is accepting stanzas for the target domain. Although Server Dialback does not provide strong authentication and is subject to DNS poisoning attacks, it has effectively prevented most address spoofing on the XMPP network since its development in the year 2000.</abstract>
  &LEGALNOTICE;
  <number>0220</number>
  <status>Draft</status>
  <type>Standards Track</type>
  <sig>Standards</sig>
  <approver>Council</approver>
  <dependencies>
    <spec>XMPP Core</spec>
  </dependencies>
  <supersedes/>
  <supersededby/>
  <shortname>dialback</shortname>
  <schemaloc>
    <url>http://xmpp.org/schemas/dialback.xsd</url>
  </schemaloc>
  &jer;
  &stpeter;
  &fippo;
  <revision>
    <version>1.1.1</version>
    <date>2015-03-12</date>
    <initials>ssw</initials>
    <remark>Update DNA framework reference to RFC 7712.</remark>
  </revision>
  <revision>
    <version>1.1</version>
    <date>2014-08-05</date>
    <initials>ph/psa</initials>
    <remark>
      <ul>
        <li>Added resource-constraint dialback error condition.</li>
        <li>Provided guidance on the usage of the &lt;failed/&gt; dialback error.</li>
        <li>Clarified that the dialback error conditions table is not exhaustive and any stanza error condition can be used.</li>
      </ul>
    </remark>
  </revision>
  <revision>
    <version>1.0</version>
    <date>2013-09-27</date>
    <initials>psa</initials>
    <remark><p>Per a vote of the XMPP Council, advanced status to Draft.</p></remark>
  </revision>
  <revision>
    <version>0.15</version>
    <date>2013-08-27</date>
    <initials>psa/ph</initials>
    <remark><p>Addressed Last Call feedback and made editorial improvements.</p></remark>
  </revision>
  <revision>
    <version>0.14</version>
    <date>2012-08-21</date>
    <initials>ph</initials>
    <remark><p>Updated the Security Considerations to describe the 'Unsolicited Dialback Attack' and added recommendations to avoid this attack.</p></remark>
  </revision>
  <revision>
    <version>0.13</version>
    <date>2012-08-08</date>
    <initials>ph/psa</initials>
    <remark>
      <ul>
        <li>Allowed same SRV target in multiplexing business</li>
        <li>Added not-acceptable dialback error</li>
        <li>Changed hostnames to something more memorable.</li>
        <li>Added note about using certificates for "dialback-without-dial-back".</li>
        <li>Added note about not forwarding invalid.</li>
        <li>Added another figure for the examples, reordered examples accordingly.</li>
        <li>Notes about verify-only connections.</li>
        <li>Added note about bouncing stanzas with an &lt;internal-server-error/&gt; stanza error in section 2.1.1</li>
        <li>Clarified explanations thoughout the document.</li>
        <li>Added terminology section.</li>
        <li>Removed hokey telephone analogy.</li>
        <li>Removed section about when dialback is used, since it was misleading.</li>
        <li>Removed text about dialback offering only weak identify verification, since verification can be strong if DNSSEC is used.</li>
        <li>Corrected XML schema to support mixed content model with &lt;error/&gt; child.</li>
      </ul>
    </remark>
  </revision>
  <revision>
    <version>0.12</version>
    <date>2011-09-19</date>
    <initials>psa</initials>
    <remark><p>Corrected several small errors and added sentence about the undesirability of the stream features child element, per list discussion.</p></remark>
  </revision>
  <revision>
    <version>0.11</version>
    <date>2011-07-06</date>
    <initials>psa</initials>
    <remark><p>Per list discussion, reverted the stream features versioning that was added to version 0.10, thus reverting to the format used in versions 0.5 through 0.9 of the spec; corrected several errors in the examples.</p></remark>
  </revision>
  <revision>
    <version>0.10</version>
    <date>2011-05-16</date>
    <initials>psa</initials>
    <remark><p>Modified stream features to incorporate versioning, thus removing the need for an &lt;errors/&gt; child element; clarified a few points in the text.</p></remark>
  </revision>
  <revision>
    <version>0.9</version>
    <date>2011-04-25</date>
    <initials>psa</initials>
    <remark><p>To reduce the possibility of confusion, harmonized the protocol sections so that they show only the first dialback negotiation from Initiating Server to Receiving Server.</p></remark>
  </revision>
  <revision>
    <version>0.8</version>
    <date>2011-04-19</date>
    <initials>ph/psa</initials>
    <remark><p>Per list discussion, restored requirement for Receiving Server to close the stream if the dialback key is invalid, since application of dialback to multiple domain pairs will use dialback packets of type error, not type invalid.</p></remark>
  </revision>
  <revision>
    <version>0.7</version>
    <date>2011-04-14</date>
    <initials>ph/psa</initials>
    <remark><p>Removed stream feature for advertising mere protocol support, using it only for advertising support for enhanced error handling.</p></remark>
  </revision>
  <revision>
    <version>0.6</version>
    <date>2011-04-13</date>
    <initials>psa</initials>
    <remark><p>Updated to reflect RFC 6120; mandated support for stream feature in XMPP 1.0 implementations; removed requirement for the Receiving Server to close the stream if the dialback key is invalid, since the stream might be used for multiple domain pairs.</p></remark>
  </revision>
  <revision>
    <version>0.5</version>
    <date>2010-03-18</date>
    <initials>ph</initials>
    <remark><p>Added policy-violation and not-authorized error conditions</p></remark>
  </revision>
  <revision>
    <version>0.4</version>
    <date>2009-08-05</date>
    <initials>ph/psa</initials>
    <remark>
      <ul>
        <li>Changed description and order of steps.</li>
        <li>Made clear that dialback consists of two mostly independent subprotocols.</li>
        <li>Further piggybacking clarifications.</li>
        <li>Defined extended usage of dialback errors, obsoleting stream errors.</li>
        <li>Specified extended error conditions.</li>
        <li>Added stream feature details for new-style error behavior.</li>
        <li>Added multiplexing notes.</li>
        <li>Updated schemas.</li>
      </ul>
    </remark>
  </revision>
  <revision>
    <version>0.3</version>
    <date>2008-10-16</date>
    <initials>psa</initials>
    <remark><p>Completed copy edit; clarified several points in the text; corrected several examples.</p></remark>
  </revision>
  <revision>
    <version>0.2</version>
    <date>2008-06-18</date>
    <initials>psa</initials>
    <remark>
      <ul>
        <li>Rewrote introduction.</li>
        <li>Provided motivating text about why dialback is used.</li>
        <li>Added text about different federation models.</li>
        <li>More clearly described what dialback accomplishes and what it does not accomplish.</li>
        <li>Added explanatory text about scenarios in which Server Dialback is used and not used.</li>
        <li>Clarified basic description of how dialback works.</li>
        <li>Clarified discovery of dialback support.</li>
        <li>Separated sections into subsections, as has been done for the revisions to RFC 3920 and RFC 3921.</li>
        <li>Described the protocol flows in much greater detail.</li>
        <li>Explained and illustrated failure cases more completely.</li>
        <li>Clarified reuse of negotiated connections, a.k.a. piggybacking.</li>
      </ul>
    </remark>
  </revision>
  <revision>
    <version>0.1</version>
    <date>2007-07-11</date>
    <initials>psa</initials>
    <remark><p>Initial published version.</p></remark>
  </revision>
  <revision>
    <version>0.0.1</version>
    <date>2007-06-22</date>
    <initials>psa</initials>
    <remark><p>Content moved from the revisions to RFC 3920.</p></remark>
  </revision>
</header>

<section1 topic="Introduction" anchor="intro">
  <section2 topic="Why Dialback?" anchor="intro-why">
    <p>When Jabber technologies were first developed in 1998, they were conceived of as a client-server system similar to email, wherein a client would connect to a server in order to communicate with other clients. Similarly, servers would connect with peer servers to provide inter-domain communication (often called "federation"). In a system that allows federation, it is important for a server to be able to determine the identity of a peer server. Therefore the Jabber developer community designed a protocol called "Server Dialback" for identity verification based on the Domain Name System (DNS), built support for that protocol into the jabberd 1.2 server (released in October 2000), and mandated support for that protocol on the emerging Jabber server network.</p>
    <p>The basic idea behind Server Dialback is that a receiving server does not accept XMPP traffic from a sending server until it has (a) "called back" the authoritative server for the domain asserted by the sending server and (b) verified that the sending server is truly authorized to generate XMPP traffic for that domain. The protocol also ensures that the receiving server is accepting stanzas for the target domain.</p>
    <p>When the early Jabber protocols were formalized by the XMPP Working Group of the &IETF; in 2002-2004, support for strong identity verification was added (see &rfc3920;, since updated by &rfc6120;). That support takes the form of Transport Layer Security (TLS) for encryption of server-to-server XML streams and the Simple Authentication and Security Layer (SASL) for authentication of such streams, typically using digital certificates issued by trusted root certification authorities (CAs). However, the Server Dialback protocol is still in wide use. In addition, the slow but steady deployment of the DNS security extensions (DNSSEC) &rfc4033; can provide a stronger basis for using Server Dialback.</p>
  </section2>

  <section2 topic="What Dialback Accomplishes" anchor="intro-what">
    <p>Server Dialback is a method for identity verification: if the dialback negotiation succeeds, the receiving server for an XML stream can associate a pair of domain names with the stream; those two domain names are the sender domain asserted by the initiating server and the domain name at the receiving server that the initiating server has indicated it wishes to communicate with.</p>
    <p>Traditionally, the verification accomplished in Server Dialback has depended on the Domain Name System (DNS) and the use of keys based on a shared secret known to all XMPP servers within a given administrative domain. It is a proof-of-possession protocol in the sense of &rfc4949; which asserts that the initiating server and the authoritative server are associated with each other. The relative strength or weakness of the verification depends in part on the strength or weakness of the process for resolving the domain names of the authoritative server; in particular, if DNSSEC is not used then Server Dialback results in weak identity verification, whereas if DNSSEC is used then Server Dialback can result in fairly strong identity verification.</p>
    <p>Since October 2000, the use of Server Dialback (even absent DNSSEC) has made it more difficult to spoof the hostnames of servers (and therefore the addresses of sent messages) on the XMPP network.</p>
    <p>Server Dialback is unidirectional, and results in verification for one XML stream in one direction. Because traditionally Server-to-Server connections are used unidirectionally, Server Dialback needs to be completed in each direction in order to enable bidirectional communication between two domains (unless &xep0288; is used).</p>
    <p>Furthermore, because a separate TCP connection is mandated for each domain pair, the use of server dialback results in significant scalability challenges for large XMPP service providers that host many domains (see &rfc7712; for a possible solution).</p>
    <p>Finally, dialback signalling can be used without basing the identity verification on checking of the dialback key provided by the Initiating Server.  As one example, if Transport Layer Security (TLS) is used then the Receiving Server can attempt to verify the certificate presented by the Initiating Server, either according to the PKIX-based rules specified in &xep0178;, <cite>RFC 6120</cite>, and &rfc6125; or by checking that the public key or certificate of the Initiating Server matches a public key or certificate obtained via &posh;. However, this technique of using dialback signalling without verifying the dialback key (sometimes called "dialback without dialing back" since the Receiving Server does not contact the Authoritative Server) is not described in this document.</p>
  </section2>

  <section2 topic="Terminology" anchor="intro-terms">
    <p>This document uses the following terms.</p>
    <dl>
      <di><dt>Authoritative Server</dt><dd>The machine that is discovered by means of a DNS lookup for the Sender Domain; for simple deployments this will be the Initiating Server, but it could be a separate machine in the Initiating Server's network (where "network" is defined by knowledge of a shared secret for verification of dialback keys).</dd></di>
      <di><dt>Domain Pair</dt><dd>The combination of the Sender Domain and Target Domain.</dd></di>
      <di><dt>Initiating Server</dt><dd>The machine that wants to send a message from an entity at the Sender Domain to an entity at the Target Domain (and thus the machine that is attempting to establish a domain name association between (a) the Target Domain and (b) the XML stream from the Initiating Server to the Receiving Server). Note well that in older documentation of the Server Dialback protocol, this was called the Originating Server.</dd></di>
      <di><dt>Receiving Server</dt><dd>The machine to which the Initiating Server has opened a connection for the purpose of sending a message from the Sender Domain to the Target Domain (and thus the machine that is trying to verify that the Initiating Server represents the Sender Domain).</dd></di>
      <di><dt>Sender Domain</dt><dd>The domain name asserted by the Initiating Server as the domainpart of the XMPP 'from' address of stanzas that will flow over the XML stream from the Initiating Server to the Receiving Server.</dd></di>
      <di><dt>Target Domain</dt><dd>The domain name specified by the Initiating Server as the domainpart of the XMPP 'to' address of stanzas that will flow over the XML stream from the Initiating Server to the Receiving Server.</dd></di>
    </dl>
  </section2>

  <section2 topic="How Dialback Works" anchor="intro-howitworks">
    <p>Server Dialback is used when a stanza that is to be sent from a Sender Domain must be routed to a Target Domain and there is not yet an established connection between the domains. The basic flow of events in Server Dialback consists of the following four steps:</p>
    <ol start='1'>
      <li><p>The Initiating Server generates a dialback key and sends that value over its XML stream with the Receiving Server. (If the Initiating Server does not yet have an XML stream to the Receiving Server, it will first need to perform a DNS lookup on the Target Domain and thus discover the Receiving Server, open a TCP connection to the discovered IP address and port, and establish an XML stream with the Receiving Server.)</p></li>
      <li><p>Instead of immediately accepting XML stanzas on the connection from the Initiating Server, the Receiving Server sends the same dialback key over its XML stream with the Authoritative Server for verification.  (If the Receiving Server does not yet have an XML stream to the Authoritative Server, it will first need to perform a DNS lookup on the Sender Domain and thus discover the Authoritative Server, open a TCP connection to the discovered IP address and port, and establish an XML stream with the Authoritative Server.)</p></li>
      <li><p>The Authoritative Server informs the Receiving Server whether the key is valid or invalid.</p></li>
      <li><p>The Receiving Server informs the Initiating Server whether its identity has been verified or not.</p></li>
    </ol>
    <p>After Step 4, the Initiating Server is authorized to send stanzas from the Sender Domain to the Target Domain as communicated in the 'to' and 'from' attributes of the dialback negotiation. In addition to identity verification of the Sender Domain, this also ensures that the Receiving Server is accepting stanzas for the Target Domain.</p>
    <p>We can represent the flow of events graphically as follows.</p>

    <code><![CDATA[
Initiating                 Receiving
  Server                    Server
-----------               ---------
    |                          |
    |  [if necessary,          |
    |   perform DNS lookup     |
    |   on Target Domain,      |
    |   open TCP connection,   |
    |   and establish stream]  |
    | -----------------------> |
    |                          |                   Authoritative
    |   send dialback key      |                       Server
    | -------(STEP 1)--------> |                   -------------
    |                          |                          |
    |                          |  [if necessary,          |
    |                          |   perform DNS lookup,    |
    |                          |   on Sender Domain,      |
    |                          |   open TCP connection,   |
    |                          |   and establish stream]  |
    |                          | -----------------------> |
    |                          |                          |
    |                          |   send verify request    |
    |                          | -------(STEP 2)--------> |
    |                          |                          |
    |                          |   send verify response   |
    |                          | <------(STEP 3)--------- |
    |                          |
    |  report dialback result  |
    | <-------(STEP 4)-------- |
    |                          |
]]></code>
  </section2>
</section1>

<section1 topic="Protocol" anchor="protocol">
  <p>This section describes the protocol in detail.</p>
  <p>Assumptions used in the examples:</p>
  <ul>
    <li>The server hosting "capulet.example" is acting as the Initiating Server in sections 2.1.1 and 2.2.1 and as the Receiving Server in sections 2.1.2 and 2.2.2. A DNS SRV lookup on "capulet.example" resolves to "orchard.capulet.example".</li>
    <li>The server hosting "montague.example" is acting as Receiving Server in sections 2.1.1 and 2.2.2 and as Authoritative Server in sections 2.1.2 and 2.2.2. A DNS SRV lookup on "montague.example" resolves to the machine "home.montague.example"</li>
    <li>The stream ID of the response stream header sent from "capulet.example" to "montague.example" is "D60000229F".</li>
    <li>The stream ID of the response stream header sent from "montague.example" to "capulet.example" is "417GAF25".</li>
    <li>The shared secret within the "capulet.example" domain is "s3cr3tf0rd14lb4ck".</li>
    <li>The shared secret within the "montague.example" domain is "d14lb4ck43v3r".</li>
  </ul>
  <p>Note: All XML elements qualified by the Server Dialback namespace MUST be prefixed with the namespace prefix for the 'jabber:server:dialback' namespace as advertised on the stream header originally sent by the entity sending the element. <note>RFC 3920 stipulated that "an implementation SHOULD generate only the 'db:' prefix for such elements and MAY accept only the 'db:' prefix." This restriction was included for the sake of backward compatibility with the jabberd 1.x codebase.</note></p>
  <p>This section can be read in two ways:</p>
  <ol>
    <li><p>To understand the overall protocol flow of each dialback negotiation, read Section 2.1.1 and Section 2.2.1 (aspects of the dialback negotiation from capulet.example as Initiating Server to montague.example as Receiving Server), then Section 2.1.2 and 2.2.2 (aspects of the dialback negotiation from montague.example as Initiating Server to capulet.example as Receiving Server).</p></li>
    <li><p>To implement the code for either an outbound connection or an inbound connection, read Section 2.1 (outbound) or Section 2.2 (inbound). Note that both parts can be implemented, tested, and used separately.</p></li>
  </ol>
  <p>The following figure gives an overview of where each example is embedded in the process and illustrates the changing roles of each server.</p>
  <code><![CDATA[
orchard.capulet.     home.montague.
example              example
(as Initiating)      (as Receiving
   Server)              Server)
----------------     -------------
    |                    |
    |  [if necessary,    |
    |   perform DNS      |
    |   lookup on        |
    |   Target Domain,   |
    |   open TCP         |
    |   connection,      |
    |   and establish    |
    |   stream]          |
    | -----------------> |
    |  (ID D60000229F)   |
    |                    |
    |      send          |               capulet.example
    |  dialback key      |             (as Authoritative
    | -----(STEP 1)----> |                 Server)
    |   Ex 1 / 9         |             -----------------
    |                    |  [if necessary,    |
    |                    |   perform DNS      |
    |                    |   lookup on        |
    |                    |   Sender Domain,   |
    |                    |   open TCP         |
    |                    |   connection,      |
    |                    |   and establish    |
    |                    |   stream]          |
    |                    | -----------------> |
    |                    |                    |
    |                    |       send         |
    |                    |   verify request   |
    |                    | ----(STEP 2)-----> |
    |                    |                    |
    |                    |       send         |
    |                    |   verify response  |
    |                    | <----(STEP 3)----- |
    |                    |                    |
    |      report        |                    |
    |  dialback result   |                    |
    | <-----(STEP 4)---- |                    |
    |  Ex 2,3,4/10,11,12 |                    |
    |                    |                    |
    | - stanzas flow ->  |                    |
    |  from              |                    |
    |   capulet.example  |                    |
    |  to                |                    |
    |   montague.example |                    |
    |                    |                    |
    |                montague.example    capulet.example
    |                (as Initiating      (as Receiving
    |                  Server)              Server)
    |                 ---------           ----------
    |                    |                    |
    |                    |  [may reuse        |
    |                    |   connection or    |
    |                    |   open new stream] |
    |                    | -----------------> |
    |                    |   (ID 417GAF25)    |
    |                    |                    |              montague.example
    |                    |       send         |             (as Authoritative
    |                    |   dialback key     |                 Server)
    |                    | -----(STEP 1)----> |               -----------
    |                    |                    |                    |
    |                    |                    |  [may reuse        |
    |                    |                    |   connection or    |
    |                    |                    |   open new stream] |
    |                    |                    | -----------------> |
    |                    |                    |                    |
    |                    |                    |       send         |
    |                    |                    |   verify request   |
    |                    |                    | -----(STEP 2)----> |
    |                    |                    |  Ex 5 / 13         |
    |                    |                    |                    |
    |                    |                    |       send         |
    |                    |                    |   verify response  |
    |                    |                    | <----(STEP 3)----- |
    |                    |                    |  Ex 6,7,8/14,15,16 |
    |                    |                    |                    |
    |                    |       report       |                    |
    |                    |   dialback result  |                    |
    |                    | <----(STEP 4)----- |                    |
    |                    |                    |                    |
    |                    | - stanzas flow ->  |                    |
    |                    |  from              |                    |
    |                    |   montague.example |                    |
    |                    |  to                |                    |
    |                    |   capulet.example  |                    |
]]></code>

  <section2 topic="Outbound Connection">
    <p>On an outbound connection there are two different tasks:</p>
    <ol>
      <li>Request authorization to send stanzas from a Sender Domain to a Target Domain, i.e., act as an Initiating Server in relation to a Receiving Server; this is is described under Section 2.1.1.</li>
      <li>Generate verification requests about the validity of dialback keys, i.e., act as a Receiving Server in relation to an Authoritative Server; this is described under Section 2.1.2.</li>
    </ol>

    <section3 topic="Initiating Server Generates Outbound Request for Authorization by Receiving Server">
      <p>This subsection describes the interaction between the server hosting capulet.example (acting as an Initiating Server) and the server hosting montague.example (acting as a Receiving Server), from the outbound perspective of the Initiating Server.</p>
      <p>When the Initiating Server has stanzas to send from the Sender Domain to the Target Domain, does not have a verified connection, is currently not attempting to get a verified connection for this domain pair, it sends a new dialback key to the Receiving Server.</p>
      <p>To do so, either it can reuse an existing XML stream or it needs to establish a new connection. To establish a new connection, the Initiating Server performs a DNS lookup on the Target Domain, thus finding the IP address and port for server-to-server communication at an authoritative machine for the Target Domain (here that is "home.montague.example").</p>
      <p>After the XML stream is established from the Initiating Server to the Receiving Server, the Initiating Server sends a dialback key to the Receiving Server. This is done by creating a &lt;db:result/&gt; element whose XML character data is the dialback key; the element MUST possess a 'from' attribute whose value is the Sender Domain and MUST possess a 'to' attribute whose value is the Target Domain.</p>
      <example caption="Initiating Server Sends Dialback Key (Step 1)"><![CDATA[
send: <db:result
          from='capulet.example'
          to='montague.example'>
        b4835385f37fe2895af6c196b59097b16862406db80559900d96bf6fa7d23df3
      </db:result>
]]></example>
      <p>The key sent is generated as described in &xep0185;:</p>
      <code>
key = HMAC-SHA256(
        SHA256('s3cr3tf0rd14lb4ck'),
          { 'montague.example', ' ', 'capulet.example', ' ', 'D60000229F' }
      )
    = b4835385f37fe2895af6c196b59097b16862406db80559900d96bf6fa7d23df3
      </code>
      <p>Note: The Receiving Server MAY use any method to determine the validity of the dialback key and the identity of the Initiating Server. The Initiating Server MUST NOT make any assumptions about how the Receiving Server verifies the key, including even the assumption that the key is actively verified by the Receiving Server through communication with the Authoritative Server.</p>
      <p>After sending the dialback key, the Initiating Server waits for the verification result from the Receiving Server. If the Initiating Server wishes to send any stanzas for this domain pair, it MUST queue them for sending after it has received authorization to send stanzas from the Receiving Server, and MUST NOT attempt to send stanzas until it has received such authorization.</p>
      <p>Note: While waiting for the verification result, the Initiating Server SHOULD continue to send stanzas for any domain pair that has already been verified on that connection. It MAY send out additional dialback keys for different domain pairs and issue dialback verification requests as described under Section 2.1.2. To avoid denial of service attacks (&rfc4732;) or deadlock situations, the Initiating Server MAY impose a timeout on dialback operations, i.e. it ought to consider dialback operations as having failed when there is no response after a certain amount of time.</p>
      <p>If the stream or the underlying TCP connection is closed by the Receiving Server while the Initiating Server is waiting for the verification result, the Initiating Server shall behave as it does when receiving a dialback error as described below.</p>
      <p>After the Receiving Server has verified the request, the Initiating Server receives the verification result in the form of a &lt;db:result/&gt; element with a the 'type' attribute whose value is "valid" or "invalid" (for the value of "error", see below). The Initiating Server MUST ensure that the 'from' and 'to' attributes in this response correlate to a request that was sent over the same XML stream (see Section 3.1).</p>
      <p>Thus the result is either valid...</p>
      <example caption="Initiating Server Receives Valid Verification Result from Receiving Server (Step 4)"><![CDATA[
recv: <db:result
          from='montague.example'
          to='capulet.example'
          type='valid'/>
]]></example>
      <p>... or invalid ...</p>
      <example caption="Initiating Server Receives Invalid Verification Result from Receiving Server (Step 4)"><![CDATA[
recv: <db:result
          from='montague.example'
          to='capulet.example'
          type='invalid'/>
]]></example>
      <p>Note: There are no examples for Step 2 and Step 3 in this section of the document; see the examples under Sections 2.1.2 and 2.2.2.</p>
      <p>If the value of the 'type' attribute is "valid", then the connection between the domain pair is considered verified and the Initiating Server can send any outbound stanzas it has queued up for routing to the Receiving Server for the domain pair (i.e., from the Sender Domain to the Target Domain). Naturally, the Initiating Server can also enable or negotiate other stream features at this point.</p>
      <p>If the value of the 'type' attribute is "invalid", then the Receiving Server is reporting that that Initiating Server's identity (as valid for the Sender Domain) was deemed bogus by the Authoritative Server. In this case, the Initiating Server MUST NOT attempt to send any outbound stanzas it has queued up for routing to the Receiving Server for the domain pair but instead MUST return such stanzas to the respective senders at the Sender Domain with an &internalserver; stanza error. Since the Receiving Server will most likely close the stream and the underlying TCP connection if that occurs (see Section 2.2.1), the Initiating Server SHOULD NOT attempt to send further stanzas for other domain pairs that have already been authorized.</p>
      <p>If the value of the 'type' attribute is "error", this indicates a problem which is not related to the validity of the dialback key provided. The error conditions are explained in detail under <link url='#advertisement-errors'>Dialback with Error Handling</link>. Such an error is non-fatal for the XML stream, but the Initiating Server MUST return any queued stanzas to the respective senders at the Sender Domain with a &timeout; stanza error.</p>
      <example caption="Initiating Server Receives Dialback Error from Receiving Server (Step 4)"><![CDATA[
recv: <db:result
          from='montague.example'
          to='capulet.example'
          type='error'>
        <error type='cancel'>
          <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
        </error>
      </db:result>
]]></example>
    </section3>

    <section3 topic="Receiving Server Generates Outbound Request for Verification of Initiating Server by Authoritative Server">
      <p>This subsection describes the interaction between the server hosting capulet.example (acting as a Receiving Server) and the server hosting montague.example (acting as an Authoritative Server), from the outbound perspective of the Receiving Server.</p>
      <p>To determine the validity of a dialback key received from the Initiating Server, the Receiving Server needs to establish communications with the Authoritative Server. To do so, it can reuse an existing XML stream or establish a new connection. To establish a new connection, the Receiving Server performs a DNS lookup on the Sender Domain, thus finding the IP address and port for server-to-server communication at an authoritative machine for the Sender Domain asserted by the Initiating Server (here the machine is "orchard.capulet.example").</p>
      <p>After the XML stream is established from the Receiving Server to the Authoritative Server, the Receiving Server sends a verification request. This is done by creating a &lt;db:verify/&gt; element whose XML character data is the dialback key received from the Initiating Server; the element MUST possess a 'from' attribute whose value is the Target Domain, MUST possess a 'to' attribute whose value is the Sender Domain as provided in the 'from' attribute of Step 1, and MUST possess an 'id' attribute whose value is the stream ID of the response stream header sent from the Receiving Server to the Initiating Server (here "417GAF25"). The combination of 'from', 'to', and 'id' attributes makes it possible for the Receiving Server to uniquely identify the TCP connection on which it received the original request in Step 1.</p>
      <p>Note: An implementation MAY open a separate connection to the Authoritative Server for the sole purpose of doing key verification. Such an implementation SHOULD close the connection immediately after receiving the verification result. Not using TLS or any other stream features can reduce the number of round trips in that case.</p>
      <example caption="Receiving Server Sends Verification Request to Authoritative Server (Step 2)"><![CDATA[
send: <db:verify
          from='capulet.example'
          id='417GAF25'
          to='montague.example'>
       225cc5aa6a071133249d25fef42ae516fc7a86c523aa1c6980a7f73e784c972d
     </db:verify>
]]></example>
      <p>After that, the Receiving Server waits for the verification result. While doing so, it can still use the connection to send dialback packets or to send stanzas for domain pairs that have already been validated.</p>
      <p>Here again, the result is either valid...</p>
      <example caption="Receiving Server is Informed by Authoritative Server that Key is Valid (Step 3)"><![CDATA[
recv: <db:verify
          from='montague.example'
          id='417GAF25'
          to='capulet.example'
          type='valid'/>
]]></example>
      <p>... or invalid ...</p>
      <example caption="Receiving Server is Informed by Authoritative Server that Key is Invalid (Step 3)"><![CDATA[
recv: <db:verify
          from='montague.example'
          id='417GAF25'
          to='capulet.example'
          type='invalid'/>
]]></example>
      <p>In addition to the values "valid" and "invalid", the 'type' attribute can also have a value of "error"; see <link url='#advertisement-errors'>Dialback with Error Handling</link> for a detailed explanation.</p>
      <example caption="Receiving Server Receives Dialback Error from Authoritative Server (Step 3)"><![CDATA[
recv: <db:verify
          from='montague.example'
          id='417GAF25'
          to='capulet.example'
          type='error'>
        <error type='cancel'>
          <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
        </error>
     </db:verify>
]]></example>
      <p>Note: If the underlying TCP connection is closed by the remote side while there are pending verification requests, those requests SHOULD be considered failed and therefore be treated like an error response.</p>
      <p>The Receiving Server MUST ensure that the values of the 'from', 'to' and 'id attributes correlate to a request that was sent over the same XML stream (see Section 3.1).</p>
      <p>After receiving the validation result from the Authoritative Server, the Receiving Server determines the inbound connection that the dialback key was originally received on. This connection is uniquely identified by the combination of the 'from', 'to', and 'id' attributes. If no inbound connection is found that matches this combination, the verification result SHOULD be dropped silently. If an inbound connection is found, the Receiving Server uses it to communicate the verification result to the Initiating Server. A positive result indicates the readiness of the Receiving Server to accept stanzas from the Initiating Server for this domain pair.</p>
      <p>When receiving a verification result of type "invalid", the Receiving Server MAY choose not to relay this result to the Initiating Server. Instead, it might send a dialback error such as &lt;forbidden/&gt; to the Initiating Server. Compared to sending a result of type "invalid", this behavior will not result in the loss of the whole stream and any previously domain pairs previously negotiated, while at the same time not accepting stanzas from the spoofed domain. Even when not forwarding the "invalid" result, the incident ought to be logged.</p>
    </section3>
  </section2>

  <section2 topic="Inbound Connection">

    <p>There are two different tasks on an inbound connection:</p>
    <ol>
      <li>Authorize inbound connections, i.e., act as a Receiving Server in relation to an Initiating Server; this is described under Section 2.2.1.</li>
      <li>Answer verification requests about the validity of dialback keys, i.e., act as an Authoritative Server in relation to a Receiving Server; this is described under Section 2.2.2.</li>
    </ol>
    <p>Note that, unless <cite>XEP-0288</cite> is used, the 'type' should not be set on either &lt;db:result/&gt; or &lt;db:verify/&gt; elements received on an inbound connection.</p>

    <section3 topic="Receiving Server Handles Inbound Authorization Request from Initiating Server">
      <p>This subsection describes the interaction between the server hosting capulet.example (acting as an Initiating Server) and the server hosting montague.net (acting as a Receiving Server), from the inbound perspective of the Receiving Server (i.e., this section is the mirror image of Section 2.1.1).</p>
      <example caption="Receiving Server Receives Dialback Key from Initiating Server (Step 1)"><![CDATA[
recv: <db:result
          from='capulet.example'
          to='montague.example'>
        b4835385f37fe2895af6c196b59097b16862406db80559900d96bf6fa7d23df3
      </db:result>
]]></example>
      <p>Before the Receiving Server allows the Initiating Server to send stanzas from the Sender Domain (here "capulet.example") to the Target Domain (here "montague.example"), it MUST verify the identity of the Initiating Server. Depending on how the server dialback protocol is used, this can be done by verifying the dialback key or by using some out-of-band method as in the POSH prooftype for XMPP domain name associations. Note that the verification process might fail prematurely, for example, if the Receiving Server's policy states that connections from the Initiating Server or the Sender Domain are not allowed.</p>
      <p>Note: The Receiving Server MUST continue to accept and process stanzas for already verified domain pairs, and MUST continue to process both &lt;db:result/&gt; and &lt;db:verify/&gt; elements.</p>
      <p>If the Target Domain as given in the 'to' attribute of the element is not a configured domain of the Receiving Server, this results in a dialback error. This error, which is explained further under <link url='#advertisement-errors'>Section 2.4.2</link>, is not a stream error and therefore MUST NOT result in closing of the stream as described in Section 4.4 of <cite>RFC 6120</cite>, since the stream might already be used to exchange XML stanzas for other domain pairs.</p>
      <example caption="Receiving Server Sends Dialback Error to Initiating Server (Step 4)"><![CDATA[
send: <db:result
          from='montague.example'
          to='capulet.example'
          type='error'>
        <error type='cancel'>
          <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
        </error>
      </db:result>
]]></example>
      <p>After the validity of the dialback request has been established (for example, by the Authoritative Server), the Receiving Server can safely accept stanzas from the Initiating Server for the verified domain pair.</p>
      <p>In addition, the Receiving Server SHALL notify the Initiating Server of the result and thus signal its willingness to accept stanzas from the Initiating Server for the verified domain pair.  This is done by creating a &lt;db:result/&gt; element which MUST possess a 'from' attribute whose value is the Target Domain, MUST possess a 'to' attribute whose value is the Sender Domain, and MUST possess a 'type' attribute whose value is either "valid" or "invalid" (or "error", as shown above).</p>
      <p>Therefore, here again the result is either valid (this is the same as Example 2)...</p>
      <example caption="Receiving Server Sends Valid Verification Result to Initiating Server (Step 4)"><![CDATA[
send: <db:result
          from='montague.example'
          to='capulet.example'
          type='valid'/>
]]></example>
      <p>... or invalid (this is the same as Example 3)...</p>
      <example caption="Receiving Server Sends Invalid Verification Result to Initiating Server (Step 4)"><![CDATA[
send: <db:result
          from='montague.example'
          to='capulet.example'
          type='invalid'/>
]]></example>
      <p>If the result is "invalid", the Initiating Server is either attempting to spoof the Sender Domain or is misconfigured. The Receiving Server MUST NOT accept stanzas from the Initiating Server for the Sender Domain and ought to log the attempt. If no other valid domain pairs exist for this connection (i.e., if this is the first attempt), the Receiving Server SHOULD send a result with type "invalid" and MUST close the XML stream. If there exist other valid domain pairs for this connection, the Initiating Server might merely have a misconfiguration for the Sender Domain. In this case, the Receiving Server MAY (instead of closing the connection) return an error condition of &lt;forbidden/&gt; as described under Section 2.5 of this document.</p>
    </section3>

    <section3 topic="Authoritative Server Handles Inbound Verification Request from Receiving Server">
      <p>This subsection describes the interaction between the server hosting capulet.example (acting as a Receiving Server) and the server hosting montague.example (acting as an Authoritative Server), from the inbound perspective of the Authoritative Server (i.e., this section is the mirror image of Section 2.1.2 and the following example is the same as Example 5).</p>
      <example caption="Authoritative Server Receives Verification Request from Receiving Server (Step 2)"><![CDATA[
recv: <db:verify
          from='capulet.example'
          id='417GAF25'
          to='montague.example'>
       225cc5aa6a071133249d25fef42ae516fc7a86c523aa1c6980a7f73e784c972d
     </db:verify>
]]></example>
      <p>If the Target Domain as given in the 'to' attribute of the element does not match a configured local domain according to the Authoritative Server, this results in a dialback error. This error, which is explained further under Section 2.4, is not a stream error and therefore MUST NOT result in closing of the stream (as described in Section 4.4 of <cite>RFC 6120</cite>), since the stream might already be used for sending XML stanzas for other domain pairs. (The following example is the same as Example 8.)</p>
      <example caption="Authoritative Server Sends Dialback Error to Receiving Server (Step 3)"><![CDATA[
send: <db:verify
          from='montague.example'
          id='417GAF25'
          to='capulet.example'
          type='error'>
        <error type='cancel'>
          <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
        </error>
      </db:verify>
]]></example>
      <p>Upon receiving this &lt;db:verify/&gt; element, the Authoritative Server determines the validity of the dialback key provided in the XML character data of the element. This can be achieved for example by comparing the character data with the output of applying the same key generation mechanism that was (presumably) used for the generation of the key, using as input the values of the 'from', 'to', and 'id' attributes contained in the verification request and the secret known only to the Sender Domain:</p>
      <code>
key = HMAC-SHA256(
        SHA256('d14lb4ck43v3r'),
          { 'capulet.example', ' ', 'montague.example', ' ', '417GAF25' }
      )
    = 225cc5aa6a071133249d25fef42ae516fc7a86c523aa1c6980a7f73e784c972d
      </code>
      <p>The Authoritative Server then notifies the Receiving Server whether the key is valid. This is done by creating a &lt;db:verify/&gt; element which MUST possess 'from' and 'to' attributes whose values are swapped from the request, MUST possess an 'id' attribute whose value is copied from the 'id' value of the request, and MUST possess a 'type' attribute whose value is either "valid" or "invalid".</p>
      <p>Therefore, here again the result is either valid (this is the same as Example 6)...</p>
      <example caption="Authoritative Server Informs Receiving Server that Key is Valid (Step 3)"><![CDATA[
send: <db:verify
          from='montague.example'
          id='417GAF25'
          to='capulet.example'
          type='valid'/>
]]></example>
      <p>... or invalid (this is the same as Example 7)...</p>
      <example caption="Authoritative Server Informs Receiving Server that Key is Invalid (Step 3)"><![CDATA[
send: <db:verify
          from='montague.example'
          id='417GAF25'
          to='capulet.example'
          type='invalid'/>
]]></example>
      <p>There are several reasons why the key might be invalid (e.g., the Authoritative Server has a different secret key or the Authoritative Server doesn't know anything about the StreamID communicated in the &lt;db:result/&gt; element it received from the Receiving Server).</p>
    </section3>
  </section2>

  <section2 topic="Directionality" anchor='directionality'>
    <p>The result of the protocol exchanges shown in the foregoing two sections is that the server hosting montague.example has verified the identity of the server hosting capulet.example. Since XMPP Server-to-Server connections are unidirectional (unless <cite>XEP-0288</cite> is used), dialback needs to be completed in each direction before XML stanzas can be exchanged over the two TCP connections between the servers.</p>
  </section2>

  <section2 topic="Advertisement" anchor='advertisement'>

    <section3 topic="Traditional Dialback" anchor='advertisement-traditional'>
      <p>Support for the traditional server dialback protocol (originally specified in <cite>RFC 3920</cite>) is indicated by inclusion of the dialback namespace declaration in the stream header.</p>
      <example caption="Stream Header With Dialback Namespace Declaration"><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:db='jabber:server:dialback'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='montague.example'
    to='capulet.example'>
]]></example>
      <p>Note: Although in general advertising protocol support by means of an XML namespace declaration has been superseded by the use of stream features as originally defined in <cite>RFC 3920</cite> and updated in <cite>RFC 6120</cite>, the server dialback protocol predates the existence of stream features and therefore the namespace declaration method is still used in this instance.</p>
      <p>Note: It is conventional to use a namespace prefix of "db" for Server Dialback elements. Although the prefix is allowed to be other than "db" according to the XML namespaces specification (&w3xmlnamespaces;), some existing implementations and deployments might accept only the "db" prefix.</p>
    </section3>

    <section3 topic="Dialback with Error Handling" anchor='advertisement-errors'>
      <p>If a server supports graceful handling of dialback errors as described in this document, it MUST advertise that via a stream feature which is a &lt;dialback/&gt; element qualified by the 'urn:xmpp:features:dialback' namespace, including an empty &lt;errors/&gt; element.</p>
      <example caption="Stream Features With &lt;errors/&gt; Element"><![CDATA[
<stream:features>
  <dialback xmlns='urn:xmpp:features:dialback'>
    <errors/>
  </dialback>
</stream:features>
]]></example>
      <p>Note: As a general rule, stream feature elements containing child elements that advertise particular sub-features are not encouraged. The format shown above is used for the sake of backward compatiblity with existing implementations and deployments.</p>
    </section3>
  </section2>

  <section2 topic="Dialback Error Conditions" anchor='errors'>
    <!-- credits: Matthias in http://mail.jabber.org/pipermail/standards/2007-June/015662.html -->
    <p><cite>RFC 3920</cite> introduced stream errors for any errors related to dialback. However, this turned out to be overly aggressive, particularly if the XML stream was used to multiplex stanzas for more than one domain pair (since closing the stream would result in throwing away accumulated dialback state for a potentially large number of domain pairs). Therefore this specification defines a third value for the 'type' attribute: "error".</p>
    <p>This usage of the 'error' value for the 'type' attribute is not fully backward compatible with <cite>RFC 3920</cite>. However, the server that generates the error SHOULD still attempt to send the dialback error instead of terminating the stream, as the worst thing that can happen is that the remote server terminates the stream if it does not understand the error or if it eventually times out the connection. Dialback errors are to be considered non-fatal for the XML stream, but the Initiating Server MUST return queued stanzas to the respective senders with a &timeout; stanza error. If an error is encountered in Step 3 of the dialback negotiation, the Receiving Server MUST send a &lt;remote-server-not-found/&gt; dialback error to the Initiating Server.</p>
    <p>When the &lt;db:verify/&gt; or &lt;db:result/&gt; element is of type "error", the element MUST contain an &lt;error/&gt; element (implicitly qualified by the 'jabber:server' namespace), which MUST in turn contain an XML element qualified by the 'urn:ietf:params:xml:ns:xmpp-stanzas' namespace (i.e., a stanza error condition) as those errors are defined in RFC 6120. The following table provides additional guidance regarding the most relevant stanza error conditions:</p>
    <table caption='Dialback error conditions'>
      <tr>
        <th>Condition</th>
        <th>Description</th>
        <th>Occurs in</th>
      </tr>
      <tr>
        <td>&notfound;</td>
        <td>The domain given in the 'to' attribute of the request is not hosted on the Receiving Server. Nonetheless, the domain is used in the 'from' attribute of the error packet, for the purpose of identifying the original request.</td>
        <td>Step 3 or 4</td>
      </tr>
      <tr>
        <td>&remoteconnection;</td>
        <td>The Receiving Server was unable to establish a connection to the Authoritative Server and therefore could not validate the identity of the Initiating Server.</td>
        <td>Step 4</td>
      </tr>
      <tr>
        <td>&remoteserver;</td>
        <td>The Receiving Server encountered an &notfound; error condition or a &lt;host-unknown/&gt; stream error when attempting to contact the Authoritative Server.</td>
        <td>Step 4</td>
      </tr>
      <tr>
        <td>&timeout;</td>
        <td>The Receiving Server encountered a problem with the connection to the Authoritative Server, for example if the Authoritative Server unexpectedly closed the stream without verifying the dialback key.</td>
        <td>Step 4</td>
      </tr>
      <tr>
        <td>&policy;</td>
        <td>The Receiving Server enforces a policy mandating usage of TLS before dialback and the Initiating Server sent the dialback request without using TLS.</td>
        <td>Step 3 or 4</td>
      </tr>
      <tr>
        <td>&notauthorized;</td>
        <td>The Receiving Server enforces a policy requiring either a valid PKIX certificate containing the identity of the Sender Domain or some other proof of authorization (e.g., via POSH), and the Initiating Server did not provide proof of authorization.</td>
        <td>Step 3</td>
      </tr>
      <tr>
        <td>&forbidden;</td>
        <td>The Receiving Server received an "invalid" response when attempting to verify the dialback key with the Authoritative Server.</td>
        <td>Step 4</td>
      </tr>
      <tr>
        <td>&notacceptable;</td>
        <td>The Receiving Server was unable to establish the asserted identity of the Initiating Server.</td>
        <td>Step 4</td>
      </tr>
      <tr>
        <td>&constraint;</td>
        <td>The Receiving Server lacks the resources to add the requested domain pair to the list of connections authorized for this connection. The initiating server should attempt to establish a new TCP connection to the target domain using the process described in <cite>RFC 6120</cite> and give up when receiving the same error on the new connection.</td>
        <td>Step 4</td>
      </tr>
    </table>
  </section2>

  <!--
  <section2 topic="Reverification" anchor='reverify'>
    <p>Server-to-server streams can exist for long periods of time. An Initiating Server MAY reverify the key periodically over the life of the stream (i.e., by sending a new &lt;db:verify/&gt; packet as in Step 3 of the dialback negotiation), but MUST NOT attempt to re-verify the domain pair on this TCP connection.</p>
  -->

  <section2 topic="Multiplexing" anchor='multiplex'>
    <p>A single XML stream between Initiating Server and Receiving Server can be used to multiplex stanzas for more than one domain pair. We call this usage "multiplexing" (historically it has also been known as "piggybacking").</p>
    <p>One common motivation for multiplexing is virtual hosting, under which many domains are hosted on the same server. This problem is described more fully in the Domain Name Associations specification, <cite>draft-ietf-xmpp-dna</cite>).</p>
    <p>Another common motivation for such reuse is the existence of additional services associated with the Sender Domain but hosted at "subdomains" thereof. For example, both the "montague.example" and the "capulet.example" XMPP servers might host &xep0045; services at "chat.montague.example" and "rooms.capulet.example" respectively. Because dialback operates on domain pairs, a total of eight dialback negotiations would be necessary for a bidirectional exchange of stanzas between two sending domains and two target domains.</p>
    <p>If multiplexing is not used, the number of server-to-server connections needed to exchange stanzas between virtual hosting providers or multi-service XMPP servers can increase signficantly. Indeed, when the number of hosted domains becomes especially large, the number of connections might exceed the maximum number of connections allowed from a single IP address as explained in &xep0205;.</p>
    <p>If multiplexing is used, the number of connections can be limited to only two (or, at the operator's discretion, more than two for operational reasons).</p>

    <section3 topic="Multiplexing Sender Domains" anchor="sendermultiplex">
      <p>In order to accept XML stanzas from rooms at "rooms.capulet.example" intended for addresses at "montague.example", the "montague.example" domain will need to validate the "rooms.capulet.example" domain (just as it already did for the "capulet.example" domain). Thus the server hosting both capulet.example and rooms.capulet.example would now initiate a dialback negotiation with the server hosting montague.example but specify the Sender Domain as "rooms.capulet.example". Specifying different Sender Domains is called "sender multiplexing" and MAY be used without further negotation.</p>
    </section3>

    <section3 topic="Multiplexing Target Domains" anchor="targetmultiplex">
      <p>Likewise, to send stanzas to rooms at "chat.montague.example" from addresses at "capulet.example", the server hosting both capulet.example and rooms.capulet.example would initiate dialback negotiation with the server hosting chat.montague.example (probably on the same connection that is already used to send stanzas from "capulet.example" to "montague.example"), specifying the Target Domain as "chat.montague.example". Specifying different target domains is called "target multiplexing".</p>
      <p>The Initiating Server SHOULD NOT use target multiplexing unless the Receiving Server has signalled support for dialback error handling via &lt;stream:features/&gt; as described under <link url='#advertisement-errors'>Dialback with Error Handling</link>. The Initiating Server MAY then attempt to multiplex a new Sender Domain on the stream to the Receiving Server that is already used for another Sender Domain if the hostname and port resolution results in the same IP address and port combination. For example:</p>
      <example caption="DNS SRV Record for the montague.example Zone"><![CDATA[
_xmpp-server._tcp.montague.example.      86400 IN SRV 10 0 5269 home.montague.example
_xmpp-server._tcp.chat.montague.example. 86400 IN SRV 10 0 5269 home.montague.example
home.montague.example.                   86400 IN A                     10.44.0.4
]]></example>
      <p>Because DNS SRV lookups for both "montague.example" and "chat.montague.example" point to the same target ("home.montague.example") and port (5269), or eventually resolve to the same IP address (10.44.0.4) and port (5269), "capulet.example" MAY initiate a dialback negotation from "capulet.example" to "chat.montague.example" over the same XML stream that is already used to send stanzas from "capulet.example" to "montague.example".</p>
      <p>&xep0288; extends those rules since any domain that has been used as a source domain can be used as a target domain without further negotiation.</p>
    </section3>
  </section2>
</section1>

<section1 topic='Security Considerations' anchor='security'>
  <p>Server Dialback helps protect against domain spoofing, thus making it difficult to spoof the origin of XML stanzas. Absent the use of DNS security (DNSSEC, <cite>RFC 4033</cite>), Server Dialback does not provide a mechanism for authenticating a stream, as is done via TLS and SASL, and results in weak verification of server identities only. Furthermore, if DNSSEC is not used then it is susceptible to DNS poisoning attacks.</p>
  <p>If DNSSEC is used, Server Dialback provides stream authentication only (i.e., a strong association between a domain name and an XML stream). However, Server Dialback by itself does not provide confidentiality, data integrity, or stream encryption. Some existing implementations are known to support dialback over TLS. In this case, Server Dialback is typically carried out the same way as without TLS, but gains from the use of channel encryption.</p>
  <section2 topic='Unsolicited Dialback' anchor='security-unsolicited'>
    <p>In mid-2012, several implementations turned out to be vulnerable to a number of attacks against the protocol described in this document. These attacks were based on sending verify (STEP 3) or result (STEP 4) responses without an associated request, in an unexpected direction and/or on an unexpected XML stream. Failure to reject those 'unsolicited' responses lets an attacker either spoof stanzas with an arbitrary sender domain or enables him to impersonate any target domain.</p>
  </section2>
</section1>

<section1 topic='IANA Considerations' anchor='iana'>
  <p>This document requires no interaction with &IANA;.</p>
</section1>

<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
  <section2 topic='Protocol Namespaces' anchor='registrar-ns'>
    <p>The &REGISTRAR; includes 'jabber:server:dialback' in its registry of protocol namespaces (see &NAMESPACES;).</p>
  </section2>
  <section2 topic='Stream Features' anchor='registrar-stream'>
    <p>The XMPP Registrar includes 'urn:xmpp:features:dialback' in its registry of stream features (see &STREAMFEATURES;).</p>
    <p>The registration is as follows:</p>
    <code><![CDATA[
<feature>
  <ns>urn:xmpp:features:dialback</ns>
  <name>Server Dialback</name>
  <element>dialback</element>
  <desc>Support for Server Dialback with dialback errors</desc>
  <doc>XEP-0220</doc>
</feature>
]]></code>
  </section2>
</section1>

<section1 topic='XML Schema' anchor='schema'>
  <section2 topic="Dialback" anchor="schema-dialback">
    <p>Note Well: the 'error' value for the 'type' attribute and the &lt;error/&gt; child element were added since RFC 3920.</p>
    <code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:server:dialback'
    xmlns='jabber:server:dialback'
    elementFormDefault='qualified'>

  <xs:annotation>
    <xs:documentation>
      The protocol documented by this schema is defined in
      XEP-0220: http://www.xmpp.org/extensions/xep-0220.html
    </xs:documentation>
  </xs:annotation>

  <xs:import namespace='urn:ietf:params:xml:ns:xmpp-stanzas'
             schemaLocation='http://xmpp.org/schemas/stanzaerror.xsd'/>

  <xs:element name='result'>
    <xs:complexType mixed='true'>
      <xs:all>
        <xs:element name='error' type='errorType'/>
      </xs:all>
      <xs:attribute name='from' type='xs:string' use='required'/>
      <xs:attribute name='to' type='xs:string' use='required'/>
      <xs:attribute name='type' use='optional'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='error'/>
            <xs:enumeration value='invalid'/>
            <xs:enumeration value='valid'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name='verify'>
    <xs:complexType mixed='true'>
      <xs:all>
        <xs:element name='error' type='errorType'/>
      </xs:all>
      <xs:attribute name='from' type='xs:string' use='required'/>
      <xs:attribute name='to' type='xs:string' use='required'/>
      <xs:attribute name='id' type='xs:NMTOKEN' use='required'/>
      <xs:attribute name='type' use='optional'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='error'/>
            <xs:enumeration value='invalid'/>
            <xs:enumeration value='valid'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:complexType name='errorType'>
    <xs:sequence xmlns:err='urn:ietf:params:xml:ns:xmpp-stanzas'>
      <xs:group ref='err:stanzaErrorGroup'/>
    </xs:sequence>
  </xs:complexType>

</xs:schema>
]]></code>
  </section2>
  <section2 topic="Stream Feature" anchor="schema-feature">
    <code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:features:dialback'
    xmlns='urn:xmpp:features:dialback'
    elementFormDefault='qualified'>

  <xs:element name='dialback'>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='errors' minOccurs='0' type='empty'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
]]></code>
  </section2>
  <section2 topic="Application Specific Errors" anchor="schema-errors">
    <code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:dialback:errors'
    xmlns='urn:xmpp:dialback:errors'
    elementFormDefault='qualified'>

  <xs:annotation>
    <xs:documentation>
      The protocol documented by this schema is defined in
      XEP-0220: http://www.xmpp.org/extensions/xep-0220.html
    </xs:documentation>
  </xs:annotation>
</xs:schema>
]]></code>
  </section2>
</section1>

<section1 topic='Acknowledgments' anchor='ack'>
  <p>Thanks to Richard Barnes, Dave Cridland, Jack Erwin, Joe Hildebrand, Justin Karneges, Nina Kirchner, Carlo von Loesch, Ralph Meijer, Matthew Miller, Chris Newton, Rob Norris, Tory Patnoe, Dave Richards, Matthew Wild, and Matthias Wimmer for their comments.</p>
</section1>

</xep>
