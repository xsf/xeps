<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY iana-cb-types "<span class='ref'><link url='https://www.iana.org/assignments/channel-binding-types/channel-binding-types.xhtml'>IANA Channel-Binding Types Registry</link></span> <note>IANA Channel-Binding Types Registry &lt;<link url='https://www.iana.org/assignments/channel-binding-types/channel-binding-types.xhtml'>https://www.iana.org/assignments/channel-binding-types/channel-binding-types.xhtml</link>&gt;.</note>" >
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
  <title>SASL Channel-Binding Type Capability</title>
  <abstract>This specification allows servers to annouce their supported SASL channel-binding types to clients.</abstract>
  &LEGALNOTICE;
  <number>0440</number>
  <status>Draft</status>
  <lastcall>2025-10-28</lastcall>
  <type>Standards Track</type>
  <sig>Standards</sig>
  <approver>Council</approver>
  <dependencies>
    <spec>XMPP Core</spec>
  </dependencies>
  <supersedes/>
  <supersededby/>
  <shortname>sasl-cb-types</shortname>
  &flow;
  &tmolitor;
  <revision>
    <version>1.0.0</version>
    <date>2025-12-08</date>
    <initials>XEP Editor (dg)</initials>
    <remark><ul><li>Accept as Stable as per Council Vote from 2025-11-18</li></ul></remark>
  </revision>
  <revision>
    <version>0.5</version>
    <date>2025-10-25</date>
    <initials>tm</initials>
    <remark>
      <ul>
        <li>Address a possible MITM attack vector by making the tls-server-end-point channel-binding mandatory to implement</li>
        <li>Remove the whole 'Interaction with SASL mechanisms' section and replace it with 'Business Rules'</li>
        <li>Rework whole 'Security Considerations' section</li>
        <li>Some minor editorial changes</li>
        <li>Add Thilo Molitor as author</li>
      </ul>
    </remark>
  </revision>
  <revision>
    <version>0.4.2</version>
    <date>2024-07-02</date>
    <initials>egp</initials>
    <remark>
      <ul>
        <li>Add an XML schema.</li>
        <li>Mention that this specification does add a new namespace that should go to the registrar.</li>
        <li>Fix indentation, typos, misuse of '' vs. &lt;/&gt; for elements, etc.</li>
      </ul>
    </remark>
  </revision>
  <revision>
    <version>0.4.1</version>
    <date>2024-01-30</date>
    <initials>fs</initials>
    <remark>
      Recommend the usage of tls-exporter over tls-server-end-point
    </remark>
  </revision>
  <revision>
    <version>0.4.0</version>
    <date>2022-09-21</date>
    <initials>dg</initials>
    <remark>
      Make sasl-channel-binding element a top level stream feature
    </remark>
  </revision>
  <revision>
    <version>0.3.0</version>
    <date>2022-08-29</date>
    <initials>tm</initials>
    <remark>
      Make implementation of tls-server-end-point a MUST for servers.
    </remark>
  </revision>
  <revision>
    <version>0.2.0</version>
    <date>2020-08-04</date>
    <initials>fs</initials>
    <remark>
      Discuss interaction with SASL mechanism and add security considerations.
      Recommend implementation of tls-server-end-point.
    </remark>
  </revision>
  <revision>
    <version>0.1.0</version>
    <date>2020-06-14</date>
    <initials>XEP Editor (jsc)</initials>
    <remark>Accepted by vote of Council on 2020-05-27.</remark>
  </revision>
  <revision>
    <version>0.0.1</version>
    <date>2020-05-20</date>
    <initials>fs</initials>
    <remark><p>First draft.</p></remark>
  </revision>
</header>
<section1 topic='Introduction' anchor='intro'>

  <p>SASL channel-binding is a technique to increase the security of
  connections (&rfc5056;). Unfortunately, the SASL profile specified
  in &rfc6120; lacks a method for the server to announce its supported
  channel-binding types. This hinders the adoption of channel-binding,
  especially since the error protocol to execute after a client
  requested a channel-binding type unsupported by the server is
  basically unspecified.</p>

  <p>The extension defined herein fills the gap left by &rfc6120;, by
  allowing the server to announce its supported channel-binding
  types.</p>

</section1>

<section1 topic='Announcing the SASL Channel-Binding Type Capability' anchor='sasl-cb-type'>

  <p>This protocol consists of a stream feature named &lt;sasl-channel-binding/&gt;
  qualified by the 'urn:xmpp:sasl-cb:0' namespace.
  The &lt;sasl-channel-binding/&gt; element MUST contain one or
  more &lt;channel-binding/&gt; elements, of which each MUST have an
  attribute with the name 'type'. The value of the 'type' attribute
  SHOULD be the "Channel-binding unique prefix" of a channel-binding
  type which was registered with the &iana-cb-types;.</p>

  <p>A server declares that it supports particular channel-binding
  types by listing the supported types via the &lt;sasl-channel-binding/&gt;
  stream feature defined herein. The &lt;sasl-channel-binding/&gt; element could
  appear next to the SASL &lt;mechanisms/&gt;
  stream-feature element, qualified by the
  'urn:ietf:params:xml:ns:xmpp-sasl' namespace, as specified in
  &rfc6120;. Another potential appearance of
  &lt;sasl-channel-binding/&gt; is next to the
  &lt;authentication/&gt; stream-feature element as specified in the
  &xep0388;.</p>

  <example caption='Example SASL1 &lt;mechanisms/&gt; stream feature with SASL Channel-Binding Type Capability.'><![CDATA[
<stream:features>
  <sasl-channel-binding xmlns='urn:xmpp:sasl-cb:0'>
    <channel-binding type='tls-server-end-point'/>
    <channel-binding type='tls-exporter'/>
  </sasl-channel-binding>
  <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
    <mechanism>EXTERNAL</mechanism>
    <mechanism>SCRAM-SHA-1-PLUS</mechanism>
    <mechanism>PLAIN</mechanism>
  </mechanisms>
</stream:features>]]></example>

<example caption='Example SASL2 &lt;authentication&gt; stream feature with SASL Channel-Binding Type Capability.'><![CDATA[
<stream:features>
  <sasl-channel-binding xmlns='urn:xmpp:sasl-cb:0'>
    <channel-binding type='tls-server-end-point'/>
    <channel-binding type='tls-exporter'/>
  </sasl-channel-binding>
  <authentication xmlns='urn:xmpp:sasl:2'>
    <mechanism>SCRAM-SHA-1</mechanism>
    <mechanism>SCRAM-SHA-1-PLUS</mechanism>
    <inline>
      <sm xmlns='urn:xmpp:sm:3'/>
      <bind xmlns='urn:xmpp:bind:0'/>
    </inline>
  </authentication>
</stream:features>]]></example>

</section1>

<section1 topic='Business Rules' anchor='business-rules'>

  <p>Client developers MUST follow the following rules to ensure that implementing this specification
    in conjunction with SCRAM (&rfc5802;) or any other equivalent SASL mechanism supporting channel-binding
    does not introduce a MITM attack vector. The rules are specifically taylored to SCRAM. For other
    SASL mechanisms supporting channel-binding, client developers MUST use the equivalent to "y" and "n"
    defined by those mechanisms.</p>
  
  <ol>
    <li>Servers MUST implement tls-server-end-point and enable/advertise it.
      Clients SHOULD implement tls-server-end-point and use it if no stronger
      channel-binding method is mutually supported.</li>
    <li>If the client doesn't support channel-binding, it MUST send "n" in the GSS-header (see &rfc5802;).</li>
    <li>If the client supports channel-binding, but the server announced neither SASL mechanisms supporting channel-binding
      nor channel-binding types (via this specification), it MUST send "y" in accordance to &rfc5802;.</li>
    <li>If the client is using SASL2 (&xep0388;) to authenticate and received announcements
      for SASL mechanisms supporting channel-binding from the server, but no channel-binding types,
      it MUST abort the authentication (this is either an implementation error or ongoing MITM attack
      where channel-binding types are stripped).
      This condition is undefined with SASL1 (&rfc6120;), but the client MAY also abort authentication
      in this case (or it MAY try authentication using tls-server-end-point  or any other channel-binding mechanism).</li>
    <li>If the client is using SASL2 to authenticate and it receives channel-binding announcements,
      from the server, but no SASL mechanisms supporting channel-binding are announced, it MUST abort authentication
      (this is an implementation error or ongoing MITM attack where SASL mechanisms are stripped).
      It SHOULD do the same when using SASL1.</li>
    <li>If the client is using either SASL1 or SASL2 to authenticate and receives announcements for
      SASL mechanisms supporting channel-binding and channel-binding types, but none of these announced channel-binding types are
      supported by it, it MUST abort authentication, if tls-server-end-point is also not advertised by the server
      (this is an ongoing MITM attack, as per our first rule above).</li>
    <li>The client SHOULD use a channel-binding stronger than tls-server-end-point, if advertised
      by the server and implemented by it (that is: set the p=&lt;channel-binding-name&gt; GSS-header
      to that channel-binding type according to &rfc5802;).</li>
  </ol>
  
  <p>When implementing &xep0474; the above rules might be relaxed a bit, see that specification for details.</p>
  
  <p>A more sophisticated attacker managing to steal the certificate and private key of the server
    won't be detected by the tls-server-end-point channel-binding. Clients and servers SHOULD implement
    stronger channel-binding types like tls-exporter, to detect and prevent such attacks</p>

</section1>

<section1 topic='Security Considerations' anchor='security'>

  <p>The following considerations refer to SCRAM,
    as it is the only widely depolyed mechanism with channel binding
    at the time of writing this document. As already stated in the <link url="#business-rules">Business Rules</link>,
    other mechanisms supporting channel-binding will have some sort of equivalent for "y" and "n".</p>
  
  <p>In SCRAM (&rfc5802;) the client-first-message contains three possible values in the 
    GSS-header part:</p>
  <ol>
    <li>y - The client would have used channel-binding, but the server did not offer any.</li>
    <li>n - The client does not support channel-binding (even if the server offered any).</li>
    <li>p=&lt;cb-name&gt; - The name of the channel-binding, the client wants to use.</li>
  </ol>
  
  <p>The RFC explains, that sending "y" when the server advertised channel-binding
    support is to be used as a MITM-detection. An attacker stripping out all *-PLUS variants can be detected this way:
    the server knows it advertised them and the client reports via "y", that it would have used them if it saw them advertised,
    so the server can abort the authentication in this case.</p>
  
  <p>This works reasonably well, if there is only one single channel-binding 
    possible. But that's the exact assumption this specification now changes:
    it is now possible to advertise a list of different channel-bindings for the client 
    to choose.</p>
  
  <p>But this creates a problem: what to do if the server advertised a list of 
    channel-binding algorithms, but the client doesn't support any of these?
    Assuming there is no MITM attacker present, the client can't send "y" in the GSS-header,
    because the server would then abort the authentication because it advertised channel-bindings.
    Sending "n" and continuing without channel-binding is fine in this case,
    but it won't be if a MITM attacker were present.
    <note>This isn't fully hypothetical. An older client might only support tls-unique, 
    while the server only advertises tls-exporter (which can be used for tls 1.2, 
    too, if the extended master secret is used).
    Blocking the connection entirely is of course at the discretion of the client 
    developer, but it hinders interoperability, especially while phasing out one 
    channel-binding-type and introducing a new one.</note></p>

  <p>Any MITM attacker could just manipulate the list of channel-bindings advertised using this specification
    to just list some dummy mechanisms the client doesn't support. If the client acted like
    in the non-attacker case depicted in the last paragraph and sent "n",
    the attacker would have successfully downgraded the client to non-channel-binding.
    The client won't be able to distinguish the attacker case from the non-attacker one.</p>
  
  <p>The rules in the <link url="#business-rules">Business Rules</link>
    section fix that loophole. Tls-server-end-point was picked, because it is the lowest denominator
    that can be implemented by virtually everyone and even though it isn't as strong as tls-exporter
    or tls-unique, it still catches many attacks.
    <strong>This only works reliably, if <em>every</em> server supports and announces tls-server-end-point.</strong></p>

  <p>A client following the rules above and seeing a server-advertised list without
    tls-sever-end-point, immediately knows, that some attacker tampered with the list of channel-binding types
    and can abort the authentication. It never needs to send "n" even though it supports channel-binding and
    can still safely send "y" if it doesn't see any '*-PLUS' variants and channel-bindings announced.</p>

</section1>

<section1 topic='IANA Considerations' anchor='iana'>

  <p>This document requires no interaction with &IANA;.</p>

</section1>

<section1 topic='XMPP Registrar Considerations' anchor='registrar'>

  <p>Add the 'urn:xmpp:sasl-cb:0' namespace to the registry:</p>
  <code caption='Registry Submission'><![CDATA[
<var>
  <name>urn:xmpp:sasl-cb:0</name>
  <desc>Expose supported channel-binding types to clients</desc>
  <doc>XEP-0440</doc>
</var>
]]></code>

</section1>

<section1 topic='XML Schema' anchor='schema'>

  <code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    xmlns='urn:xmpp:sasl-cb:0'
    targetNamespace='urn:xmpp:sasl-cb:0'
    elementFormDefault='qualified'>

  <xs:annotation>
    <xs:documentation>
      The protocol documented by this schema is defined in
      XEP-0440: https://xmpp.org/extensions/xep-0440.html
    </xs:documentation>
  </xs:annotation>

  <xs:element name='sasl-channel-binding'>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref='channel-binding' maxOccurs='unbounded'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='channel-binding'>
    <xs:complexType>
      <xs:attribute name='type' type='xs:string'/>
    </xs:complexType>
  </xs:element>

</xs:schema>
]]></code>

</section1>

<section1 topic='Acknowledgements' anchor='acknowledgements'>

  <p>Thanks to Sam Whited for the discussion about the underlying
  issue and incentivizing me to come up with this extension. Further
  thanks goes to Ruslan N. Marchenko for pointing out the possible
  MITM attack vector. Last but not least, Dave Cridland, Thilo Molitor,
  and Simon Josefsson provided valuable feedback.</p>

</section1>

</xep>
