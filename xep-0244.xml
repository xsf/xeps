<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
  <title>IO Data</title>
  <abstract>This specification defines an XMPP protocol extension for handling the input to and output from a remote entity.</abstract>
  &LEGALNOTICE;
  <number>0244</number>
  <status>Deferred</status>
  <type>Standards Track</type>
  <sig>Standards</sig>
  <approver>Council</approver>
  <dependencies>
    <spec>XMPP Core</spec>
    <spec>XEP-0001</spec>
    <spec>XEP-0030</spec>
    <spec>XEP-0050</spec>
  </dependencies>
  <supersedes/>
  <supersededby/>
  <shortname>NOT_YET_ASSIGNED</shortname>
  <author>
    <firstname>Johannes</firstname>
    <surname>Wagener</surname>
    <email>johannes.wagener@med.uni-muenchen.de</email>
    <jid>edrin@jabber.org</jid>
  </author>
  <author>
    <firstname>Egon</firstname>
    <surname>Willighagen</surname>
    <email>egonw@users.sf.net</email>
    <jid>egonw@jabber.org</jid>
  </author>
  <author>
    <firstname>Andreas</firstname>
    <surname>Heusler</surname>
    <email>aheusler@in.tum.de</email>
    <jid>krach@jabber.org</jid>
  </author>
  <author>
    <firstname>Tobias</firstname>
    <surname>Markmann</surname>
    <email>tm@ayena.de</email>
    <jid>tm@ayena.de</jid>
  </author>
  <author>
    <firstname>Ola</firstname>
    <surname>Spjuth</surname>
    <email>ola.spjuth@farmbio.uu.se</email>
    <jid>olas@pele.farmbio.uu.se</jid>
  </author>
  <revision>
    <version>0.1</version>
    <date>2008-06-18</date>
    <initials>psa</initials>
    <remark><p>Initial published version.</p></remark>
  </revision>
  <revision>
    <version>0.0.4</version>
    <date>2008-06-05</date>
    <initials>jw/ew</initials>
    <remark><p>The IO Data specific commands (procedure status and output request) were moved in the IO Data namespace. The Schema was adapted to become extensible.</p></remark>
  </revision>
  <revision>
    <version>0.0.3</version>
    <date>2008-04-16</date>
    <initials>jw</initials>
    <remark><p>Applied the suggested modifications in result to the discussion on the XMPP standards mailing list.</p></remark>
  </revision>
  <revision>
    <version>0.0.2</version>
    <date>2008-03-20</date>
    <initials>jw</initials>
    <remark><p>Added some missing namespaces in two examples.</p></remark>
  </revision>
  <revision>
    <version>0.0.1</version>
    <date>2008-02-25</date>
    <initials>jw</initials>
    <remark><p>Initial Version.</p></remark>
  </revision>
</header>

<section1 topic='Introduction' anchor='intro'>
	<section2 topic='About the intention to write this XEP' anchor='intention'>
		<p>&xep0050; became a popular and widespread XMPP Protocol Extension to execute functions on a remote systems. It is supported by many XMPP client and service implementations. To date almost all of its implementations rely on &xep0004; to be the data container. However Ad-Hoc Commands is explicitly designed and mentioned to be used in combination with other data containers, too. This applies for the cases where the Data Forms specification does not fit the needs, for example the Data Forms can be too restrictive on strong typing of data (see Section 1.2).</p>
		<p>The intention of the present XEP is to define a data container for the cases where Data Forms is not applicable or not optimal. The data container defined herein (IO Data) is very generic and discoverable. It is intended to be used for other purposes than Data Forms.</p>
	</section2>
	
	<section2 topic='Limitations of Data Forms' anchor='limits'>
		<p>The Data Forms data container has certain restrictive limitations:</p>
		<ol>
			<li>The supported Field Types are limited: text input fields, drop down boxes, different selectable optional values, etc. See <link url='http://www.xmpp.org/extensions/xep-0004.html#protocol-fieldtypes'>Data Forms - Field Types</link></li>
			<li>The only allowed content type of the fields is xs:string. See <link url='http://www.xmpp.org/extensions/xep-0004.html#schema'>Data Forms - XML Schema</link></li>
			<li>According to current specifications it is not possible to transport complex tree-based data structures. For example nested elements of elements cannot have nested elements at all, therefore lacking an XML key feature.</li>
		</ol>
		<p>The limitations of Data Forms are not bad. They are good for the special use case a client has to render a graphical representation of the service. In HTML the correlative is a HTML form. For a chat client developer this makes it plain and simple to develop a generic graphical client implementation with some simple text-input fields.</p>
	</section2>
	
	<section2 topic='Why an additional data container is required' anchor='sense'>
		<p>According to current standards it is not supported to encapsulate more complex data in the Data Forms data container. For example it is not possible to encapsulate a complete XML Document - the real "generic" data container - in the Data Forms data container, unless you encode the XML Document as xs:string â€“ which would be considered bad practice.</p>
		<p>However specialized clients are developed to make use of the service oriented architecture of XMPP. An example is given here: a XMPP client implementation reflects an Application Programming Interface (API) with an XMPP services by making use of Ad-Hoc Commands.</p>
<example caption='get_titles.js'><![CDATA[
// javascript syntax

service = client.getService("database.server.com");

function = service.getFunction("getXmlFile");

// Check if this Ad-Hoc Command supports the IO Data XEP?
if (function instanceof IoDataFunction) {
  
   // Discover the input and output XML Schemata - required only once!
   schemata = function.getIoSchemata();
   
   // Dynamically marshal an API for the input and output - required only once!
   inputOutputFactory = new IoFactory( schemata );
   
   // Create and set the input
   input1 = inputOutputFactory.createInputObject();
   input1.setFileName("doc-ID-011021");
   
   // Invoke the function and get the output
   result1 = function.invoke(input1);
   output1 = inputOutputFactory.getOutputObject(result1);
   title1 = output1.getDocumentTitle();
   
   // Next document
   input2 = inputOutputFactory.createInputObject();
   input2.setFileName("doc-ID-833423");
   result2 = function.invoke(input2);
   output2 = inputOutputFactory.getOutputObject(result2);
   title2 = output1.getDocumentTitle();
   
   ...
}]]></example>
		<p>The limitations of Data Forms make it impossible to define and handshake these actions clearly and precisely and without confusing existing and future implementations for the following reasons:</p>
		<ol>
			<li>Data Forms does not support a "Schemata Discovery". The form descriptor Data Forms provides (type='form') is not separated from the data transaction according to the Ad-Hoc Command logic descibed in XEP-0050. Therefore each function invocation would result in a form descriptor submission again causing unnecessary traffic. It is sufficient to discover the IO Schemata once.</li>
			<li>It is not suggested to encapsulate XML Documents in the Data Forms in general.</li>
		</ol>
	</section2>
	<section2 topic='Web Services over XMPP' anchor='ws'>
		<p>Beside Ad-Hoc Commands two other XEPs exist that provide mechanisms to execute a function on a remote system. For this count &xep0009; and &xep0072;.</p>
		<p>However, Jabber-RPC and SOAP over XMPP lack certain functionality that is important for flexible, simple and robust Web Services. Because of the limited expressiveness of XML-RPCs data types the Jabber-RPC is not suitable for complex functionality, similar to the limitations of Data Forms. While SOAP over XMPP supports complex data types it lacks an obvious mechanism for asynchronous usage. For example it has no default stateful design: there is no sessionid like in Ad-Hoc Commands. Beside this SOAP brings in severe complexity (XML associated abstractions) that was required for the primary transport layer HTTP. This complexity is not required because XMPP does already implement the required XML associated abstractions. In addition to that there are other issues that argument against SOAP. For example to date most HTTP SOAP implemented services are only compatible with a subset of SOAP libraries.</p>
		<p>In contrast Ad-Hoc Commands comprises simple, clean and optionally stateful Web Service mechanisms by default. In addition to that asynchronous client notification can be achieved with a &lt;message&gt;, as indicated in Ad-Hoc Commands and as realized in some unofficial implementations.</p>
	</section2>
	
	<section2 topic='The IO Data data container' anchor='conclusion'>
		<p>In conclusion and as already suggested in Ad-Hoc Commands we describe an alternative data container. This data container is more generic in the way it can be used:</p>
		<ol>
			<li>It supports a "Schemata Discovery". Thus a client implementation can marshal an API for the input and output (and optionally for a service specific error) of a certain service.</li>
			<li>This "Schemata Discovery" is separated from the data transaction. This reduces the amount of unnecessary traffic.</li>
			<li>The Field Types of the described data container are on the one hand clearly defined (there is only description, input, output, error, and status) and on the other hand straightforward. Thus any kind of XML data (XML Document with namespaces that represent any imaginable data object) can be submitted.</li>
		</ol>
		<p>It is important to note that this XEP does not intent to replace or extent Data Forms. Also it does not break any current Ad-Hoc implementations. It just intends to offer another data container that fits much better under some circumstances where no GUI is rendered around an Ad-Hoc Command service.</p>  
	</section2>

</section1>

<section1 topic='Protocol' anchor='protocol'>
	<p>The base syntax for the 'urn:xmpp:tmp:io-data' namespace is as follows &NSNOTE;; a formal description can be found in the XML Schema section below.</p>
<code><![CDATA[
  <iodata xmlns='urn:xmpp:tmp:io-data'
      type='transaction-type'>
      <desc/>
      <in/>
      <out/>
      <error/>
      <status>
         <elapsed/>
         <remaining/>
         <percentage/>
         <information/>
      </status>
  </iodata>
]]></code>
	
	<section2 topic='Transaction Types' anchor='trans'>
		<table caption='IO Data Transaction Types allowed for client to service stanzas'>
      <tr>
        <th>Transaction Type</th>
        <th>Purpose</th>
        <th>Associated Ad-Hoc Command</th>
        <th>REQUIRED for generic XEP compatibility</th>
        <th>Contained Elements</th>
      </tr>
	 		<tr>
				<th>io-schemata-get</th>
				<th>To request the schemata of input and output.</th>
				<th>execute</th>
				<th>yes</th>
				<th>-</th>
			</tr>
			<tr>
				<th>input</th>
				<th>To submit the input.</th>
				<th>execute</th>
				<th>yes</th>
				<th>&lt;in&gt;</th>
			</tr>
			<tr>
				<th>getStatus</th>
				<th>To request the status of the procedure.</th>
				<th>next</th>
				<th>yes</th>
				<th>-</th>
			</tr>
			<tr>
				<th>getOutput</th>
				<th>To request the output.</th>
				<th>next, complete</th>
				<th>yes</th>
				<th>-</th>
			</tr>
		</table>
		
		<table caption='IO Data Transaction Types allowed for service to client stanzas'>
      <tr>
        <th>Transaction Type</th>
        <th>Purpose</th>
        <th>Associated Ad-Hoc Command status value</th>
        <th>REQUIRED for generic XEP compatibility</th>
        <th>Contained Elements</th>
      </tr>
			<tr>
				<th>io-schemata-result</th>
				<th>To return the schemata of input and output.</th>
				<th>completed</th>
				<th>yes</th>
				<th>&lt;desc&gt; &lt;in&gt; &lt;out&gt;</th>
			</tr>
			<tr>
				<th>output</th>
				<th>To submit the output.</th>
				<th>executing, completed</th>
				<th>yes</th>
				<th>&lt;out&gt;</th>
			</tr>
			<tr>
				<th>error</th>
				<th>To submit additional error information.</th>
				<th>executing</th>
				<th>no</th>
				<th>&lt;error&gt;</th>
			</tr>
			<tr>
				<th>status</th>
				<th>To indicate the current status of the procedure.</th>
				<th>executing</th>
				<th>no</th>
				<th>&lt;status&gt;</th>
			</tr>
		</table>
	</section2>
	
	<section2 topic='Container Elements' anchor='container'>
		<p>&lt;desc&gt; -- a textual description of the IO Data data container (xs:string).</p>
		<p>&lt;in&gt; -- contains the input. Valid for Transaction Type 'input' and 'io-schemata-result' only. May contain any XML data (XML Schema, XML Document ...).</p>
		<p>&lt;out&gt; -- contains the output. Valid for Transaction Type 'output' and 'io-schemata-result' only. May contain any XML data (XML Schema, XML Document ...).</p>
		<p>&lt;error&gt; -- describes the error raised by the procedure invocation. This element is optional and valid for Transaction Type 'error' and 'io-schemata-result' only. May contain any XML data (XML Schema, XML Document ...).</p>
		<p>&lt;status&gt; -- describes the status of the procedure. This element is optional and valid for Transaction Type 'status' only.</p>
	</section2>
	
	<section2 topic='Status Elements' anchor='status'>
		<p>&lt;elapsed&gt; -- an integer value of the time in milliseconds that elapsed since the procedure was invoked (xs:integer).</p>
		<p>&lt;remaining&gt; -- an integer value of the (estimated) time in milliseconds till the procedure will finish (xs:integer).</p>
		<p>&lt;percentage&gt; -- the percentage of the procedure that is finished (xs:integer).</p>
		<p>&lt;information&gt; -- describes the current status of the procedure.</p>
	</section2>
</section1>

<section1 topic='Implementation Notes' anchor='impl'>
	<p>Commands (= remote procedures) executed with Ad-Hoc Commands and IO Data SHOULD NOT keep the requester in an uncertain state. This means the responder SHOULD respond to the requester always as fast as possible. Thereby the requester acquires the sessionid. (As some remote procedures/calculations are cost-intensive and/or time-consuming the requester MUST "save" this sessionid for the case a network problem occurs.)</p>
	<p>The Ad-Hoc Command logic applied for the IO Data data container should be associated with the following rules and keywords:</p>
		<table caption='Subsequently allowed Ad-Hoc Commands are depending on the state of the service'>
      <tr>
        <th>Ad-Hoc Command</th>
        <th>Keyword</th>
        <th>Associated Transaction Type</th>
        <th>Subsequently allowed commands</th>
        <th>Status description</th>
      </tr>
	 		<tr>
				<th>execute</th>
				<th>Get Schemata</th>
				<th>io-schemata-get</th>
				<th>-</th>
				<th>XML Schemata are returned immediately</th>
			</tr>
			<tr>
				<th>execute</th>
				<th>Start procedure</th>
				<th>input</th>
				<th>-</th>
				<th>output returns immediately (synchronous)</th>
			</tr>
			<tr>
				<th></th>
				<th>Start procedure</th>
				<th>input</th>
				<th>next, cancel</th>
				<th>asynchronous procedure was invoked</th>
			</tr>
			<tr>
				<th>next</th>
				<th>Check status</th>
				<th>getStatus</th>
				<th>next, cancel</th>
				<th>asynchronous procedure not finished</th>
			</tr>
			<tr>
				<th></th>
				<th>Check status</th>
				<th>getStatus</th>
				<th>next, complete, cancel</th>
				<th>asynchronous procedure finished</th>
			</tr>
			<tr>
				<th></th>
				<th>Get result</th>
				<th>getOutput</th>
				<th>next, complete, cancel</th>
				<th>result was delivered</th>
			</tr>
			<tr>
				<th>cancel</th>
				<th>Cancel/delete procedure</th>
				<th>-</th>
				<th>-</th>
				<th>procedure terminated</th>
			</tr>
			<tr>
				<th>complete</th>
				<th>Get result + delete procedure</th>
				<th>-</th>
				<th>-</th>
				<th>result was delivered, procedure terminated</th>
			</tr>
		</table>
		
	<section2 topic='Synchronous implementation - for immediately completing services' anchor='sync_imp'>
	<ol>
		<li>If a service can return the output immediately, it MAY respond with status='completed' and return the output (IO Data type='output'). This behavior is NOT RECOMMENDED for procedures that need more than 5 seconds to complete or that are cost-intensive.</li>
	</ol>
	</section2>
	<section2 topic='Asynchronous implementation - for services that cannot return the output immediately' anchor='async_imp'>
	<ol>
		<li>If a service cannot return the result immediately (this refers to procedures that need more than 5 seconds to complete) or the invoked procedure is cost-intensive, it SHOULD response with status='executing' and a &lt;actions&gt; element containing the &lt;next&gt; element.</li>
		<li>If the service returned status='executing' the requester MAY stay up-to-date by proceeding with action='next' combined with the IO Data transaction type='getStatus'. The responder MUST respond with status='executing' and a &lt;actions&gt; element containing the &lt;next&gt; element only as long as the procedure is not finished.</li>
		<li>If the procedure finished the responder MUST respond to this request (action='next') combined with the IO Data transaction type='getStatus' with status='executing' and a &lt;actions&gt; element containing the &lt;next&gt; and the &lt;complete&gt; elements to indicate that the output is ready for collection. The requester MAY then request the result by proceeding with action='complete' or action='next' combined with the IO Data transaction type='getOutput'.</li>
		<li>Asynchronous notification: If the procedure finished the service MUST actively notify the requester by sending a message containing an Ad-Hoc Command element with status='executing' and a &lt;actions&gt; element containing the &lt;next&gt; and the &lt;complete&gt; elements to indicate that the result is ready for collection.</li>
		<li>If the requester requests the output with action='complete' the responder MUST return the result (IO Data transaction type='output') with status='completed'. This means the Ad-Hoc Command session terminated. The responder MUST subsequently delete associated procedure and result.</li>
		<li>If the requester requests the output with action='next' combined with the IO Data transaction type='getOutput' the responder MUST return the result (IO Data transaction type='output') with status='executing' and a &lt;actions&gt; element containing the &lt;next&gt; and the &lt;complete&gt; elements to indicate that the the Ad-Hoc Command session continues to exist and the output is still available. The requester MUST subsequently delete the associated procedure and result with action='cancel'.</li>
	</ol>
	</section2>
	<section2 topic='Error handling' anchor='error_imp'>
	<p>Beside the errors that are associated with IQ or Ad-Hoc Command abstraction layer an internal procedure error may occur.</p>
	<ol>
		<li>If the procedure invocation fails (an error occurs) the responder MUST respond with status='completed'. To indicate that the procedure failed the &lt;note&gt; element MUST have type='error' as described in XEP 50 Ad-Hoc Commands. The service may provide additional error information within the IO Data data container (IO Data transaction type='error').</li>
		<li>Asynchronous implementation only: If the service returned status='executing' (asynchronous implementation) and the procedure fails (an error occurs) the service MUST actively notify the requester by sending a message containing an Ad-Hoc Command element with status='executing' and a &lt;actions&gt; element containing the &lt;next&gt; element to the invoker. To indicate that the procedure failed the &lt;note&gt; element MUST have type='error' as described in XEP 50 Ad-Hoc Commands. The service may provide additional error information within the IO Data data container (IO Data transaction type='error'). The requester SHOULD subsequently delete the associated procedure with action='cancel'.</li>
		<li>Asynchronous implementation only: If the procedure failed (an error occurs) the responder MUST respond to a status request (action='next') with status='executing' and a &lt;actions&gt; element containing the &lt;next&gt; element to the requester. To indicate that the procedure failed the &lt;note&gt; element MUST have type='error' as described in XEP 50 Ad-Hoc Commands. The service may provide additional error information within the IO Data data container (IO Data transaction type='error'). The requester SHOULD subsequently delete the associated procedure with action='cancel'.</li>
	</ol>
	</section2>
		<section2 topic='Optional status information' anchor='status_imp'>
	<ol>
        <li>As long as the procedure did not finish (!) the service MAY provide additional status information within the IO Data data container (IO Data transaction type='status').</li>	</ol>
	</section2>
	<p>Formalising machine to machine commands using the namespace defined herein, making such commands detectable and usable on-the-fly without the prerequisite for the requester to know the exact interface on the service site and the support for asynchronous as well as synchronous execution contributes to the usability of XMPP for complex grid-computing projects.</p>
	<p>In example an IDE could support the development of such projects by generating code interfaces (client stubs) to machine to machine capable XMPP services by discovering and requesting all required information on-the-fly.</p>
</section1>

<section1 topic='Use Cases' anchor='usecases'>
	
	
	<section2 topic='Discovering support' anchor='ret_coli'>
		<p>The requester can query for disco information on the command (Ad-Hoc Command) node to find out if it supports IO Data based commands.</p>
			<example caption='Disco request for command information'><![CDATA[
<iq type='get'
    from='user@university.example.org'
    to='service.university.example.org'
    id='iq_125'>
  <query xmlns='http://jabber.org/protocol/disco#info'
      node='get_threedimensionalcoordinates'/>
</iq>]]></example>
        	<example caption='Disco result for command information'><![CDATA[
<iq type='result'
    from='service.university.example.org'
    to='user@university.example.org'
    id='iq_125'>
  <query xmlns='http://jabber.org/protocol/disco#info'
      node='get_threedimensionalcoordinates'>
    <feature var='http://jabber.org/protocol/commands'/>
    <feature var='urn:xmpp:tmp:io-data'/>
  </query>
</iq>]]></example>
		<p>To indicate support for IO Data it MUST include &lt;feature var='urn:xmpp:tmp:io-data'/&gt;. Of course the node can still provide &lt;feature var='jabber:x:data'/&gt; if this is supported, too.</p>
	</section2>
		
		
	<section2 topic='Retrieving the IO Schemata' anchor='ret-schemata'>
		<p>The 'in' and 'out' elements may each have any valid XML encoded elements as children. From a XML document style type of view &lt;in/&gt; and &lt;out/&gt; may be seen as root elements. Therefore it is required to "discover" the XML Schemata of the "dynamic children" of &lt;in/&gt; and &lt;out/&gt; (IO Schemata). This way a requester can marshal an API for the input and output of a certain service.</p>
		<p>Beside the 'in' and 'out' elements an 'error' element is optionally allowed and would be discovered in exactly the same. It is not included in the example to keep it simple.</p>
		<p>The XML Schemata request is done by setting the type of the IO Data element to 'io-schemata-get'.</p>
			<example caption='IO Schemata request'><![CDATA[
<iq type='set'
    from='user@university.example.org'
    to='service.university.example.org'
    id='iq_126'>
  <command xmlns='http://jabber.org/protocol/commands'
      node='get_threedimensionalcoordinates'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='io-schemata-get'/>
  </command>
</iq>
]]></example>
		<example caption='IO Schemata result'><![CDATA[
<iq type='result'
    from='service.university.example.org'
    to='user@university.example.org'
    id='iq_126'>
  <command xmlns='http://jabber.org/protocol/commands'
      node='get_threedimensionalcoordinates'
      status='completed'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='io-schemata-result'>
      <desc>
        This service returns 3D atomic coordinates for the
        input structure. The input and output is encoded using the
        Chemical Markup Language (CML). 
      </desc>
      <in>
        <xs:complexType>
          <xs:any namespace='http://www.xml-cml.org/schema'
              minOccur='1' maxOccur='1'/>
        </xs:complexType>
      </in>
      <out>
        <xs:complexType>
          <xs:any namespace='http://www.xml-cml.org/schema'
              minOccur='1' maxOccur='1'/>
        </xs:complexType>
      </out>
    </iodata>
  </command>
</iq>
]]></example>
		<p>This service example requires the content of &lt;in/&gt; and &lt;out/&gt; to be <cite>Chemical Markup Language</cite> <note>The Chemical Markup Language: &lt;<link url='http://www.xml-cml.org/'>http://www.xml-cml.org/</link>&gt;.</note> by requiring input with the namespace 'http://www.xml-cml.org/schema'. Additionally, it also defines the returned output to be <cite>Chemical Markup Language</cite>.</p>
	</section2>
	
	
	<section2 topic='Executing a service' anchor='exec_serv'>
		<p>To keep the example simple the children of the 'in' and 'out' elements just contain strings (the protein name and protein sequence). However in real use cases it is likely that the children of 'in' and 'out' contain very complex XML documents with many different valid elements, namespaces, or values.</p>
		<p>The requester transmits the input to the service (responder) by setting the type of the IO Data element to 'input'.</p>
		<example caption='Execute Command request'><![CDATA[
<iq type='set'
    from='user@university.example.org'
    to='service.university.example.org'
    id='iq_127'>
  <command xmlns='http://jabber.org/protocol/commands'
      node='get_proteinsequence'
      action='execute'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='input'>
      <in>
        <proteinname xmlns='http://university.example.org/protocol/proteinservice/proteinname'>
          CAB08284
        </proteinname>
      </in>
    </iodata>
  </command>
</iq>
]]></example>
		<p>The service transmits the output to the requester by setting the type of the IO Data element to 'output'.</p>
		<example caption='Execute command result'><![CDATA[
<iq type='result'
    from='service.university.example.org'
    to='user@university.example.org'
    id='iq_127'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000001'
      node='get_proteinsequence'
      status='completed'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='output'>
      <out>
        <proteinsequence xmlns='http://university.example.org/protocol/proteinservice/proteinsequence'>
            mrkhpqsatk hlfvsggvas slgkgltass lgqlltargl hvtmqkldpy lnvdpgtmnp
            fqhgevfvte dgaetdldvg hyerfldrdl sgsanvttgq vystviaker rgeylgdtvq
            viphitdeik qrimamaqpd ggdnrpdvvi teiggtvgdi esqpfleaar qvrhdlgren
            vfflhvslvp hlapsgelkt kptqhsvaal rsigitpdal ilrcdrdvpe slknkialmc
            dvdidgvist pdapsiydip kvlhreelda fvvrrlnlpf rdvdwtewdd llrrvhephg
            tvrialvgky vdfsdaylsv sealhaggfk hyakvevvwv asddcetatg aaavladvhg
            vlipggfgir giegkigair yararglpvl glclglqciv ieatrsvglv qansaefepa
            tpdpvistma dqkeivagea dfggtmrlga ypavlqpasi vaqaygttqv serhrhryev
            nnayrdwiae sglrisgtsp dgylvefvey panmhpfvvg tqahpelksr ptrphplfva
            fvgaaidyks aellpveipa vpeisehlpn ssnqhrdgve rsfpapaarg
        </proteinsequence>
      </out>
    </iodata>
  </command>
</iq>
]]></example>
	</section2>


	<section2 topic='Executing a time-consuming service' anchor='exec_serv_time'>
		<p>In this example the Ad-Hoc Command is a time-consuming and cost-intensive computation service. To keep the example simple the computation is a WAV to MP3 encoder - the input and output elements of this example make use of &xep0231;.</p>
		<example caption='Execute Command request'><![CDATA[
<iq type='set'
    from='user@server.org'
    to='encoder.server.org'
    id='iq_128'>
  <command xmlns='http://jabber.org/protocol/commands'
      node='wav2mp3'
      action='execute'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='input'>
      <in>
        <data xmlns='urn:xmpp:tmp:data-element' 
            alt='my-song.wav'
            type='audio/x-wav'>
               [ ... base64-encoded-audio ... ]
        </data>
      </in>
    </iodata>
  </command>
</iq>
]]></example>
		<p>The service notifies the requester that the job is accepted: status='executing' and a &lt;actions&gt; element contains the &lt;next&gt; element.</p>
		<example caption='Execute command result'><![CDATA[
<iq type='result'
    from='encoder.user.org'
    to='user@user.org'
    id='iq_128'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='executing'>
    <note type='info'>WAV to MP3 encoding has been started. You may stay up to
        date using the next-action.
    </note>
    <actions>
      <next/>
    </actions>
  </command>
</iq>
]]></example>
		<p>The requester MAY stay up-to-date by proceeding with action='next' combined with the IO Data transaction type='getStatus'.</p>
<example caption='Execute Command request'><![CDATA[
<iq type='set'
    from='user@server.org'
    to='encoder.server.org'
    id='iq_129a'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      action='next'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='getStatus'>
  </command>
</iq>
]]></example>
		<p>The service returns the status of the procedure. The "still calculating"-status is indicated with the &lt;actions&gt; element that contains the &lt;next&gt; element only. The "calculation finished"-status is indicated with the &lt;actions&gt; element that contains the &lt;next&gt; and &lt;complete&gt; elements.</p>
		<p>Optionally the result MAY contain additional status information within the IO Data element with IO Data transaction type='status' although is not shown here to keep the example simple.</p>
		<example caption='Execute command result'><![CDATA[
<iq type='result'
    from='encoder.user.org'
    to='user@user.org'
    id='iq_129a'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='executing'>
    <actions>
       <next/>
    </actions>
  </command>
</iq>
]]></example>

		<p>If the procedure is complete the service notifies the invoker with a message stanza containing an Ad-Hoc Command namespace with status='executing' and a &lt;actions&gt; element that contains the &lt;next&gt; and &lt;complete&gt; elements. The &lt;complete&gt; element indicates the calculation finished.</p>
		<example caption='Notification message'><![CDATA[
<message from='encoder.user.org'
    to='user@user.org'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='executing'>
    <note type='info'>WAV to MP3 encoding finished. You may request the
        output now.</note>
    <actions>
       <complete/>
       <next/>
    </actions>
  </command>
</iq>
]]></example>
		<p>After that the requester can request the output with the Ad-Hoc Command action='complete'.</p>
<example caption='Execute Command request'><![CDATA[
<iq type='set'
    from='user@server.org'
    to='encoder.server.org'
    id='iq_130a'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      action='complete'/>
</iq>
]]></example>
		<p>The service returns the MP3 within the IO Data element. The status of the Ad-Hoc Command completed (status='completed').</p>
		<example caption='Execute command result'><![CDATA[
<iq type='result'
    from='encoder.user.org'
    to='user@user.org'
    id='iq_130a'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='completed'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='output'>
      <out>
        <data xmlns='urn:xmpp:tmp:data-element' 
            alt='my-song.mp3'
            type='audio/mpeg'>
               [ ... base64-encoded-audio ... ]
        </data>
      </out>
    </iodata>
  </command>
</iq>
]]></example>

		<p>Alternatively the requester can request the output with the Ad-Hoc Command action='next' combined with the IO Data transaction type='getOutput'. This will keep the Ad-Hoc Command session alive and it must be deleted subsequently. This design allows to recover from network breakage during the result transmission state of the client-server communication, but allowing to request receiving the computation results or second time, because the session was left open after the first request.</p>
<example caption='Execute Command request'><![CDATA[
<iq type='set'
    from='user@server.org'
    to='encoder.server.org'
    id='iq_130b'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      action='next'>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='getOutput'>
  </command>
</iq>
]]></example>
		<p>The service returns the MP3 within the IO Data element. The status of the Ad-Hoc Command remains active (status='executing').</p>
		<example caption='Execute command result'><![CDATA[
<iq type='result'
    from='encoder.user.org'
    to='user@user.org'
    id='iq_130b'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='executing'>
    <actions>
       <complete/>
       <next/>
    </actions>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='output'>
      <out>
        <data xmlns='urn:xmpp:tmp:data-element' 
            alt='my-song.mp3'
            type='audio/mpeg'>
               [ ... base64-encoded-audio ... ]
        </data>
      </out>
    </iodata>
  </command>
</iq>
]]></example>
		<p>The requester MUST subsequently delete the remote procedure with the Ad-Hoc Command action='cancel'.</p>
<example caption='Execute Command request'><![CDATA[
<iq type='set'
    from='user@server.org'
    to='encoder.server.org'
    id='iq_131'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      action='cancel'/>
</iq>
]]></example>
		<p>The remote procedure is deleted.</p>
		<example caption='Execute command result'><![CDATA[
<iq type='result'
    from='encoder.user.org'
    to='user@user.org'
    id='iq_130'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='canceled'/>
</iq>
]]></example>
	</section2>

	<section2 topic='Asynchronous error notification' anchor='async_error_serv_time'>
		<p>In case of an error the service the service notifies the invoker with a message stanza containing an Ad-Hoc Command namespace with status='executing' and a &lt;actions&gt; element that contains the &lt;next&gt; element. In addition to that it MUST contain a &lt;note&gt; element with type='error' to indicate the error.</p>
		<p>The error notification MAY contain additional error information within the IO Data element with IO Data transaction type='error'.</p>
		<example caption='Error notification message'><![CDATA[
<message from='encoder.user.org'
    to='user@user.org'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='executing'>
    <note type='error'>#593 - The encoder could not parse the file.</note>
    <actions>
       <next/>
    </actions>
    <iodata xmlns='urn:xmpp:tmp:io-data' type='error'>
      <error>
        <errorcode/>593</errorcode>
        <description>The encoder could not parse the file.</description>
      </error>
    </iodata>
  </command>
</iq>
]]></example>
		<p>In case of an error the service would respond to a status request (Ad-Hoc Command action='next' combined with the IO Data transaction type='getStatus') in a very similar way except that a &lt;iq&gt; and not a &lt;message&gt; would be used.</p>
	</section2>

	<section2 topic='Canceling a time-consuming service' anchor='cancel_serv_time'>
		<p>An asynchronous remote procedure may be canceled (deleted) by the invoker at any time.</p>
		<example caption='Cancel Command request'><![CDATA[
<iq type='set'
    from='user@server.org'
    to='encoder.server.org'
    id='iq_129b'>
  <command xmlns='http://jabber.org/protocol/commands'
      node='wav2mp3'
      action='cancel'/>
</iq>
]]></example>
		<p>The remote procedure is deleted.</p>
		<example caption='Cancel command result'><![CDATA[
<iq type='result'
    from='encoder.user.org'
    to='user@user.org'
    id='iq_129b'>
  <command xmlns='http://jabber.org/protocol/commands'
      sessionid='RPC-SESSION-0000002'
      node='wav2mp3'
      status='canceled'/>
</iq>
]]></example>
	</section2>
</section1>

<section1 topic='Error Codes' anchor='error'>
  <p>Error codes on the Ad-Hoc Command abstraction layer are inherited from Ad-Hoc Commands.</p>
  <p>Application specific errors associated with a remote procedure call realized with IO Data in combination with Ad-Hoc Commands were described in section 3 - Implementation notes.</p>
</section1>

<section1 topic='Internationalization Considerations' anchor='i18n'>
  <p>Internationalization of messages sent by the server is covered by setting the @xml:lang attribute of the &lt;iq&gt; element. Services should reply in the same language in which the client asked the question. That is, if the client specifies a locale using the @xml:lang attribute on the &lt;iq> element, then the server should reply in the same locale, and localize messages given in &lt;desc&gt;, &lt;node&gt;@info and &lt;query&gt;&lt;item&gt;@name.</p>
</section1>

<section1 topic='Security Considerations' anchor='security'>
  <p>To follow.</p>
</section1>

<section1 topic='IANA Considerations' anchor='iana'>
  <p>This document requires no interaction with &IANA;.</p> 
</section1>

<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
  <section2 topic='Protocol Namespaces' anchor='ns'>
    <p>Until this specification advances to a status of Draft, its associated namespace shall be "urn:xmpp:tmp:io-data"; upon advancement of this specification, the &REGISTRAR; shall issue a permanent namespace in accordance with the process defined in Section 4 of &xep0053;.</p>
  </section2>
</section1>

<section1 topic='XML Schema' anchor='schema'>
  <code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:tmp:io-data'
    xmlns='urn:xmpp:tmp:io-data'
    elementFormDefault='qualified'>

  <xs:element name='iodata'>
    <xs:complexType>
      <xs:element name='desc' minOccurs='0' maxOccurs='1'
                  type='xs:string'/>
      <xs:element name='in' minOccurs='0' maxOccurs='1'/>
      <xs:element name='out' minOccurs='0' maxOccurs='1'/>
      <xs:element name='error' minOccurs='0' maxOccurs='1'/>
      <xs:element name='status' minOccurs='0' maxOccurs='1'/>
      <xs:attribute name='type' use='required'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='io-schemata-get'/>
            <xs:enumeration value='io-schemata-result'/>
            <xs:enumeration value='input'/>
            <xs:enumeration value='output'/>
            <xs:enumeration value='getStatus'/>
            <xs:enumeration value='getOutput'/>
            <xs:enumeration value='error'/>
            <xs:enumeration value='status'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:anyAttribute/>
    </xs:complexType>
  </xs:element>

  <xs:element name='in'>
    <xs:choice>
      <!-- for x@type='io-schemata-result' : -->
      <xs:any namespace='http://www.w3.org/2001/XMLSchema'
              minOccurrence='1' maxOccurence='1'/>
      <!-- for x@type='input' : -->
      <xs:any namespace='##other' processContents='strict'/>
    </xs:choice>
  </xs:element>

  <xs:element name='out'>
    <xs:choice>
      <!-- for x@type='io-schemata-result' : -->
      <xs:any namespace='http://www.w3.org/2001/XMLSchema'
              minOccurrence='1' maxOccurence='1'/>
      <!-- for x@type='output' : -->
      <xs:any namespace='##other' processContents='strict'/>
    </xs:choice>
  </xs:element>
  
  <xs:element name='error'>
    <xs:choice>
      <!-- for x@type='io-schemata-result' : -->
      <xs:any namespace='http://www.w3.org/2001/XMLSchema'
              minOccurrence='1' maxOccurence='1'/>
      <!-- for x@type='error' : -->
      <xs:any namespace='##other' processContents='strict'/>
    </xs:choice>
  </xs:element>
  
  <xs:element name='status'>
    <!-- for x@type='status' -->
    <xs:element name='elapsed' minOccurs='0' maxOccurs='1'
              type='xs:integer'/>
    <xs:element name='remaining' minOccurs='0' maxOccurs='1'
              type='xs:integer'/>
    <xs:element name='percentage' minOccurs='0' maxOccurs='1'
              type='xs:integer'/>
    <xs:element name='information' minOccurs='0' maxOccurs='1'
              type='xs:string'/>
  </xs:element>

</xs:schema>
    ]]></code>
</section1>

<section1 topic='Acknowledgements' anchor='ackn'>
  <p><link url='http://bioclipse.net/'>The Bioclipse Project</link></p>
</section1>
</xep>
