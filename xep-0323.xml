<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
	<!ENTITY % ents SYSTEM 'xep.ent'>
	%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
  <header>
    <title>Internet of Things - Sensor Data</title>
    <abstract>This specification provides the common framework for sensor data interchange over XMPP networks.</abstract>
    &LEGALNOTICE;
    <number>0323</number>
    <status>Experimental</status>
    <type>Standards Track</type>
    <sig>Standards</sig>
    <approver>Council</approver>
    <dependencies>
      <spec>XMPP Core</spec>
      <spec>XEP-0001</spec>
      <spec>XEP-0030</spec>
    </dependencies>
    <supersedes/>
    <supersededby/>
    <shortname>sensor-data</shortname>
    <author>
      <firstname>Peter</firstname>
      <surname>Waher</surname>
      <email>peterwaher@hotmail.com</email>
      <jid>peter.waher@jabber.org</jid>
      <uri>http://www.linkedin.com/in/peterwaher</uri>
    </author>
    <revision>
      <version>0.5</version>
      <date>2015-11-09</date>
      <initials>pw</initials>
      <remark>
        <p>Updated contact information.</p>
	<p>Updated example JIDs to example.org</p>
      </remark>
    </revision>
    <revision>
      <version>0.4</version>
      <date>2015-03-02</date>
      <initials>pw</initials>
      <remark>
        <p>
          Added '<strong>cancel</strong>' and '<strong>cancelled</strong>' elements to the XML schema.
          These elements where previously available in <link url='#cancelreadout'>use cases</link>, but not documented in the XML schema.
        </p>
      </remark>
    </revision>
    <revision>
      <version>0.3</version>
      <date>2014-04-07</date>
      <initials>pw</initials>
      <remark>
        <p>
          Updated IQ-error stanzas for <link url='#readoutrejected'>readout rejections</link> to make them compliant with RFC-6120.
        </p>
        <p>
          The element <strong>rejected</strong> is no longer used and has been removed.
        </p>
        <p>
          Harmonization of data types between XEP-0323 and XEP-0325. This has resulted in the addition of the following new field types: <strong>date</strong>,
          <strong>int</strong>, <strong>long</strong> and <strong>time</strong>. The <strong>timeSpan</strong> type has been renamed <strong>duration</strong>.
        </p>
        <p>
          The term Field Status Value has been renamed <link url='#fieldqosvalues'>Field Quality of Service Value</link>, to make it clearer.
        </p>
        <p>
          Added a <link url='#fieldqosvalues'>inProgress</link> field quality of service value.
        </p>
        <p>
          Added a section giving an example of the <link url='#estimatesvsreadouts'>difference between estimates and normally read values</link>.
        </p>
        <p>
          A new field attribute named <link url='#control'>writable</link> has been added. It can be used to inform clients that the corresponding value can be controlled
          using XEP-0325.
        </p>
        <p>Added anchors to all second level subsections.</p>
      </remark>
    </revision>
    <revision>
      <version>0.2</version>
      <date>2014-03-10</date>
      <initials>pw</initials>
      <remark>
        <p>Changed the id attrobutes of IQ stanzas, to highlight they are different from sequence numbers used in requests.</p>
        <p>Fixed links to documents with new numbers.</p>
        <p>Changed namespace urn:xmpp:sn to urn:xmpp:iot:sensordata</p>
      </remark>
    </revision>
    <revision>
      <version>0.1</version>
      <date>2013-04-16</date>
      <initials>psa</initials>
      <remark>
        <p>Initial published version approved by the XMPP Council.</p>
      </remark>
    </revision>
    <revision>
      <version>0.0.5</version>
      <date>2013-04-01</date>
      <initials>pw</initials>
      <remark>
        <p>Added resource information of original called to their corresponding JIDs.</p>
        <p>Changed the return type of a rejected message.</p>
        <p>Made images inline.</p>
        <p>Converted the glossary into a definition list.</p>
      </remark>
    </revision>
    <revision>
      <version>0.0.4</version>
      <date>2013-03-18</date>
      <initials>pw</initials>
      <remark>
        <p>Added information about how to read sensors from large subsystems.</p>
        <p>Added support for client/device provisioning tokens.</p>
      </remark>
    </revision>
    <revision>
      <version>0.0.3</version>
      <date>2013-03-11</date>
      <initials>pw</initials>
      <remark>
        <p>Changed time point to timestamp everywhere.</p>
        <p>Corrected some errors in the text.</p>
        <p>Made the accepted response optional.</p>
      </remark>
    </revision>
    <revision>
      <version>0.0.2</version>
      <date>2013-03-09</date>
      <initials>pw</initials>
      <remark>
        <p>Corrected some errors in XML examples.</p>
        <p>English corrected.</p>
        <p>
          Added <strong>errors</strong> elements to the <strong>rejected</strong> element.
        </p>
        <p>
          Added <strong>cancel</strong> command with corresponding <strong>cancelled</strong> response.
        </p>
      </remark>
    </revision>
    <revision>
      <version>0.0.1</version>
      <date>2013-03-07</date>
      <initials>pw</initials>
      <remark>
        <p>First draft.</p>
      </remark>
    </revision>
  </header>
  <section1 topic='Introduction' anchor='intro'>
    <p>
      This XEP provides the underlying architecture, basic operations and data structures for sensor data communication over XMPP networks. It includes a hardware abstraction model, removing any
      technical detail implemented in underlying technologies.
    </p>
    <p>
      Note has to be taken, that these XEP's are designed for implementation in sensors, many of which have very limited amount of memory (both RAM and ROM) or resources (processing power).
      Therefore, simplicity is of utmost importance. Furthermore, sensor networks can become huge, easily with millions of devices in peer-to-peer networks.
    </p>
    <p>
      Sensor networks contains many different architectures and use cases. For this reason, the sensor network standards have been divided into multiple XEPs according to the following table:
    </p>
    <table caption='Internet of Things XEPs'>
      <tr>
        <th>XEP</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>xep-0000-IoT-BatteryPoweredSensors</td>
        <td>Defines how to handle the peculiars related to battery powered devices, and other devices intermittently available on the network.</td>
      </tr>
      <tr>
        <td>xep-0000-IoT-Events</td>
        <td>Defines how sensors send events, how event subscription, hysteresis levels, etc., are configured.</td>
      </tr>
      <tr>
        <td>xep-0000-IoT-Interoperability</td>
        <td>Defines guidelines for how to achieve interoperability in sensor networks, publishing interoperability interfaces for different types of devices.</td>
      </tr>
      <tr>
        <td>xep-0000-IoT-Multicast</td>
        <td>Defines how sensor data can be multicast in efficient ways.</td>
      </tr>
      <tr>
        <td>xep-0000-IoT-PubSub</td>
        <td>Defines how efficient publication of sensor data can be made in sensor networks.</td>
      </tr>
      <tr>
        <td>xep-0000-IoT-Chat</td>
        <td>Defines how human-to-machine interfaces should be constructed using chat messages to be user friendly, automatable and consistent with other IoT extensions and possible underlying architecture.</td>
      </tr>
      <tr>
        <td>XEP-0322</td>
        <td>
          Defines how to EXI can be used in XMPP to achieve efficient compression of data. Albeit not a sensor network specific XEP, this XEP should be considered
          in all sensor network implementations where memory and packet size is an issue.
        </td>
      </tr>
      <tr>
        <td>XEP-0323</td>
        <td>
          This specification. Provides the underlying architecture, basic operations and data structures for sensor data communication over XMPP networks.
          It includes a hardware abstraction model, removing any technical detail implemented in underlying technologies. This XEP is used by all other sensor network XEPs.
        </td>
      </tr>
      <tr>
        <td>XEP-0324</td>
        <td>Defines how provisioning, the management of access privileges, etc., can be efficiently and easily implemented.</td>
      </tr>
      <tr>
        <td>XEP-0325</td>
        <td>Defines how to control actuators and other devices in Internet of Things.</td>
      </tr>
      <tr>
        <td>XEP-0326</td>
        <td>Defines how to handle architectures containing concentrators or servers handling multiple sensors.</td>
      </tr>
      <tr>
        <td>XEP-0331</td>
        <td>Defines extensions for how color parameters can be handled, based on &xep0004;</td>
      </tr>
      <tr>
        <td>XEP-0336</td>
        <td>Defines extensions for how dynamic forms can be created, based on &xep0004;, &xep0122;, &xep0137; and &xep0141;.</td>
      </tr>
      <tr>
        <td>XEP-0347</td>
        <td>Defines the peculiars of sensor discovery in sensor networks. Apart from discovering sensors by JID, it also defines how to discover sensors based on location, etc.</td>
      </tr>
    </table>
  </section1>
  <section1 topic='Glossary' anchor='glossary'>
    <p>The following table lists common terms and corresponding descriptions.</p>
    <dl>
      <di>
        <dt>Actuator</dt>
        <dd>Device containing at least one configurable property or output that can and should be controlled by some other entity or device.</dd>
      </di>
      <di>
        <dt>Computed Value</dt>
        <dd>A value that is computed instead of measured.</dd>
      </di>
      <di>
        <dt>Concentrator</dt>
        <dd>Device managing a set of devices which it publishes on the XMPP network.</dd>
      </di>
      <di>
        <dt>Field</dt>
        <dd>
          One item of sensor data. Contains information about: Node, Field Name, Value, Precision, Unit, Value Type, Status, Timestamp, Localization information, etc.
          Fields should be unique within the triple (Node ID, Field Name, Timestamp).
        </dd>
      </di>
      <di>
        <dt>Field Name</dt>
        <dd>Name of a field of sensor data. Examples: Energy, Volume, Flow, Power, etc.</dd>
      </di>
      <di>
        <dt>Field Type</dt>
        <dd>What type of value the field represents. Examples: Momentary Value, Status Value, Identification Value, Calculated Value, Peak Value, Historical Value, etc.</dd>
      </di>
      <di>
        <dt>Historical Value</dt>
        <dd>A value stored in memory from a previous timestamp.</dd>
      </di>
      <di>
        <dt>Identification Value</dt>
        <dd>A value that can be used for identification. (Serial numbers, meter IDs, locations, names, etc.)</dd>
      </di>
      <di>
        <dt>Localization information</dt>
        <dd>Optional information for a field, allowing the sensor to control how the information should be presented to human viewers.</dd>
      </di>
      <di>
        <dt>Meter</dt>
        <dd>A device possible containing multiple sensors, used in metering applications. Examples: Electricity meter, Water Meter, Heat Meter, Cooling Meter, etc.</dd>
      </di>
      <di>
        <dt>Momentary Value</dt>
        <dd>A momentary value represents a value measured at the time of the read-out.</dd>
      </di>
      <di>
        <dt>Node</dt>
        <dd>
          Graphs contain nodes and edges between nodes. In Internet of Things, sensors, actuators, meters, devices, gateways, etc., are often depicted as nodes whereas links between sensors (friendships)
          are depicted as edges. In abstract terms, it's easier to talk about a Node, rather than list different possible node types (sensors, actuators, meters, devices, gateways, etc.).
          Each Node has a Node ID.
        </dd>
      </di>
      <di>
        <dt>Node ID</dt>
        <dd>
          An ID uniquely identifying a node within its corresponding context. If a globally unique ID is desired, an architecture should be used using a universally accepted
          ID scheme.
        </dd>
      </di>
      <di>
        <dt>Parameter</dt>
        <dd>
          Readable and/or writable property on a node/device. The XEP-0326 &xep0326; deals with reading and writing parameters
          on nodes/devices. Fields are not parameters, and parameters are not fields.
        </dd>
      </di>
      <di>
        <dt>Peak Value</dt>
        <dd>A maximum or minimum value during a given period.</dd>
      </di>
      <di>
        <dt>Precision</dt>
        <dd>
          In physics, precision determines the number of digits of precision. In sensor networks however, this definition is not easily applicable. Instead, precision
          determines, for example, the number of decimals of precision, or power of precision. Example: 123.200 MWh contains 3 decimals of precision. All entities parsing and
          delivering field information in sensor networks should always retain the number of decimals in a message.
        </dd>
      </di>
      <di>
        <dt>Sensor</dt>
        <dd>
          Device measuring at least one digital value (0 or 1) or analog value (value with precision and physical unit). Examples: Temperature sensor, pressure sensor, etc.
          Sensor values are reported as fields during read-out. Each sensor has a unique Node ID.
        </dd>
      </di>
      <di>
        <dt>SN</dt>
        <dd>Sensor Network. A network consisting, but not limited to sensors, where transport and use of sensor data is of primary concern. A sensor network may contain actuators, network applications, monitors, services, etc.</dd>
      </di>
      <di>
        <dt>Status Value</dt>
        <dd>A value displaying status information about something.</dd>
      </di>
      <di>
        <dt>Timestamp</dt>
        <dd>Timestamp of value, when the value was sampled or recorded.</dd>
      </di>
      <di>
        <dt>Token</dt>
        <dd>
          A client, device or user can get a token from a provisioning server. These tokens can be included in requests to other entities in the network, so these entities can validate
          access rights with the provisioning server.
        </dd>
      </di>
      <di>
        <dt>Unit</dt>
        <dd>Physical unit of value. Example: MWh, l/s, etc.</dd>
      </di>
      <di>
        <dt>Value</dt>
        <dd>A field value.</dd>
      </di>
      <di>
        <dt>Value Status</dt>
        <dd>Status of field value. Contains important status information for Quality of Service purposes. Examples: Ok, Error, Warning, Time Shifted, Missing, Signed, etc.</dd>
      </di>
      <di>
        <dt>Value Type</dt>
        <dd>Can be numeric, string, boolean, Date &amp; Time, Time Span or Enumeration.</dd>
      </di>
      <di>
        <dt>WSN</dt>
        <dd>Wireless Sensor Network, a sensor network including wireless devices.</dd>
      </di>
      <di>
        <dt>XMPP Client</dt>
        <dd>Application connected to an XMPP network, having a JID. Note that sensors, as well as applications requesting sensor data can be XMPP clients.</dd>
      </di>
    </dl>
  </section1>
  <section1 topic='Use Cases' anchor='usecases'>
    <p>
      The most common use case for a sensor network application is meter read-out. It's performed using a request and response mechanism, as is shown in the following diagram.
    </p>
    <p>
      <img src='data:image/png;base64,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'/>
    </p>
    <p>
      The read-out request is started by the client sending a <strong>req</strong> request to the device. Here, the client selects a sequence number <strong>seqnr</strong>.
      It should be unique among requests made by the client. The device will use this sequence numbers in all messages sent back to the client.
    </p>
    <p>
      The request also contains a set of <strong>field types</strong> that very roughly determine what the client wants to read. What the client actually will return will be determined by
      a lot of other factors, such as make and model of device, any provisioning rules provided, etc. This parameter just gives a hint on what kind of data is desired. It is implicit in the request
      by the context what kind of data is requested. Examples of field types are: Momentary values, peak values, historical values, computed values, status values, identification values, etc.
    </p>
    <p>
      If reading historical values, the client can also specify an optional time range using the <strong>from</strong> and <strong>to</strong> parameter values, giving the device a hint on
      how much data to return.
    </p>
    <p>
      If the client wants the read-out to be performed at a given point in time, the client can define this using the optional parameter <strong>when</strong>.
    </p>
    <p>
      There's an optional parameter <strong>ids</strong> that the client can provide, listing a set of <strong>Node IDs</strong>. If omitted, the request includes all sensors or devices
      managed by the current JID. But, if the JID is controlled by a system, device or concentrator managing various devices, the <strong>ids</strong> parameter restricts the read-out to
      specific individuals.
    </p>
    <p>
      <strong>Note:</strong> The device is not required to follow the hints given by the client. These are suggestions the client can use to minimize its effort to perform the read-out.
      The client MUST make sure the response is filtered according to original requirements by the client after the read-out response has been received.
    </p>
    <p>
      If the device accepts the client request, it sends an <strong>accepted</strong> response back to the client. The device also has to determine if the read-out is commenced directly,
      or if it is to be queued for later processing. Note that the request can be queued for several reasons. The device can be busy, and queues it until it is ready to process the request.
      It can also queue the request if the client has requested it to be executed at a given time. If the request is queued, the device informs the client of this using the <strong>queued</strong>
      attribute. Note however, that the device will process the request when it can. There's no guarantee that the device will be able to process the request exactly when the client requests it.
    </p>
    <p>
      <strong>Note:</strong> The <strong>accepted</strong> message can be omitted if the device already has the response and is ready to send it. If the client receives field data or a
      <strong>done</strong> message before receiving an <strong>accepted</strong> message, the client can assume the device accepted the request and omitted sending an <strong>accepted</strong>
      element.
    </p>
    <p>
      If the request was queued, the device will send a message informing the client when the read-out is begun. This is done using a <strong>started</strong> message, using the same
      <strong>seqnr</strong> used in the original request.
    </p>
    <p>
      <strong>Note:</strong> Sending a <strong>started</strong> element should be omitted by the device if the request is not queued on the device. If the <strong>queued</strong> attribute
      is omitted in the response, or has the value <strong>false</strong>, the client must not assume the device will send a <strong>started</strong> element.
    </p>
    <p>
      During the read-out, the device sends partial results back to the client using the same <strong>seqnr</strong> as used in the request, using a <strong>fields</strong> message.
      These messages will contain a sequence of fields read out of the device. The client is required to filter this list according to original specifications, as the device is not required
      to do this filtering for the client.
    </p>
    <p>
      When read-out is complete, the device will send a <strong>done</strong> message to the client with the same <strong>seqnr</strong> as in the original request. Since the sender
      of messages in the device at the time of sending might not be aware of if there are more messages to send or not, the device can send this message separately as is shown in the
      diagram. If the device however, knows the last message containing fields is the last, it can set a <strong>done</strong> attribute in the message, to skip this last message.
    </p>
    <p>
      <strong>Note:</strong> There is no guarantee that the device will send a corresponding <strong>started</strong> and <strong>fields</strong> element, even though the request was
      accepted. The device might lose power during the process and forget the request. The client should always be aware of that devices may not respond in time, and take appropriate action
      accordingly (for instance, implementing a retry mechanism).
    </p>
    <p>
      If a failure occurs while performing the read-out, a <strong>failure</strong> message is sent, instead of a corresponding <strong>fields</strong> message, as is shown in the following diagram.
      Apart from notifying the client that a failure to perform the read-out, or part thereof, has occurred, it also provides a list of errors that the device encountered while trying. Note that
      multiple <strong>fields</strong> and <strong>failure</strong> messages can be sent back to the client during the read-out.
    </p>
    <p>
      <img src='data:image/png;base64,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'/>
    </p>
    <p>
      The device can also reject a read-out request. Reasons for rejecting a request may be missing privileges defined by provisioning rules, etc. It's not part of this XEP
      to define such rules. A separate XEP (&xep0324;) defines an architecture for how such provisioning can be easily implemented.
    </p>
    <p>
      A rejection response is shown in the following diagram.
    </p>
    <p>
      <img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZ0AAADjCAIAAADR4l7wAAAOtElEQVR4nO3d244Uxx3H8XomkBHbT5IYKRgS+iWiSFw4NrICmgeIjcIVsbiIg9SXNjFXsWTWZxMPBy/YYMDAgk8YLE0u+lTdVd3TM9Mz0/2r70crebenp6q6av6/qeldCzMDAC1m2wMAgJ6RawDUlLlmAGDkPLm26VDFlrDWkESuBY21hiRyLWisNSSRa0FjrSGJXAsaaw1JK+badBKZaDItDyRx9ZcScbLwkJw2551d6aOHASxmyQEk8aJjq3e0MkINqtaRa8WBxRKqsc055xonVlYcwCI2NgC3o9UQahDWJdemkyjbe+Qlmh+J4rgt14ofihbqDbS3WW59yp/T0k5bTopWyoLvOADrSJR2V2+8/Vm1ExYfQGW/5nZUXnuczPwdrYBQg7YOuVYp1NnM3jpMJ5Fp/RxanFUPpnrbnjbLk/MG3Ojxb5fmD6C1u6xxz7CdqVh6APZUtD1afNPffo1Qg7zF9mv1Km35HJrElW1WKT1W37C5bdpNZ9XdNdfmD8BzCU7jc4ZdRu4yA7BzrXV4lUVYPdcINYSgS67lWjY7lXOswGioUncD1LCBKtOkcqTSdOPtrZYB1PZB3sbb7o21bKMWHYD3Jlyl/doELY9QQyA65Fq3e2EZ5+5SGT92C/kWJYqiys6n2ma5kbESoHhauSlqvb3lH4CnO7dx51meqVh2AP77a7Vn+jqK7f1g9ZtuKw3IW2S/pmn9vzP1WvzvPFYU2LIiaOTaNnIt3XttMNYCW1OEjlzTx4IiNOSaOFYTASLXlLGUCBO5Jot1RLD8uQYBW3pFAdtn2K8BEEOuAVBDrgFQQ64BUEOuAVBDrgFQQ64BUEOuAVBDrgFQQ64BUEOuAVBDrgFQs5Zc29T/2T0OK04mQrDtF+mw9DKf2TfuoVUavXPtwzvXPrx7/crd61e+u7H73Y3dezc/unfzo/tff3z/648f7H3yYO+T7299+vD2Zw9vf/bom88fffP542+/ePztF/t3vty/8+WTu1ef3L369Lv/pV8/3Pvqh3tf/Xh/+uP96U8Prv304NrP31//+fvrvzy88cvDG88e3Xz26Oavj79+vr/3fH/vxZNbL57c+u3p7SF89bJIkEfJ9Fsy5NoIFgnyKBlybWSLdOm9S+nXirMKYZRMvyVDro1gkSCPkiHXglskyKNkyLV0kd48Xvz65OjZZ49u/vr2yzuv/+f5/t6LC0d2Xn+/8zxePnPq3MAXCfLWVTL//fMh6/eMh199t1OuXTiyc+oyubapRSpz7c3j5sAbH2RvPu8cNYdfu1Tm2kJvPrsnd46Ra9iyNebaH/6ebwXefeMl88d/sl8b2iIVuXb+d4dffbe+qfbs1y6fyd6tDp7Zzd+IDh1MD+2culycsL53J3INXWwk167/fP735uhbvzx8728vpUVw4PSVvef7exdfOXh691b2Nn/o5NVyv1arIKeghloyo8y1T149cPy8c7PAybWrpw7my3PuhDly8ent3y4cMYdOXi3W7yn7NQzChnLtg78cPvrWZ389cPi1S88e3fz18dk/mZf/vb/34sIR88o/0pI5caH8HHr11EGTVsfuyZ1j5zwFNdSSGWWuOfu1s++87cm1i8fsv2E+eGbXvnFw7gS5hsHY5H7tX0crdXH6yt6LJ++fPnTkovX2n5bJxWPmxIXyxewpqKGWzDhzzbm/Zo6ebd2v5V/kGgZpk/fXrP1aeX/ty9cPnjiWV4e1X8uO7J7cOXTyoltQQy2ZkeZax9+HFrcDjKm+EVVyzRiztmgj19DFZn4fevx8uhUo7q8Zk34OfXLrxe7JHfs29Jz7a3lBDbVkxptrAf0xDuRRMuRacIsEeZQMuRbcIkEeJUOuBbdIkEfJkGvBLRLkUTLkWnCLBHmUDLkW3CJBHiVDrgW3SJBHyZBrwS0S5FEy5FpwiwR5lAy5FtwiQR4lQ64Ft0iQR8mQa8EtEuRRMuRacIsEeZQMuRbcIkEeJUOuBbdIkEfJkGvBLRLkUTLkWnCLBHmUDLkW3CJBHiVDrgW3SJBHyZBrwS0S5FEy5FpwiwR5lAy5FtwiQR4lQ64Ft0iQR8mQa8EtEuRRMuRacIsEeZQMuRbcIkEeJUOuBbdIkEfJkGvBLRLkUTLkWnCLBHmUDLkW3CJBHiVDrgW3SJBHyZBrwS0S5FEy5FpwiwR5lAy5FtwiQR4lQ64Ft0iQR8mMI9dQINcw17ZfpMMy0FwrFOPbypc9QUP46mtWIYyS6aVkyLURLBLCQcn0UjLk2ggWCeGgZHopmfXm2nbJXAiwGTIlQ64ByMiUDLkGICNTMuQagIxMySjnGoAwkWsA1JBrANSQawDUKOeazIUAmyFTMuQagIxMyZBrADIyJUOuAcjIlAy5BiAjUzLkGoCMTMmQawAyMiWjnGsAwkSuAVBDrgFQQ64BUKOcazIXAmyGTMmQawAyMiVDrq0siaPJtI+GppNJ0kc7HfU27mZruqLpJDLG9Dj6lcfZ11x62ul2qCd6tU+uLWo6iUzcY9lOJ1GcZO02vm6X6dTb4AZSrbiivvU99tXHucbZ9DY9ncRr6U+v9sm1zpLYGGu/UL7w0n2EMXHsvBbdh/IjWTvZj9UHrVbcTqPIGBMntXYahlFvMB908WwTTaYdmsr7LU8qR1KbprLLJM4fnU6iaDJN4iiOo0pP1a4ro/I3m7brTELeUdlF2r/xjdCdGqcdz8npI0lcLlyczL0i79S5Wl5L1TlZ01uGXu2Ta5149ktWRBSlXnvlug+VR2Z51Xteqllv3k6LJ9XaaRlGOXxrzEXDnZqyy7k40lRhRevWVjTtvQzFWkezJDbxZE7RJnG1a2t+8kP2gIsj88bpaafp3CSOoqgMGGdaPOvrTl3zlXlfMJUBrWeHqFf75Fpntbf/epXN3Bed9XP2bdaGvSupZYx/v+bptNaOfxi1BstHigaKzURrU/YT60cc5RWl3+U/O9PhXEU5Kl/b9a6tmcsDoeiiuIaWHU4tdu12Gk6eTuJJkn6Tx1x1Wjzr605d25W5i1idk5aYXoFe7Qvm2prlOwH3PdYpitb9mnXS/PtrzZ26fVl7h3qDbmUlsZsinitaMtdm00mUbXCsSfDt15zL9VSvJ9fc/dpyuTZ3v5ZfShrT6TeeafFc0SK51vJayoa2ifujI0aurayy+8i3PgvcX8t3YemBjm/C7o0YazfXPIz6860n2/fXmptqyTVvxFZasp6a342ycq/semKPKmlOCN8klPfXmnKtbZxOO77ELeKvzEFPZjmT6Z7jy6z6FeUzX12ptf1KRgW5tg71N9PKfm1zr8e29/QF3++7nJ7EbZfmfhbv3HXPM7ZQg7333kvjnWYwTcGl2h89cm0dGj7mNd4w2tgwuj+6ysmeZ1d2onyGWk3HN0dTtf5xDYhyrslcCLAE06D9KRsb3lqRa4CmplxrCTiZkpHKtbkLCaC7bRf08oxYrv329Lb3a7wXBSynS2aplgy5Bmjqsv9SLRlyDdDU5bOkasmQa0C4VEuGXAPCpVoy5BoQLtWSIdeAcKmWDLkGhEu1ZMg1IFyqJUOuAeFSLRlyDQiXasmQa0C4VEuGXAPCpVoy5BoQLtWSIdeAcKmWDLkGhEu1ZMg1IFyqJUOuAeFSLRlyDQiXasmQa0C4VEuGXAPCpVoy5BoQLtWSIdeGba3/NHrZ+HQy6fAPiC/Q4Fxdemxpbkz/ZPyQxypYMrPZjFwbqukkMnEfUdOmKLjpJIqTrNfGGux1SHmPc8eX+IY05KTwmU7igY5XqGQqyLWBSWJjjClK2d5SRcYYY+K4XtRJHEWRMSZO8nNM/UnGRJNJXG80+292UplxdgveITV15462bMc+YvfRfGZxpfUhJdXjlTbb2slHXp5UXou7Er6rS0+O3RnIWyjOmdhj6xbj26BQMj7k2oB4dkRWCRelWN+/JLHJd1tlCZo4qe2KkqZc8+6esrF4h9TUnWe01kiydtK+rB2ie2bDleZtWL0UQ+vUTvFN8Vg+cO9auFeXnWzNQJln1XPqMzrUHebYS6YJuTYw2eYoL4oygpxD1lOKcyy1Yy37NSch/Ps1z5Dq3TU/VA+QvMfWMxP/fs0O6PyJ+T6stZ2WZG9aB9/V+YI1j0Hf2NLj67+tsAyFkvEh14YpiU19b1JmUEOuuY9U2zPljqkh11rvrzUPqcNI6uP37Nf8Z3rur7lhlMTVJPb1OFss11qurpK3zn7NM7Y4Yb+2YeTasFn1kN/mippyzb7hZIpPf+WuId9BFC3YuWb8N5lah1Tvru2h2u2qssfmM90rrY6genVuO86MtX8Sr/fVfHW+yyzvr9Vu/XF/bRvItbbWBjkVQ33rn21uaAv20+X0JF5j8Ax3yci1EehlkUzVWge8lKEWSRJ33/P10NkCk7DlGRvqvbXZjFwbhVUWyTTYzMiBrSDXRmCJRWqKM3INISDXRqC2SHMzCwC5NnTGybW5azZ31bd7RcBakWsjsESu2c8l1xAacm0EVsk1uxFyDYEg10agl1yzWxvvVABdkGsj0G+uAfJUa4RcA8KlWiPkGhAu1Roh14BwqdYIuQaES7VGyDUgXKo1Ip5rLbY9WGD7yLURUF0kYE1US4ZcA8KlWjJqucYHT6A71ZKRyjUAmJFrAPSQawDUKOeazIUAmyFTMuQagIxMyZBrADIyJUOuAcjIlAy5BiAjUzLkGoCMTMmQawAyMiWjnGsAwkSuAVBDrgFQQ64BUKOcazIXAmyGTMmQawAyMiVDrgHIyJQMuQYgI1My5BqAjEzJkGsAMjIlQ64ByMiUjHKuAQgTuQZADbkGQA25BkCNcq7JXAiwGTIlQ64ByMiUDLkGICNTMuQagIxMyZBrADIyJUOuAcjIlAy5BiAjUzLKuQYgTOQaADXkGgA15BoANeQaADXkGgA15BoANeQaADXkGgA15BoANeQaADXkGgA15BoANeQaADXkGgA15BoANeQaADXkGgA15BoANeQaADXkGgA15BoANeQaADX+XAOAUavnGgBoINcAqPk/SfDfMMCR1PQAAAAASUVORK5CYII='/>
    </p>
    <p>
      If a read-out has been queued, the client can cancel the queued read-out request sending a <strong>cancel</strong> command to the device. If a reading has begin and the client
      sends a <strong>cancel</strong> command to the device, the device can choose if the read-out should be cancelled or completed.
    </p>
    <p>
      <strong>Note:</strong> Remember that the <strong>seqnr</strong> value used in this command is unique only to the client making the request. The device can receive requests
      from multiple clients, and must make sure it differs between <strong>seqnr</strong> values from different clients. Different clients are assumed to have different values
      in the corresponding <strong>from</strong> attributes.
    </p>
    <p>
      <img src='data:image/png;base64,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'/>
    </p>
    <section2 topic='Request Read-out of momentary values' anchor='readmomentary'>
      <p>
        The client that wishes to receive momentary values from the sensor initiates the request using the <strong>req</strong> element sent to the device.
      </p>
      <example caption='Read-out request of momentary values from a device'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0001'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='1' momentary='true'/>
   </iq>]]>
      </example>

      <p>
        When the device has received and accepted the request, it responds as follows:
      </p>

      <example caption='Read-out request accepted by device'>
        <![CDATA[
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0001'>
      <accepted xmlns='urn:xmpp:iot:sensordata' seqnr='1'/>
   </iq>]]>
      </example>

      <p>
        When read-out is complete, the response is sent as follows:
      </p>

      <example caption='Momentary read-out response'>
        <![CDATA[
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='1' done='true'>
         <node nodeId='Device01'>
            <timestamp value='2013-03-07T16:24:30'>
               <numeric name='Temperature' momentary='true' automaticReadout='true' value='23.4' unit='°C'/> 
            </timestamp>
         </node>
      </fields>
   </message>]]>
      </example>
    </section2>

    <section2 topic='Read-out failure' anchor='readoutfailure'>
      <p>
        If instead a read-out could not be performed, the communication sequence might look as follows:
      </p>

      <example caption='Momentary read-out failure'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0002'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='2' momentary='true'/>
   </iq>
   
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0002'>
      <accepted xmlns='urn:xmpp:iot:sensordata' seqnr='2'/>
   </iq>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <failure xmlns='urn:xmpp:iot:sensordata' seqnr='2' done='true'>
         <error nodeId='Device01' timestamp='2013-03-07T17:13:30'>Timeout.</error>
      </failure>
   </message>]]>
      </example>
    </section2>
    <section2 topic='Read-out rejected' anchor='readoutrejected'>
      <p>
        If for some reason, the device rejects the read-out request, the communication sequence might look as follows:
      </p>

      <example caption='Momentary read-out rejected'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0003'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='3' momentary='true'/>
   </iq>
   
   <iq type='error'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0003'>
      <error type='cancel'>
         <forbidden xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
         <text xmlns='urn:ietf:params:xml:ns:xmpp-stanzas' xml:lang='en'>Access denied.</text>
      </error>
   </iq>]]>
      </example>
      <p>
        Depending on the reason for rejecting the request, different XMPP errors can be returned, according to the description in the following table. The table also
        lists recommended error type for each error. Any custom error message is returned in a <strong>text</strong> element, as in the example above.
      </p>
      <table caption='XMPP Errors when rejecting a readout request'>
        <tr>
          <th>Error Type</th>
          <th>Error Element</th>
          <th>Namespace</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>cancel</td>
          <td>forbidden</td>
          <td>urn:ietf:params:xml:ns:xmpp-stanzas</td>
          <td>If the caller lacks privileges to perform the action.</td>
        </tr>
        <tr>
          <td>cancel</td>
          <td>item-not-found</td>
          <td>urn:ietf:params:xml:ns:xmpp-stanzas</td>
          <td>If an item or data source could not be found.</td>
        </tr>
        <tr>
          <td>modify</td>
          <td>bad-request</td>
          <td>urn:ietf:params:xml:ns:xmpp-stanzas</td>
          <td>If the request was malformed. Examples can include trying to read a device behind a concentrator, without including node information.</td>
        </tr>
      </table>
    </section2>
    <section2 topic='Read-out all' anchor='readall'>
      <p>
        The following example shows a communication sequence when a client reads out all available information from a sensor at a given point in time:
      </p>

      <example caption='Scheduled read-out of device with multiple responses'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0004'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='4' all='true' when='2013-03-07T19:00:00'/>
   </iq>
   
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0004'>
      <accepted xmlns='urn:xmpp:iot:sensordata' seqnr='4' queued='true'/>
   </iq>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <started xmlns='urn:xmpp:iot:sensordata' seqnr='4'/>
   </message>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='4'>
         <node nodeId='Device01'>
            <timestamp value='2013-03-07T19:00:00'>
               <numeric name='Temperature' momentary='true' automaticReadout='true' value='23.4' unit='°C'/> 
               <numeric name='Runtime' status='true' automaticReadout='true' value='12345' unit='h'/>
               <string name='Device ID' identification='true' automaticReadout='true' value='Device01'/>
            </timestamp>
         </node>
      </fields>
   </message>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='4'>
         <node nodeId='Device01'>
            <timestamp value='2013-03-07T19:00:00'>
               <numeric name='Temperature, Max' peak='true' automaticReadout='true' value='25.9' unit='°C'/> 
               <numeric name='Temperature, Min' peak='true' automaticReadout='true' value='18.7' unit='°C'/> 
               <numeric name='Temperature, Mean' computed='true' automaticReadout='true' value='22.5' unit='°C'/> 
            </timestamp>
         </node>
      </fields>
   </message>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='4'>
         <node nodeId='Device01'>
            <timestamp value='2013-03-07T18:00:00'>
               <numeric name='Temperature' historicalHour='true' automaticReadout='true' value='24.5' unit='°C'/> 
            </timestamp>
            <timestamp value='2013-03-07T17:00:00'>
               <numeric name='Temperature' historicalHour='true' automaticReadout='true' value='25.1' unit='°C'/> 
            </timestamp>
            <timestamp value='2013-03-07T16:00:00'>
               <numeric name='Temperature' historicalHour='true' automaticReadout='true' value='25.2' unit='°C'/> 
            </timestamp>
			...
            <timestamp value='2013-03-07T00:00:00'>
               <numeric name='Temperature' historicalHour='true' historicalDay='true' automaticReadout='true' value='25.2' unit='°C'/> 
            </timestamp>
         </node>
      </fields>
   </message>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <done xmlns='urn:xmpp:iot:sensordata' seqnr='4'/>
   </message>]]>
      </example>
    </section2>
    <section2 topic='Read-out of multiple devices' anchor='readmulti'>
      <p>
        The following example shows how a client reads a subset of multiple sensors behind a device with a single JID.
      </p>

      <example caption='Read-out of multiple devices'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0005'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='5' momentary='true'>
         <node nodeId='Device02'/>
         <node nodeId='Device03'/>
      </req>
   </iq>
   
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0005'>
      <accepted xmlns='urn:xmpp:iot:sensordata' seqnr='5'/>
   </iq>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='5'>
         <node nodeId='Device02'>
            <timestamp value='2013-03-07T19:31:15'>
               <numeric name='Temperature' momentary='true' automaticReadout='true' value='23.4' unit='°C'/> 
            </timestamp>
         </node>
      </fields>
   </message>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='5' done='true'>
         <node nodeId='Device03'>
            <timestamp value='2013-03-07T19:31:16'>
               <numeric name='Temperature' momentary='true' automaticReadout='true' value='22.8' unit='°C'/> 
            </timestamp>
         </node>
      </fields>
   </message>]]>
      </example>
    </section2>
    <section2 topic='Read-out of specific fields' anchor='readfields'>
      <p>
        The <strong>req</strong> element can take <strong>field</strong> sub elements, with which the client can specify which fields it is interested in.
        If not provided, the client is assumed to return all matching fields, regardless of field name. However, the <strong>field</strong> elements in the
        request object can be used as a hint which fields should be returned.
      </p>
      <p>
        <strong>Note:</strong> the device is not required to adhere to the field limits expressed by these <strong>field</strong> elements. They are considered
        a hint the device can use to limit bandwidth.
      </p>
      <p>
        The following example shows how a client can read specific fields in a device.
      </p>

      <example caption='Read-out of multiple devices'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0006'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='6' momentary='true'>
         <node nodeId='Device04'/>
         <field name='Energy'/>
         <field name='Power'/>
      </req>
   </iq>
   
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0006'>
      <accepted xmlns='urn:xmpp:iot:sensordata' seqnr='6'/>
   </iq>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='6' done='true'>
         <node nodeId='Device04'>
            <timestamp value='2013-03-07T22:03:15'>
               <numeric name='Energy' momentary='true' automaticReadout='true' value='12345.67' unit='MWh'/> 
               <numeric name='Power' momentary='true' automaticReadout='true' value='239.4' unit='W'/> 
            </timestamp>
         </node>
      </fields>
   </message>]]>
      </example>
    </section2>
    <section2 topic="Cancelling a scheduled read-out request" anchor="cancelreadout">
      <p>
        The following example shows how the client cancels a scheduled read-out:
      </p>
      <example caption='Scheduled read-out of device with multiple responses'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0007'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='8' all='true' when='2013-03-09T23:30:00'/>
   </iq>
   
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0007'>
      <accepted xmlns='urn:xmpp:iot:sensordata' seqnr='8' queued='true'/>
   </iq>
   
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0008'>
      <cancel xmlns='urn:xmpp:iot:sensordata' seqnr='8'/>
   </iq>
   
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0008'>
      <cancelled xmlns='urn:xmpp:iot:sensordata' seqnr='8'/>
   </iq>]]>
      </example>
    </section2>
  </section1>
  <section1 topic='Determining Support' anchor='support'>
    <p>If an entity supports the protocol specified herein, it MUST advertise that fact by returning a feature of "urn:xmpp:iot:sensordata" in response to &xep0030; information requests.</p>
    <example caption="Service discovery information request">
      <![CDATA[
<iq type='get'
    from='client@example.org/amr'
    to='device@example.org'
    id='disco1'>
  <query xmlns='http://jabber.org/protocol/disco#info'/>
</iq>]]>
    </example>
    <example caption="Service discovery information response">
      <![CDATA[
<iq type='result'
    from='device@example.org'
    to='client@example.org/amr'
    id='disco1'>
  <query xmlns='http://jabber.org/protocol/disco#info'>
    ...
    <feature var='urn:xmpp:iot:sensordata'/>
    ...
  </query>
</iq>]]>
    </example>
    <p>
      In order for an application to determine whether an entity supports this protocol, where possible it SHOULD use the dynamic, presence-based profile of service discovery defined
      in &xep0115;. However, if an application has not received entity capabilities information from an entity, it SHOULD use explicit service discovery instead.
    </p>
  </section1>
  <section1 topic='Implementation Notes' anchor='impl'>
    <section2 topic='String lengths' anchor='stringlengths'>
      <p>
        As noticed, a conscious effort has been made not to shorten element and attribute names. This is to make sure, XML is maintained readable. Packet size is not deemed to be
        affected negatively by this for two reasons:
      </p>
      <ul>
        <li>
          For sensors with limited memory, or where package size is important, &xep0322; is supposed to be used.
          EXI compresses strings as normalized index values, making the string appear only once in the packet. Therefore, shortening string length doesn't affect packet
          size much. Element and attribute names in known namespaces are furthermore only encoded by index in schema, not by name.
        </li>
        <li>If limited memory or package size is not a consideration, readability and ease of implementation is preferred to short messages.</li>
      </ul>
    </section2>
    <section2 topic='Enumerations vs. Strings' anchor='enumsvsstrings'>
      <p>
        This protocol has avoided the use of enumerations for data types such as units, field names, etc., and instead use strings. The reasons for this are:
      </p>
      <ul>
        <li>Enumerations would unnecessarily restrict the use of the protocol to field names and units listed in the protocol.</li>
        <li>It would be very difficult to try to create a complete set of field names and units that would suit all applications.</li>
        <li>Leaving these values as strings would let developers the liberty to use units as they desire.</li>
        <li>If EXI is used for compression, the use of strings will only increase payload slightly, with only one copy of each distinct value used.</li>
        <li>If EXI is not used, this does not affect packet size.</li>
      </ul>
      <p>
        However, some things need to be taken into account:
      </p>
      <ul>
        <li>Since free strings are used, XML validation cannot be used to secure correct names are used.</li>
        <li>xep-0000-IoT-Interoperability lists recommendations on how field names and units should be used in order to achieve maximum interoperability in SN.</li>
        <li>Consumers of sensor data need to include unit conversion algorithms.</li>
      </ul>
    </section2>
    <section2 topic='Asynchronous feedback' anchor='asynchfeedback'>
      <p>
        Since some applications require real-time feedback (or as real-time as possible), and read-out might in certain cases take a long time, the device has the option
        to send multiple <strong>fields</strong> messages during read-out. The client is responsible for collecting all such messages until either a <strong>done</strong> message
        is sent, or a corresponding <strong>done</strong> attribute is available in one of the messages received. Only the device knows how many (if any) messages are sent in
        response to a read-out request.
      </p>
    </section2>
    <section2 topic='Field Value Data Types' anchor='fieldvaluetypes'>
      <p>
        There are different types of values that can be reported from a device. The following table lists the various types:
      </p>
      <table caption='Field Value Data Types'>
        <tr>
          <th>Element</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>boolean</td>
          <td>Represents a boolean value that can be either true or false.</td>
        </tr>
        <tr>
          <td>date</td>
          <td>
            Represents a date value. The value must be encoded using the xs:date data type.
          </td>
        </tr>
        <tr>
          <td>dateTime</td>
          <td>
            Represents a date and optional time value. The value must be encoded using the xs:dateTime data type. This includes date, an optional time and optional time zone information.
            If time zone is not available, it is supposed to be undefined.
          </td>
        </tr>
        <tr>
          <td>duration</td>
          <td>Represents a duration value. The value must be encoded using the xs:duration data type.</td>
        </tr>
        <tr>
          <td>enum</td>
          <td>
            Represents an enumeration value. What differs this value from a string value, is that it apart from the enumeration value (which is a string value),
            also contains a data type, which consumers can use to interpret its value. This specification does not assume knowledge of any particular enumeration
            data types.
          </td>
        </tr>
        <tr>
          <td>int</td>
          <td>
            Represents a 32-bit integer value. It contains an arbitrary 32-bit integer value. This field value data type can be seen as a subtype of the more generic numeric
            field value data type. It has its own element, to make it harmonous to 32-bit integer control parameters, as defined in XEP-0325. It is also simpler to report and
            compress, since it does not use floating point precision and a unit.
          </td>
        </tr>
        <tr>
          <td>long</td>
          <td>
            Represents a 64-bit integer value. It contains an arbitrary 64-bit integer value. This field value data type can be seen as a subtype of the more generic numeric
            field value data type. It has its own element, to make it harmonous to 64-bit integer control parameters, as defined in XEP-0325. It is also simpler to report and
            compress, since it does not use floating point precision and a unit.
          </td>
        </tr>
        <tr>
          <td>numeric</td>
          <td>
            Represents a numerical value. Numerical values contain, apart from a numerical number, also an implicit precision (number of decimals) and an
            optional unit. All parties in the communication chain should retain the number of decimals used, since this contains information that is important
            in the interpretation of a value. For example, 10 °C is different from 10.0 °C, and very different from 10.00 °C. If a sensor delivers the value
            10 °C you can assume it probably lies between 9.5 °C and 10.5 °C. But if a sensor delivers 10.00 °C, it is probably very exact (if calibrated correctly).
          </td>
        </tr>
        <tr>
          <td>string</td>
          <td>Represents a string value. It contains an arbitrary string value.</td>
        </tr>
        <tr>
          <td>time</td>
          <td>Represents a time value. The value must be encoded using the xs:time data type.</td>
        </tr>
      </table>
    </section2>
    <section2 topic='Harmonization with XEP-0325 (Control)' anchor='harmonization'>
      <p>
        When representing control parameters as momentary field values, it is important to note the similarities and differences between XEP-0323 (this document) and XEP-0325 (Control):
      </p>
      <p>
        The <strong>enum</strong> field value data type is not available in XEP-0325 (Control). Instead enumeration valued parameters are represented as <strong>string</strong> control
        parameters, while the control form explicitly lists available options for the parameter. Options are not available in XEP-0323, since it would not be practical to list all options
        every time the corresponding parameter was read out. Instead, the <strong>enum</strong> element contains a data type attribute, that can be used to identify the type of the enumeration.
      </p>
      <p>
        The <strong>numeric</strong> field value data type is not available in XEP-0325 (Control). The reason is that a controller is not assumed to understand unit conversion. Any
        floating-point valued control parameters are represented by <strong>double</strong> control parameters, which lack a unit attribute. They are assumed to have the same unit as
        the corresponding <strong>numeric</strong> field value. On the other hand, floating point valued control parameters without units, are reported using the <strong>numeric</strong>
        field element, but leaving the unit blank.
      </p>
      <p>
        Control pameters of type <strong>color</strong> have no corresponding field value data type. The color value must be represented in another way, and is implementation specific.
        Possibilities include representing the color as a string, using a specific pattern (for instance RRGGBBAA), or report it using multiple fields, one for each component for instance.
      </p>
      <p>
        The <strong>boolean</strong>, <strong>date</strong>, <strong>dateTime</strong>, <strong>duration</strong>, <strong>int</strong>, <strong>long</strong>, <strong>string</strong>
        and <strong>time</strong> field value data types correspond to control parameters having the same types and same element names.
      </p>
    </section2>
    <section2 topic='Field Types' anchor='fieldtypes'>
      <p>
        There are different types of fields, apart from types of values a field can have. These types are conceptual types, similar to categories. They are not exclusive,
        and can be combined.
      </p>
      <p>
        If requesting multiple field types in a request, the device must interpret this as a union of the corresponding field types and return at least all field values
        that contain at least one of the requested field types. Example: If requesting momentary values and historical values, devices must return both its momentary values
        and its historical values.
      </p>
      <p>
        But, when a device reports a field having multiple field types, the client should interpret this as the intersection of the corresponding field types, i.e. the corresponding
        field has all corresponding field types. Example: A field marked as both a status value and as a historical value is in fact a historical status value.
      </p>
      <p>
        The following table lists the different field types specified in this document:
      </p>
      <table caption='Field Types'>
        <tr>
          <th>Field Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>computed</td>
          <td>A value that is computed instead of measured.</td>
        </tr>
        <tr>
          <td>historical*</td>
          <td>A value stored in memory from a previous timestamp. The suffix is used to determine period, as shown below.</td>
        </tr>
        <tr>
          <td>historicalSecond</td>
          <td>A value stored at a second shift (milliseconds = 0).</td>
        </tr>
        <tr>
          <td>historicalMinute</td>
          <td>A value stored at a minute shift (seconds=milliseconds=0). Are also second values.</td>
        </tr>
        <tr>
          <td>historicalHour</td>
          <td>A value stored at a hour shift (minutes=seconds=milliseconds=0). Are also minute and second values.</td>
        </tr>
        <tr>
          <td>historicalDay</td>
          <td>A value stored at a day shift (hours=minutes=seconds=milliseconds=0). Are also hour, minute and second values.</td>
        </tr>
        <tr>
          <td>historicalWeek</td>
          <td>A value stored at a week shift (Monday, hours=minutes=seconds=milliseconds=0). Are also day, hour, minute and second values.</td>
        </tr>
        <tr>
          <td>historicalMonth</td>
          <td>A value stored at a month shift (day=1, hours=minutes=seconds=milliseconds=0). Are also day, hour, minute and second values.</td>
        </tr>
        <tr>
          <td>historicalQuarter</td>
          <td>A value stored at a quarter year shift (Month=Jan, Apr, Jul, Oct, day=1, hours=minutes=seconds=milliseconds=0). Are also month, day, hour, minute and second values.</td>
        </tr>
        <tr>
          <td>historicalYear</td>
          <td>A value stored at a year shift (Month=Jan, day=1, hours=minutes=seconds=milliseconds=0). Are also quarter, month, day, hour, minute and second values.</td>
        </tr>
        <tr>
          <td>historicalOther</td>
          <td>If period if historical value is not important in the request or by the device.</td>
        </tr>
        <tr>
          <td>identity</td>
          <td>A value that can be used for identification. (Serial numbers, meter IDs, locations, names, addresses, etc.)</td>
        </tr>
        <tr>
          <td>momentary</td>
          <td>A momentary value represents a value measured at the time of the read-out. Examples: Energy, Volume, Power, Flow, Temperature, Pressure, etc.</td>
        </tr>
        <tr>
          <td>peak</td>
          <td>A maximum or minimum value during a given period. Examples "Temperature, Max", "Temperature, Min", etc.</td>
        </tr>
        <tr>
          <td>status</td>
          <td>A value displaying status information about something. Examples: Health, Battery life time, Runtime, Expected life time, Signal strength, Signal quality, etc. </td>
        </tr>
      </table>
      <p>
        There are two field type attributes that can be used in requests to simplify read-out:
      </p>
      <table caption='Special Field Types available in read-out requests'>
        <tr>
          <th>Field Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>all</td>
          <td>Reads all types of fields. It is the same as explicitly setting all field type attributes to true.</td>
        </tr>
        <tr>
          <td>historical</td>
          <td>If period of historical values is not important, this attribute can be set to include all types of historical values.</td>
        </tr>
      </table>
      <p>
        <strong>Note:</strong> The reason for including different predefined time periods for historical values is that these periods are common in certain
        applications. However, the client is not restricted to these in any way. The client can always just ask for historical values, and do
        filtering as necessary to read out the interval desired.
      </p>
      <p>
        Also, devices are not required to include logic to parse and figure out what historical values are actually desired by the client. If too
        complicated for the device to handle, it is free to report all historical values. However, the device should limit the historical values
        to any interval requested, and should try to limit itself to the field types requested. Information in the request element are seen as hints
        that the device can use to optimize any communication required by the operation.
      </p>
    </section2>
    <section2 topic='Field Quality of Service Values' anchor='fieldqosvalues'>
      <p>
        In applications where quality of service is important, a field must always be accompanied with a corresponding quality of service flag. Devices should
        set these accordingly. If no quality of service flag is set on a field, the client can assume <strong>automaticReadout</strong> is true.
      </p>
      <p>
        Note that quality of service flags are not exclusive. Many of them can be logically be combined. Some also imply an order of importance. This should be kept in mind
        when trying to overwrite existing values with read values: An estimate should not overwrite an automatic read-out, an automatic read-out not a signed value, and a signed value
        not an invoiced value, etc.
      </p>
      <p>
        Available quality of service flags, in order of importance:
      </p>
      <table topic='Quality of Service Flags'>
        <tr>
          <th>QoS Flag</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>missing</td>
          <td>Value is missing</td>
        </tr>
        <tr>
          <td>inProgress</td>
          <td>Value is in progress to be measured or calculated. The value is to be considered as unsure and not final. Read again later to retrieve the correct value. It is more reliable than a missing value, but less reliable than an estimate.</td>
        </tr>
        <tr>
          <td>automaticEstimate</td>
          <td>An estimate of the value has been done automatically. Considered more reliable than a value in progress.</td>
        </tr>
        <tr>
          <td>manualEstimate</td>
          <td>The value has manually been estimated. Considered more reliable than an automatic estimate.</td>
        </tr>
        <tr>
          <td>manualReadout</td>
          <td>Value has been manually read. Considered more reliable than a manual estimate.</td>
        </tr>
        <tr>
          <td>automaticReadout</td>
          <td>Value has been automatically read. Considered more reliable than a manually read value.</td>
        </tr>
        <tr>
          <td>timeOffset</td>
          <td>The time was offset more than allowed and corrected during the measurement period.</td>
        </tr>
        <tr>
          <td>warning</td>
          <td>A warning was logged during the measurement period.</td>
        </tr>
        <tr>
          <td>error</td>
          <td>An error was logged during the measurement period.</td>
        </tr>
        <tr>
          <td>signed</td>
          <td>
            The value has been signed by an operator. Considered more reliable than an automatically read value. Note that the signed quality of service flag can be used to overwrite
            existing values of higher importance. Example signed + invoiced can be considered more reliable than only invoiced, etc.
          </td>
        </tr>
        <tr>
          <td>invoiced</td>
          <td>The value has been invoiced by an operator. Considered more reliable than a signed value.</td>
        </tr>
        <tr>
          <td>endOfSeries</td>
          <td>The value has been marked as an end point in a series. This can be used for instance to mark the change of tenant in an apartment.</td>
        </tr>
        <tr>
          <td>powerFailure</td>
          <td>The device recorded a power failure during the measurement period.</td>
        </tr>
        <tr>
          <td>invoiceConfirmed</td>
          <td>The value has been invoiced by an operator and confirmed by the recipient. Considered more reliable than an invoiced value.</td>
        </tr>
      </table>
      <section3 topic='Estimates vs. Readouts' anchor='estimatesvsreadouts'>
        <p>
          A note on the difference between estimates and readouts. There are many cases where a proper value in a sensor or meter cannot be sensed correctly, and
          only estimated. As an example: Consider a water meter calculating the flow of water passing vane generating pulses as the wheel turns. The frequency of pulses
          correspond to the flow of water, or inversely, the time between pulses correspond inversely to the flow of water. But what happens when the flow slows down
          and pulses are not received? How can the meter differ between zero flow, and a little flow until a pulse is received?
        </p>
        <p>
          What a meter can do is estimate a flow value that would correspond to the inverse of the time passed since last received pulse. This estimate would slowly
          decrease to zero if no flow is available, but would be correct if a pulse finally would be received, thus causing a smoother measurement of the flow.
          However, the value reported would not be an actual measurement or readout, but an estimate of the value.
        </p>
        <p>
          It's important that such estimates are flagged as such, so that readers know the value is not a measurement but an estimate. Consider an application that monitors
          water meters to detect leakage. If a water meter always measures flow, and never decreases to zero flow, it might be logically assumed there's a leakage or
          bad valves somewhere. However, if meters as described above are used, flow might perhaps never reach zero, simply because it reports a value that's inversely
          proportional to the time passed since last pulse. It might be close to zero over long periods of time, but never reach zero. To avoid the application generating
          leakage alarms in case such meters were used, the application can be made to ignore estimates and only monitor values that have been correctly measured.
        </p>
      </section3>
    </section2>
    <section2 topic='Subnodes and supernodes' anchor='subsupernodes'>
      <p>
        This document does not go into detail on how devices are ordered behind a JID. Some of the examples have assumed a single device lies behind a JID, others
        that multiple devices exist behind a JID. Also, no order or structure of devices has been assumed.
      </p>
      <p>
        But it can be mentioned that it is assumed that if a client requests a read-out of a supernode, it implies the read-out of all its subnodes. Therefore, the
        client cannot expect read-out to be limited to the devices listed explicitly in a request, as nodes implicitly implied, as descendant nodes of the selected nodes,
        can also be included.
      </p>
      <p>
        More information about how multiple devices behind a JID can be handled, is described in the XEP-0326
        <link url='http://xmpp.org/extensions/xep-0326.html'>Internet of Things - Concentrators</link>.
      </p>
    </section2>
    <section2 topic='Reading devices from large subsystems' anchor='largesubsystems'>
      <p>
        All examples in this document have been simplified examples where a few devices containing a few fields have been read. However, in many cases large subsystems with
        very many sensors containing many fields have to be read, as is documented in <link url='http://xmpp.org/extensions/xep-0326.html'>Internet of Things - Concentrators</link>.
        In such cases, a node may have to be specified using two or perhaps even three ID's: a <strong>sourceId</strong> identifying the data source controlling the device, a possible
        <strong>cacheType</strong> narrowing down the search to a specific kind of node, and the common <strong>nodeId</strong>. For more information about this, see
        <link url='http://xmpp.org/extensions/xep-0326.html'>Internet of Things - Concentrators</link>.
      </p>
      <p>
        <strong>Note:</strong> For cases where the <strong>nodeId</strong> is sufficient to uniquely identify the node, it is sufficient to provide this attribute in the request.
        If there is ambiguity in the request, the receptor must treat the request as a request with a set of nodes, all with the corresponding <strong>nodeId</strong> as requested.
      </p>
    </section2>
    <section2 topic='Reading controllable parameter values' anchor='control'>
      <p>
        If reading field values from a device that also supports control through &xep0325;, the device can report current control parameter values as momentary or status field values,
        using field names corresponding to its control parameter names. However, such values would probably only correspond to a subset of all data read out. To help the reader
        to know what fields correspond to controllable parameters, the optional <strong>writable</strong> attribute can be used in responsens. If this attribute is available, it
        tells the client if the field corresponds to a control parameter with the same name on the device. If the attribute is not available, no deduction can be made if a control
        parameter with the same name exists or not on the device.
      </p>
    </section2>
  </section1>
  <section1 topic='Internationalization Considerations' anchor='i18n'>
    <section2 topic='Time Zones' anchor='timezones'>
      <p>
        All timestamps and dateTime values use the XML data type xs:dateTime to specify values. These values include a date, an optional time and an optional time zone.
      </p>
      <p>
        <strong>Note:</strong> If time zone is not available, it is supposed to be undefined. The client reading the sensor that reports fields without time zone information
        should assume the sensor has the same time zone as the client, if not explicitly configured otherwise on the client side.
      </p>
      <p>
        If devices report time zone, this information should be propagated throughout the system. Otherwise, comparing timestamps from different time zones will be impossible.
      </p>
    </section2>
    <section2 topic='Localized strings' anchor='localization'>
      <p>
        This specification allows for localization of field names in meter data read-out. This is performed by assigning each localizable string a <strong>String ID</strong>
        which should be unique within a given <strong>Language Module</strong>. A <strong>Language Module</strong> can be any string, including URI's or namespace names.
        The XEP <link url='xep-0000-IoT-Interoperability.html'>xep-0000-IoT-Interoperability</link> details how such localizations can be made in an interoperable way.
      </p>
      <p>
        <strong>Note:</strong> Localization of strings are for human consumption only. Machines should use the unlocalized strings in program logic.
      </p>
      <p>
        The following example shows how a device can report localized field information that can be presented to end users without systems being preprogrammed
        to recognize the device. Language modules can be aggregated by operators after installation, or installed as a pluggable module after the main installation,
        if localization is desired.
      </p>
      <example caption='Localized field names'>
        <![CDATA[
   <iq type='get'
       from='client@example.org/amr'
       to='device@example.org'
       id='S0009'>
      <req xmlns='urn:xmpp:iot:sensordata' seqnr='7' all='true'/>
   </iq>
   
   <iq type='result'
       from='device@example.org'
       to='client@example.org/amr'
       id='S0009'>
      <accepted xmlns='urn:xmpp:iot:sensordata' seqnr='7'/>
   </iq>
   
   <message from='device@example.org'
            to='client@example.org/amr'>
      <fields xmlns='urn:xmpp:iot:sensordata' seqnr='7' done='true'>
         <node nodeId='Device05'>
            <timestamp value='2013-03-07T22:20:45'>
               <numeric name='Temperature' momentary='true' automaticReadout='true' 
                        value='23.4' unit='°C' module='Whatchamacallit' stringIds='1'/> 
               <numeric name='Temperature, Min' momentary='true' automaticReadout='true' 
                        value='23.4' unit='°C' module='Whatchamacallit' stringIds='1,2'/> 
               <numeric name='Temperature, Max' momentary='true' automaticReadout='true' 
                        value='23.4' unit='°C' module='Whatchamacallit' stringIds='1,3'/> 
               <numeric name='Temperature, Mean' momentary='true' automaticReadout='true' 
                        value='23.4' unit='°C' module='Whatchamacallit' stringIds='1,4'/> 
            </timestamp>
         </node>
      </fields>
   </message>]]>
      </example>
      <p>
        The above example defines a language module called <strong>Watchamacallit</strong>. In this language module it defines four strings, with IDs 1-4. A system might store these as follows,
        where the system replaces all <strong>%N%</strong> with a conceptual n:th parameter. (It's up to the system to define these strings, any syntax and how to handle input and output.). In
        this example, we will assume <strong>%0%</strong> means any previous output, and <strong>%1%</strong> any seed value provided. (See below).
      </p>
      <table caption='Example string IDs'>
        <tr>
          <th>ID</th>
          <th>String</th>
        </tr>
        <tr>
          <td>1</td>
          <td>Temperature</td>
        </tr>
        <tr>
          <td>2</td>
          <td>%0%, Min</td>
        </tr>
        <tr>
          <td>3</td>
          <td>%0%, Max</td>
        </tr>
        <tr>
          <td>4</td>
          <td>%0%, Mean</td>
        </tr>
      </table>
      <p>
        So, when the client reads the field name <strong>Temperature, Min</strong>, it knows that the field name is the composition of the string <strong>Temperature</strong>, and
        the string <strong>%0%, Min</strong>, where it will replace <strong>%0%</strong> with the output of the previous step, in this case <strong>Temperature</strong>.
        These strings can later be localized to different languages by operators of the system, and values presented when reading the device, can be done in a language
        different from the one used by the sensor.
      </p>
      <p>
        <strong>Note:</strong> The XEP <link url='xep-0000-IoT-Interoperability.html'>xep-0000-IoT-Interoperability</link> details how such localizations can be made in an interoperable way.
      </p>
      <p>
        The <strong>stringIds</strong> attribute merits some further explanation. The value of this attribute must match the following regular expression:
      </p>
      <code>
        ^\d+([|]\w+([.]\w+)*([|][^,]*)?)?(,\d+([|]\w+([.]\w+)*([|][^,]*)?)?)*$
      </code>
      <p>
        This basically means, it's of the format: ID_1[|[Module_1][|Seed_1]][...[,ID_n[|[Module_n][|Seed_n]]]]
      </p>
      <p>
        Where brackets [] mean the contents inside is optional, <strong>ID_i</strong> is an integer representing the string ID in a language module. <strong>Module_i</strong>
        is optional and allows for specifying a module for <strong>ID_i</strong>, if different from the module defined in the <strong>module</strong> attribute. <strong>Seed_i</strong>
        allows for seeding the generation of the localized string with a value. This might come in handy when generating strings like <strong>Input 5</strong>, where you don't want to
        create localized strings for every input there is.
      </p>
      <p>
        Why such a complicated syntax? The reason is the following: Most localized strings are simple numbers, without the need of specifying modules and seeds. This makes
        it very efficient to store it as an attribute instead of having to create subelements for every localized field. It's an exception to the rule, to need multiple steps
        or seeds in the generation of localized strings. Therefore, attributes is an efficient means to specify localization. However, in the general case, a single string ID
        is not sufficient and multiple steps are required, some seeded.
      </p>
      <table caption='stringIds Examples'>
        <tr>
          <th>stringIds</th>
          <th>New Parts</th>
          <th>Result</th>
        </tr>
        <tr>
          <td>1</td>
          <td>1="Temperature"</td>
          <td>Temperature</td>
        </tr>
        <tr>
          <td>1,2</td>
          <td>2="%0%, Max"</td>
          <td>Temperature, Max</td>
        </tr>
        <tr>
          <td>1,1|MathModule</td>
          <td>1 in module "MathModule"="sum(%0%)"</td>
          <td>sum(Temperature)</td>
        </tr>
        <tr>
          <td>3||A1</td>
          <td>3="Input %1%"</td>
          <td>Input A1</td>
        </tr>
        <tr>
          <td>4||A1,2</td>
          <td>4="Entrance %1%"</td>
          <td>Entrance A1, Max</td>
        </tr>
        <tr>
          <td>4||A1,5||3</td>
          <td>5="%0%, Floor %1%"</td>
          <td>Entrance A1, Floor 3</td>
        </tr>
      </table>
    </section2>
  </section1>
  <section1 topic='Security Considerations' anchor='security'>
    <p>
      This document has not touched upon security in sensor networks. There are mainly three concerns that implementers of sensor networks need to consider:
    </p>
    <ul>
      <li>
        Communication should be restricted to friends as long as possible. Approved friendships provide a mechanism of limiting sensor information to authorized and authenticated users.
        However, there are cases where multicast messages may want to go outside of recognized friendships. More information about such use cases, see the
        XEP <link url='xep-0000-IoT-Multicast.html'>xep-0000-IoT-Multicast</link>.
      </li>
      <li>
        Sensors may have very limited user interfaces. Even though installation of sensor networks is beyond the scope of this document, a simple installation scheme may include a
        single LED on the sensor that lights up for a time after receiving a friendship request. If a user presses a button on the device while the LED is lit, the friendship request
        is acknowledged, and communication is authorized.
      </li>
      <li>
        More advanced access rights, privileges, automatic friendship recognition, etc., may be managed by a third party. How to implement more advanced provisioning and detailed
        access rights to sensor information is detailed in the XEP-0324 <link url='http://xmpp.org/extensions/xep-0324.html'>Internet of Things - Provisioning</link>. In short, a device, service or user can get a
        <strong>deviceToken</strong>, <strong>serviceToken</strong> and <strong>userToken</strong> respectivelly from a provisioning server. The service or device then uses these tokens
        in all readout requests and the device being read out can in turn use these tokens to validate access rights with the provisioning server.
      </li>
    </ul>
  </section1>
  <section1 topic='IANA Considerations' anchor='iana'>
    <p>This document requires no interaction with &IANA;.</p>
  </section1>
  <section1 topic='XMPP Registrar Considerations' anchor='registrar'>
    <p>
      The <link url="#schema">protocol schema</link> needs to be added to the list of <link url="http://xmpp.org/resources/schemas/">XMPP protocol schemas</link>.
    </p>
  </section1>
  <section1 topic='XML Schema' anchor='schema'>
    <code>
      <![CDATA[
<?xml version='1.0' encoding='UTF-8'?>
<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:iot:sensordata'
    xmlns='urn:xmpp:iot:sensordata'
    elementFormDefault='qualified'>
 
    <xs:element name='req'>
        <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
                <xs:element name='node'>
                    <xs:complexType>
                        <xs:attribute name='nodeId' type='xs:string' use='required'/>
                        <xs:attribute name='sourceId' type='xs:string' use='optional'/>
                        <xs:attribute name='cacheType' type='xs:string' use='optional'/>
                    </xs:complexType>
                </xs:element>
                <xs:element name='field'>
                    <xs:complexType>
                        <xs:attribute name='name' type='xs:string' use='required'/>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
            <xs:attributeGroup ref='fieldTypes'/>
            <xs:attribute name='all' type='xs:boolean' use='optional' default='false'/>
            <xs:attribute name='historical' type='xs:boolean' use='optional' default='false'/>
            <xs:attribute name='from' type='xs:dateTime' use='optional'/>
            <xs:attribute name='to' type='xs:dateTime' use='optional'/>
            <xs:attribute name='when' type='xs:dateTime' use='optional'/>
            <xs:attribute name='serviceToken' type='xs:string' use='optional'/>
            <xs:attribute name='deviceToken' type='xs:string' use='optional'/>
            <xs:attribute name='userToken' type='xs:string' use='optional'/>
        </xs:complexType>
    </xs:element>
 
    <xs:attributeGroup name='fieldTypes'>
        <xs:attribute name='momentary' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='peak' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='status' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='computed' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='identity' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalSecond' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalMinute' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalHour' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalDay' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalWeek' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalMonth' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalQuarter' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalYear' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='historicalOther' type='xs:boolean' use='optional' default='false'/>
    </xs:attributeGroup>
 
    <xs:element name='accepted'>
        <xs:complexType>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
            <xs:attribute name='queued' type='xs:boolean' use='optional' default='false'/>
        </xs:complexType>
    </xs:element>
 
    <xs:element name='started'>
        <xs:complexType>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
        </xs:complexType>
    </xs:element>
 
    <xs:element name='cancel'>
        <xs:complexType>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
        </xs:complexType>
    </xs:element>
 
    <xs:element name='cancelled'>
        <xs:complexType>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
        </xs:complexType>
    </xs:element>
 
    <xs:element name='fields'>
        <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                <xs:element name='node'>
                    <xs:complexType>
                        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                            <xs:element name='timestamp'>
                                <xs:complexType>
                                    <xs:choice minOccurs='0' maxOccurs='unbounded'>
                                        <xs:element name='boolean' type='boolean'/>
                                        <xs:element name='date' type='date'/>
                                        <xs:element name='dateTime' type='dateTime'/>
                                        <xs:element name='duration' type='duration'/>
                                        <xs:element name='enum' type='enum'/>
                                        <xs:element name='int' type='int'/>
                                        <xs:element name='long' type='long'/>
                                        <xs:element name='numeric' type='numeric'/>
                                        <xs:element name='string' type='string'/>
                                        <xs:element name='time' type='time'/>
                                    </xs:choice>
                                    <xs:attribute name='value' type='xs:dateTime' use='required'/>
                                </xs:complexType>
                            </xs:element>
                        </xs:sequence>
                        <xs:attribute name='nodeId' type='xs:string' use='required'/>
                        <xs:attribute name='sourceId' type='xs:string' use='optional'/>
                        <xs:attribute name='cacheType' type='xs:string' use='optional'/>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
            <xs:attribute name='done' type='xs:boolean' use='optional' default='false'/>
        </xs:complexType>
    </xs:element>
 
    <xs:element name='failure'>
        <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                <xs:element name='error'>
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base='xs:string'>
                                <xs:attribute name='nodeId' type='xs:string' use='required'/>
                                <xs:attribute name='sourceId' type='xs:string' use='optional'/>
                                <xs:attribute name='cacheType' type='xs:string' use='optional'/>
                                <xs:attribute name='timestamp' type='xs:string' use='required'/>
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
            <xs:attribute name='done' type='xs:boolean' use='optional' default='false'/>
        </xs:complexType>
    </xs:element>
 
    <xs:element name='done'>
        <xs:complexType>
            <xs:attribute name='seqnr' type='xs:int' use='required'/>
        </xs:complexType>
    </xs:element>
 
    <xs:complexType name='field' abstract='true'>
        <xs:attribute name="name" type="xs:string" use="required"/>
        <xs:attributeGroup ref='fieldTypes'/>
        <xs:attributeGroup ref='fieldQoS'/>
        <xs:attribute name="module" type="xs:string" use="optional"/>
        <xs:attribute name="stringIds" type="StringIds" use="optional"/>
        <xs:attribute name="writable" type="xs:boolean" use="optional"/>
    </xs:complexType>
 
    <xs:simpleType name="StringIds">
        <xs:restriction base="xs:string">
            <xs:pattern value="^\d+([|]\w+([.]\w+)*([|][^,]*)?)?(,\d+([|]\w+([.]\w+)*([|][^,]*)?)?)*$"/>
        </xs:restriction>
    </xs:simpleType>
 
    <xs:attributeGroup name='fieldQoS'>
        <xs:attribute name='missing' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='inProgress' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='automaticEstimate' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='manualEstimate' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='manualReadout' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='automaticReadout' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='timeOffset' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='warning' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='error' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='signed' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='invoiced' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='endOfSeries' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='powerFailure' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='invoiceConfirmed' type='xs:boolean' use='optional' default='false'/>
    </xs:attributeGroup>
 
    <xs:complexType name='numeric'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:double" use="required"/>
                <xs:attribute name="unit" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='string'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='boolean'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:boolean" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='date'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:date" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='dateTime'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:dateTime" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='duration'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:duration" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='enum'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:string" use="required"/>
                <xs:attribute name="dataType" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='int'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:int" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='long'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:long" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='time'>
        <xs:complexContent>
            <xs:extension base='field'>
                <xs:attribute name="value" type="xs:time" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
</xs:schema>]]>
    </code>
  </section1>
  <section1 topic='For more information' anchor='moreinfo'>
    <p>
      For more information, please see the following resources:
    </p>
    <ul>
      <li>
        <p>
          The <link url='http://wiki.xmpp.org/web/Tech_pages/SensorNetworks'>Sensor Network section of the XMPP Wiki</link> contains further information about the
          use of the sensor network XEPs, links to implementations, discussions, etc.
        </p>
      </li>
      <li>
        <p>
          The XEP's and related projects are also available on <link url='https://github.com/joachimlindborg/'>github</link>, thanks to Joachim Lindborg.
        </p>
      </li>
      <li>
        <p>
          A presentation giving an overview of all extensions related to Internet of Things can be found here:
          <link url='http://prezi.com/esosntqhewhs/iot-xmpp/'>http://prezi.com/esosntqhewhs/iot-xmpp/</link>.
        </p>
      </li>
    </ul>
  </section1>
  <section1 topic='Acknowledgements' anchor='ack'>
    <p>Thanks to Flemon Ghobrial, Joachim Lindborg, Karin Forsell, Tina Beckman, Kevin Smith and Tobias Markmann for all valuable feedback.</p>
  </section1>
</xep>
