<?xml version='1.0' encoding='UTF-8'?>
<!-- TODO: Sub-namespace for Registration Clients.
        urn:xmpp:iot:discovery:regunit	- Registration Units (can claim ownership)
-->
<!-- TODO: TBD items -->
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
	<header>
		<title>Internet of Things - Discovery</title>
		<abstract>This specification describes an architecture based on the XMPP protocol whereby Things can be installed and safely discovered by their owners and connected into networks of Things.</abstract>
		&LEGALNOTICE;
		<number>0347</number>
		<status>Experimental</status>
		<type>Standards Track</type>
		<sig>Standards</sig>
		<approver>Council</approver>
		<dependencies>
			<spec>XMPP Core</spec>
			<spec>XEP-0001</spec>
			<spec>XEP-0030</spec>
			<spec>XEP-0077</spec>
			<spec>XEP-0114</spec>
			<spec>XEP-0174</spec>
			<spec>XEP-0323</spec>
			<spec>XEP-0324</spec>
			<spec>XEP-0325</spec>
			<spec>XEP-0326</spec>
		</dependencies>
		<supersedes/>
		<supersededby/>
		<shortname>iot-discovery</shortname>
		<author>
			<firstname>Peter</firstname>
			<surname>Waher</surname>
			<email>peterwaher@hotmail.com</email>
			<jid>peter.waher@jabber.org</jid>
			<uri>http://www.linkedin.com/in/peterwaher</uri>
		</author>
		<author>
			<firstname>Ronny</firstname>
			<surname>Klauck</surname>
			<email>rklauck@informatik.tu-cottbus.de</email>
			<jid>TBD</jid>
			<uri>http://www-rnks.informatik.tu-cottbus.de/~rklauck</uri>
		</author>
		<revision>
			<version>0.4</version>
			<date>2015-11-09</date>
			<initials>pw</initials>
			<remark>
				<p>Updated contact information.</p>
				<p>Updated example JIDs to example.org</p>
			</remark>
		</revision>
		<revision>
			<version>0.3</version>
			<date>2014-11-11</date>
			<initials>pw</initials>
			<remark>
				<p>
					Added the possibility for <link url='#ownerupdate'>owners to update meta-data about its things</link>.
					This is done through the optional attribute <strong>jid</strong> on the <strong>update</strong> element.
				</p>
				<p>Added <strong>ROOM</strong> to the <link url='#tags'>list of predefined tag names</link>.</p>
				<p>Added anchors to section headers.</p>
			</remark>
		</revision>
		<revision>
			<version>0.2</version>
			<date>2014-09-07</date>
			<initials>pw</initials>
			<remark>
				<p>Added a small note regarding URL encoding of hash signs, and corrected the Google Chart URL example.</p>
			</remark>
		</revision>
		<revision>
			<version>0.1</version>
			<date>2014-04-10</date>
			<initials>editor (mam)</initials>
			<remark>
				<p>Initial published version approved by XMPP Council.</p>
			</remark>
		</revision>
		<revision>
			<version>0.0.3</version>
			<date>2014-04-09</date>
			<initials>pw</initials>
			<remark>
				<p>Introduced possibility for hosting Thing Registry as a Jabber Server Component, using XEP-0114.</p>
				<p>
					Expanded de section <link url='#support'>Determining Support</link>, explaining how to search through server components.
				</p>
				<p>Removed the possibility to search for nick names, as a way of finding Thing Registries.</p>
				<p>Added Security and Implementation Notes describing the pros and cons of hosting a Thing Registry as a Server Component vs. as a Client.</p>
			</remark>
		</revision>
		<revision>
			<version>0.0.2</version>
			<date>2014-04-07</date>
			<initials>pw</initials>
			<remark>
				<p>Removed any hard-coded account names.</p>
			</remark>
		</revision>
		<revision>
			<version>0.0.1</version>
			<date>2014-03-11</date>
			<initials>pw,rk</initials>
			<remark>
				<p>First draft.</p>
			</remark>
		</revision>
	</header>
	<section1 topic='Introduction' anchor='intro'>
		<p>
			When installing massive amounts of Things into public networks care has to be taken to make installation simple, but at the same time secure so that the Things cannot be
			hijacked or hacked, making sure access to the Thing is controlled by the physical owner of the Thing. One of the main problems is how
			to match the characteristics of a Thing, like serial number, manufacturer, model, etc., with information automatically created by the Thing itself, like perhaps its JID, in
			an environment with massive amount of Things without rich user interfaces. Care has also to be taken when specifying rules for access rights and user privileges.
		</p>
		<p>
			This document provides a network architecture based on the XMPP protocol that provides a means to safely install, configure, find and connect massive amounts of Things together, and
			at the same time minimizing the risk that Things get hijacked. It also provides information how each individual step in the process can be performed with as little manual intervention
			as possible, aiming where possible at zero-configuration networking. Furthermore, this document specifies how to create a registry that allows simple access to public Things
			without risking their integrity unnecessarily.
		</p>
		<p>
			Internet of Things contains many different architectures and use cases. For this reason, the IoT standards have been divided into multiple XEPs according to the following table:
		</p>
		<table caption='Internet of Things XEPs'>
			<tr>
				<th>XEP</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>xep-0000-IoT-BatteryPoweredSensors</td>
				<td>Defines how to handle the peculiars related to battery powered devices, and other devices intermittently available on the network.</td>
			</tr>
			<tr>
				<td>xep-0000-IoT-Events</td>
				<td>Defines how Things send events, how event subscription, hysteresis levels, etc., are configured.</td>
			</tr>
			<tr>
				<td>xep-0000-IoT-Interoperability</td>
				<td>Defines guidelines for how to achieve interoperability in Internet of Things, publishing interoperability interfaces for different types of devices.</td>
			</tr>
			<tr>
				<td>xep-0000-IoT-Multicast</td>
				<td>Defines how sensor data can be multicast in efficient ways.</td>
			</tr>
			<tr>
				<td>xep-0000-IoT-PubSub</td>
				<td>Defines how efficient publication of sensor data can be made in Internet of Things.</td>
			</tr>
			<tr>
				<td>xep-0000-IoT-Chat</td>
				<td>Defines how human-to-machine interfaces should be constructed using chat messages to be user friendly, automatable and consistent with other IoT extensions and possible underlying architecture.</td>
			</tr>
			<tr>
				<td>XEP-0322</td>
                <td>
					Defines how to EXI can be used in XMPP to achieve efficient compression of data. Albeit not an Internet of Things specific XEP, this XEP should be considered
					in all Internet of Things implementations where memory and packet size is an issue.
				</td>
			</tr>
			<tr>
				<td>XEP-0323</td>
				<td>
					Provides the underlying architecture, basic operations and data structures for sensor data communication over XMPP networks.
					It includes a hardware abstraction model, removing any technical detail implemented in underlying technologies. This XEP is used by all other
					Internet of Things XEPs.
				</td>
			</tr>
			<tr>
				<td>XEP-0324</td>
				<td>Defines how provisioning, the management of access privileges, etc., can be efficiently and easily implemented.</td>
			</tr>
			<tr>
				<td>XEP-0325</td>
				<td>Defines how to control actuators and other devices in Internet of Things.</td>
			</tr>
			<tr>
				<td>XEP-0326</td>
				<td>Defines how to handle architectures containing concentrators or servers handling multiple Things.</td>
			</tr>
			<tr>
				<td>XEP-0331</td>
				<td>Defines extensions for how color parameters can be handled, based on &xep0004;</td>
			</tr>
			<tr>
				<td>XEP-0336</td>
				<td>Defines extensions for how dynamic forms can be created, based on &xep0004;, &xep0122;, &xep0137; and &xep0141;.</td>
			</tr>
			<tr>
				<td>XEP-0347</td>
				<td>This specification. Defines the peculiars of Thing discovery in Internet of Things. Apart from discovering Things by JID, it also defines how to discover Things based on location, etc.</td>
			</tr>
		</table>
	</section1>
	<section1 topic='Glossary' anchor='glossary'>
		<p>The following table lists common terms and corresponding descriptions.</p>
		<dl>
			<di>
				<dt>Actuator</dt>
				<dd>Device containing at least one configurable property or output that can and should be controlled by some other entity or device.</dd>
			</di>
			<di>
				<dt>Authority</dt>
				<dd>Used synonymously with Provisioning Server.</dd>
			</di>
			<di>
				<dt>Computed Value</dt>
				<dd>A value that is computed instead of measured.</dd>
			</di>
			<di>
				<dt>Concentrator</dt>
				<dd>Device managing a set of devices which it publishes on the XMPP network.</dd>
			</di>
			<di>
				<dt>Field</dt>
				<dd>
					One item of sensor data. Contains information about: Node, Field Name, Value, Precision, Unit, Value Type, Status, Timestamp, Localization information, etc.
					Fields should be unique within the triple (Node ID, Field Name, Timestamp).
				</dd>
			</di>
			<di>
				<dt>Field Name</dt>
				<dd>Name of a field of sensor data. Examples: Energy, Volume, Flow, Power, etc.</dd>
			</di>
			<di>
				<dt>Field Type</dt>
				<dd>What type of value the field represents. Examples: Momentary Value, Status Value, Identification Value, Calculated Value, Peak Value, Historical Value, etc.</dd>
			</di>
			<di>
				<dt>Historical Value</dt>
				<dd>A value stored in memory from a previous timestamp.</dd>
			</di>
			<di>
				<dt>Identification Value</dt>
				<dd>A value that can be used for identification. (Serial numbers, meter IDs, locations, names, etc.)</dd>
			</di>
			<di>
				<dt>Localization information</dt>
				<dd>Optional information for a field, allowing the sensor to control how the information should be presented to human viewers.</dd>
			</di>
			<di>
				<dt>Meter</dt>
				<dd>A device possible containing multiple sensors, used in metering applications. Examples: Electricity meter, Water Meter, Heat Meter, Cooling Meter, etc.</dd>
			</di>
			<di>
				<dt>Momentary Value</dt>
				<dd>A momentary value represents a value measured at the time of the read-out.</dd>
			</di>
			<di>
				<dt>Node</dt>
				<dd>
					Graphs contain nodes and edges between nodes. In Internet of Things, sensors, actuators, meters, devices, gateways, etc., are often depicted as nodes whereas links between sensors (friendships)
					are depicted as edges. In abstract terms, it's easier to talk about a Node, rather than list different possible node types (sensors, actuators, meters, devices, gateways, etc.).
					Each Node has a Node ID.
				</dd>
			</di>
			<di>
				<dt>Node ID</dt>
				<dd>
					An ID uniquely identifying a node within its corresponding context. If a globally unique ID is desired, an architecture should be used using a universally accepted
					ID scheme.
				</dd>
			</di>
			<di>
				<dt>Parameter</dt>
				<dd>
					Readable and/or writable property on a node/device. The XEP-0326 &xep0326; deals with reading and writing parameters
					on nodes/devices. Fields are not parameters, and parameters are not fields.
				</dd>
			</di>
			<di>
				<dt>Peak Value</dt>
				<dd>A maximum or minimum value during a given period.</dd>
			</di>
			<di>
				<dt>Provisioning Server</dt>
				<dd>
					An application that can configure a network and provide services to users or Things. In Internet of Things, a Provisioning Server knows who knows whom,
					what privileges users have, who can read what data and who can control what devices and what parts of these devices.
				</dd>
			</di>
			<di>
				<dt>Precision</dt>
				<dd>
					In physics, precision determines the number of digits of precision. In sensor networks however, this definition is not easily applicable. Instead, precision
					determines, for example, the number of decimals of precision, or power of precision. Example: 123.200 MWh contains 3 decimals of precision. All entities parsing and
					delivering field information in sensor networks should always retain the number of decimals in a message.
				</dd>
			</di>
			<di>
				<dt>Sensor</dt>
				<dd>
					Device measuring at least one digital value (0 or 1) or analog value (value with precision and physical unit). Examples: Temperature sensor, pressure sensor, etc.
					Sensor values are reported as fields during read-out. Each sensor has a unique Node ID.
				</dd>
			</di>
			<di>
				<dt>SN</dt>
				<dd>Sensor Network. A network consisting, but not limited to sensors, where transport and use of sensor data is of primary concern. A sensor network may contain actuators, network applications, monitors, services, etc.</dd>
			</di>
			<di>
				<dt>Status Value</dt>
				<dd>A value displaying status information about something.</dd>
			</di>
			<di>
				<dt>Timestamp</dt>
				<dd>Timestamp of value, when the value was sampled or recorded.</dd>
			</di>
			<di>
				<dt>Thing</dt>
				<dd>
					Internet of Things basically consists of Things connected to the Internet. Things can be any device, sensor, actuator etc., that can have an
					Internet connection.
				</dd>
			</di>
			<di>
				<dt>Thing Registry</dt>
				<dd>
					A registry where Things can register for simple and secure discovery by the owner of the Thing. The registry can also be used as a database for meta information
					about Things in the network.
				</dd>
			</di>
			<di>
				<dt>Token</dt>
				<dd>
					A client, device or user can get a token from a provisioning server. These tokens can be included in requests to other entities in the network, so these entities can validate
					access rights with the provisioning server.
				</dd>
			</di>
			<di>
				<dt>Unit</dt>
				<dd>Physical unit of value. Example: MWh, l/s, etc.</dd>
			</di>
			<di>
				<dt>Value</dt>
				<dd>A field value.</dd>
			</di>
			<di>
				<dt>Value Status</dt>
				<dd>Status of field value. Contains important status information for Quality of Service purposes. Examples: Ok, Error, Warning, Time Shifted, Missing, Signed, etc.</dd>
			</di>
			<di>
				<dt>Value Type</dt>
				<dd>Can be numeric, string, boolean, Date &amp; Time, Time Span or Enumeration.</dd>
			</di>
			<di>
				<dt>WSN</dt>
				<dd>Wireless Sensor Network, a sensor network including wireless devices.</dd>
			</di>
			<di>
				<dt>XMPP Client</dt>
				<dd>Application connected to an XMPP network, having a JID. Note that sensors, as well as applications requesting sensor data can be XMPP clients.</dd>
			</di>
		</dl>
	</section1>
	<section1 topic='Use Cases' anchor='usecases'>
		<p>
			The life cycle of a Thing can be divided into multiple steps. The following sections will list many of these steps in possible order of occurrence during the
			life cycle of the Thing.
		</p>
		<section2 topic='Production' anchor='production'>
			<p>
				During production of a Thing, decisions have to be made whether the following parameters should be pre-configured, manually entered after installation or
				automatically found and/or created by the device if possible (zero-configuration networking):
			</p>
			<ul>
				<li>
					Address and domain of XMPP Server.
				</li>
				<li>
					JID of the Thing.
				</li>
				<li>
					JID of Thing Registry, if separate from the XMPP Server.
				</li>
				<li>
					JID of first Provisioning Server, if separate from Thing Registry or XMPP Server.
				</li>
			</ul>
			<p>
				A decision has to be made at this point if global/manufacturer/customer servers should be used, or if local resources should be searched for and used if found.
				The first option is easy to configure in a production environment and might have commercial significance,
				but cannot use local resources where available. The second leaves much responsibility to the Thing for finding local resources, but has the advantage of allowing for a more
				decentralized network architecture. A detailed discussion of the two alternatives goes beyond the scope of this specification, and will not be presented here.
			</p>
		</section2>
		<section2 topic='Installation' anchor='installation'>
			<p>
				Apart from physical installation, and connection to power and communication infrastructure, the installation phase of a Thing might also require manual entry of values that
				could not be set in the production environment. Since Things might have very limited human user interfaces, external tools might be required to provide this information. Due
				to its complexity, any manual entry of configuration parameters should be avoided, if possible. However, manual entry of some parameters might allow for Things to use local
				resources where such cannot be found nor set in a production environment.
			</p>
		</section2>
		<section2 topic='Finding XMPP Server' anchor='findingserver'>
			<p>
				If the address of an XMPP Server is not preconfigured, the Thing must attempt to find one in its local surroundings. This can be done using one of several methods:
			</p>
			<ul>
				<li>DHCP</li>
				<li>Multicast DNS</li>
				<li>SSDP/UPnP</li>
			</ul>
			<p>
				The following sections describe them in more detail.
			</p>
			<section3 topic='DHCP' anchor='dhcp'>
				<p>
					DHCP offers an internal structure for advertising configuration information to clients in a network.
					This includes configuration parameters and other control elements, which are transmitted in special marked data elements, called 'options', as described in
					<span class='ref'>
						<link url='http://tools.ietf.org/html/rfc3942'>RFC 3942</link>
					</span> <note>
						RFC 3942: Reclassifying Dynamic Host Configuration Protocol version 4 (DHCPv4) Options &lt;<link url='http://tools.ietf.org/html/rfc3942'>http://tools.ietf.org/html/rfc3942</link>&gt;.
					</note>.
				</p>
				<p>
					<link url='http://www.iana.org/assignments/bootp-dhcp-parameters/bootp-dhcp-parameters.txt'>Dynamic Host Configuration Protocol (DHCP) and Bootstrap Protocol (BOOTP) Parameters</link> lists currently assigned 'options' by IANA.
					<strong>Note:</strong> There does exist no 'option' for XMPP at the moment.
					Options 224 to 254 are marked as 'site-specific option range' to support local (to a site) configuration options (i.e., reserved as 'Private Use').
				</p>
				<p>
					Possible codes for the XMPP server option:
				</p>
				<ul>
					<li>Use 'site-specific option range'. Use of 'option-code' 224.</li>
					<li>
						<strong>TBD:</strong> Define and register DHCP and BOOTP option as described in <link url='#option'>Parameters for IoT Discovery</link>. Use of 'option-code' 84.
					</li>
				</ul>
				<section4 topic='XMPP Server Option' anchor='serveroption'>
					<p>
						This option specifies the name of the XMPP server.
						The name may or may not be qualified with the local domain name.
						See &rfc1035; for character set restrictions.
					</p>
					<p>
						The code for this option is 224 (for 'site-specific option range') or 84 (for <link url='#option'>DHCP and BOOTP Parameters for IoT Discovery</link>), and its minimum length is 1.
					</p>
					<example caption='IoT Discovery DHCP Option'>
						<![CDATA[
   <option code> <data length> machine]]>
					</example>
					<p>So, for example, if the machine name is "pronto", the code for the option is 224, the XMPP server option would be as follows:</p>
					<example caption='IoT Discovery DHCP Option Example'>
						<![CDATA[
   224 12 pronto.local]]>
					</example>
				</section4>
				<section4 topic='Dynamic Host Configuration Protocol (DHCP) and Bootstrap Protocol (BOOTP) Parameters for IoT Discovery' anchor='dhcpoption'>
					<p>The following parameters in use as of MONTH 201x. Refer to the DHCP and BOOTP parameters itself for a complete and current list of parameters (this specification might or might not be revised when new parameters are registered).</p>
					<example caption='IoT Discovery DHCP and BOOTP Parameters Registry'>
						<![CDATA[
   <tag>84</tag>
   <name>XMPP server</name>
   <data length>N</data length>
   <meaning>XMPP Servers DHCP Option</meaning>
   <reference>[RFC6120]</reference>]]>
					</example>
				</section4>
			</section3>
			<section3 topic='Multicast DNS (mDNS) and DNS Service Discovery (DNS-SD)' anchor='dns'>
				<p>
					An introduction of mDNS/DNS-SD (e.g., how it works and terminology) is described in &xep0174; (i.e., sections [1.2] and [2]).
					For the purpose of IoT Discovery we are interested only in the "xmpp-client" service.
					An XMPP server MUST publish four different kinds of DNS records to advertise its availability using the services of type "xmpp-client".
					An XMPP chat client (actually its mDNS daemon) can send out multicast DNS queries for services of type "xmpp-client".
					<strong>Note:</strong> the service of type "xmpp-client" is the reservered name for client-to-server connections by IANA, as described in &rfc6120;.
				</p>
				<section4 topic='DNS Records' anchor='dnsrecords'>
					<p>In order to advertise its availability, a server MUST publish four different kinds of DNS records:</p>
					<ol>
						<li>
							<p>A PTR record of the following form:</p>
							<example caption='PTR record'>
								<![CDATA[
   _xmpp-client._tcp.local. PTR machine._xmpp-client._tcp.local.]]>
							</example>
						</li>
						<li>
							<p>An address ("A" or "AAAA") record of the following form (where the IP address can be either an IPv4 address or an IPv6 address):</p>
							<example caption='A record'>
								<![CDATA[
   machine.local. A ip-address]]>
							</example>
						</li>
						<li>
							<p>A SRV record of the following form:</p>
							<example caption='SRV record'>
								<![CDATA[
   machine._xmpp-client._tcp.local <ttl> SRV <priority> <weight> port-number machine.local.]]>
							</example>
						</li>
						<li>
							<p>
								A TXT record whose name is the same as the SRV record and whose value follows the format described in the <link url='#txt'>TXT Record</link> section of this document, consisting of a set of strings that typically represent a series of key-value pairs such as the following:
							</p>
							<example caption='TXT record'>
								<![CDATA[
   txtvers=1
   ordom=example.com
   regis=registry
   provis=provisioning]]>
							</example>
							<p>Note: The DNS-SD specification stipulates that the TXT record MUST be published, but that it MAY contain no more than a single zero byte (e.g., if the server does not wish to publish any personal information).</p>
						</li>
					</ol>
					<p>
						For the purpose of IoT Discovery we are interested only in the "xmpp-client" service.
						An XMPP server MUST publish four different kinds of DNS records to advertise its availability using the services of type "xmpp-client".
						An XMPP chat client (actually its mDNS daemon) can send out multicast DNS queries for services of type "xmpp-client".
						<strong>Note:</strong> the service of type "xmpp-client" is the reservered name for client-to-server connections by IANA, as described in &rfc6120;.
					</p>
					<p>So, for example, if the machine name is "pronto", the IP address is "10.2.1.188", and the personal information, the DNS records would be as follows:</p>
					<example caption='IoT Discovery DNS Records Example'>
						<![CDATA[
   _xmpp-client._tcp.local. PTR pronto._xmpp-client._tcp.local.
	
   pronto._xmpp-client._tcp.local. SRV 5222 pronto.local. 
				
   pronto.local. A 10.2.1.188
				
   pronto._xmpp-client._tcp.local. IN TXT 
   "txtvers=1"
   "ordom=example.com"
   "regis=registry"
   "provis=provisioning"]]>
					</example>
					<p>The IPv4 and IPv6 addresses associated with a machine might vary depending on the local network to which the machine is connected. For example, on an Ethernet connection the physical address might be "192.168.0.100" but when the machine is connected to a wireless network the physical address might change to "10.10.1.188". See &rfc3927; for details.</p>
					<p>If the machine name asserted by a client is already taken by another machine on the network, the client MUST assert a different machine name, which SHOULD be formed by adding the character "-" and digit "1" to the end of the machine name string (e.g., "pronto-1"), adding the character "-" and digit "2" if the resulting machine name is already taken (e.g., "pronto-2"), and similarly incrementing the digit until a unique machine name is constructed.</p>
					<p>
						<strong>Note:</strong> DNS-SD enables service definitions to include a TXT record that specifies parameters to be used in the context of the relevant service type. For detailed information refer to &xep0174; (Link-Local Messaging - TXT Record).
					</p>
				</section4>
				<section4 topic='IoT Discovery TXT Record Parameters Registry' anchor='txt'>
					<p>The registration process is described in &xep0174; (Link-Local Messaging - Registration Process).</p>
					<p>The following submission registers parameters in use as of MONTH 201x. Refer to the registry itself for a complete and current list of parameters (this specification might or might not be revised when new parameters are registered).</p>
					<example caption='IoT Discovery TXT Record Parameters Registry'>
						<![CDATA[
   <param>
      <name>ordom</name>
      <desc>The "origin domain" of the XMPP service.</desc>
      <status>recommended</status>
   </param>

   <param>
      <name>regis</name>
      <desc>
         The username portion of the JID to Thing Registry;
         can contain a space-separated list of more than one JID.
      </desc>
      <status>optional</status>
   </param>

   <param>
      <name>provis</name>
      <desc>
         The username portion of the JID to provisioning server;
         can contain a space-separated list of more than one JID.
      </desc>
      <status>optional</status>
   </param>]]>
					</example>
				</section4>
				<!-- Ref: XEP-0174 -->
			</section3>
			<section3 topic='SSDP/UPnP' anchor='upnp'>
				<p>TBD</p>
				<!-- TODO -->
			</section3>
			<p>
				<strong>Note:</strong> If server-less messaging is to be used, as described in &xep0174; this step can be used to find the Thing Registry and optionally the
				Provisioning Server and other peers it want to connect to. The next section can thus be skipped.
			</p>
		</section2>
		<section2 topic='Connection to XMPP Server' anchor='connection'>
			<p>
				Once an XMPP Server has been found, a connection can be made. If multiple XMPP Servers are found, the client is free to choose the one that best suits its purposes.
			</p>
			<p>
				If the Thing does not have an account already, an account can be registered along what is specified in &xep0077;. If multiple servers are available, the first XMPP server that
				allows account creation can be used.
			</p>
		</section2>
		<section2 topic='Finding Thing Registry' anchor='findingregistry'>
			<p>
				If a Thing Registry is not preconfigured, one must be found. A Thing Registry can be hosted either as a server component using &xep0114; or as an XMPP Client accessible through
				a JID. The following lists methods to obtaining the Component Address or JID for the Thing Registry. Note that the last one has <link url='#security'>security considerations</link> 
				that need to be taken into account, if implemented.
			</p>
			<ol>
				<li>
					Preconfigured Component Address of Thing Registry. A Component address is normally a subdomain to the domain of the XMPP Server that hosts the component.
				</li>
				<li>
					Preconfigured bare JID of Thing Registry.
				</li>
				<li>
					Preconfigured subdomain part of Component Address. This will be added to the domain of the XMPP Server used to connet to.
				</li>
				<li>
					Preconfigured user name of JID. This will be added to the domain of the XMPP Server used to connected to.
				</li>
				<li>
					Searching through Server Components on the XMPP Server currently connected to, as described in <link url='#support'>Determining Support</link>.
				</li>
			</ol>
		</section2>
		<section2 topic='Registering Thing' anchor='register'>
			<p>
				Once a Thing Registry has been found and been befriended, the Thing can register itself with the registry, as follows:
			</p>
			<example caption='Register Thing'>
				<![CDATA[
   <iq type='set'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='1'>
      <register xmlns='urn:xmpp:iot:discovery'>
          <str name='SN' value='394872348732948723'/>
          <str name='MAN' value='www.ktc.se'/>
          <str name='MODEL' value='IMC'/>
          <num name='V' value='1.2'/>
          <str name='KEY' value='4857402340298342'/>
      </register>
   </iq>
   
   <iq type='result'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='1'/>]]>
			</example>
			<p>
				There are two types of tags: Tags with string values and tags with numerical values. The distinction is important, since the type of value affects how
				comparisons are made later when performing searches in the registry.
			</p>
			<p>
				The Thing should only register parameters required to be known by the owner of the Thing. Dynamic meta information must be avoided at this point.
				To claim the ownership of the Thing, the owner needs to present the same meta information as registered by the Thing. Before an owner has claimed
				ownership of the Thing, it will not be returned in any search results. A list of predefined meta tag names can be found in the <link url='#tags'>Meta Tags</link>
				section below.
			</p>
			<p>
				The Thing can register itself as many times as it wants, and the response is always empty. Only one record per resource-less JID must be created. A new
				registration overrides any previous information, including meta tags previously reported but not available in the new registration. Once a Thing has been
				claimed by an owner, it should not register itself again, unless it is reset and the installation process restarted.
			</p>
			<p>
				If the Thing tries to register itself even though the Thing has already been claimed in the registry, the registry must not update any meta data in the registry, and instead
				respond with the following response. When the thing receives this, it can safely extract the JID of the owner and switch its internal state to claimed.
			</p>
			<example caption='Registration response when alrady claimed'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='1'>
      <claimed xmlns='urn:xmpp:iot:discovery' jid='owner@example.org'/>
   </iq>]]>
			</example>
			<p>
				<strong>Note:</strong> Meta Tag names are case insensitive. In this document, all tag names have been written using upper case letters.
			</p>
		</section2>
		<section2 topic='Register self-owned Thing' anchor='registerselfowner'>
			<p>
				If a thing is self-owned, it can register itself with the Registry as normal, with the addition of setting the attribute <strong>selfOwned</strong> to <strong>true</strong>,
				as is shown below. This registers the Thing directly as PUBLIC CLAIMED, with no need for an owner to claim ownership of the device. This can be useful if
				installing Things that should be publically available.
			</p>
			<example caption='Register self-owned Thing'>
				<![CDATA[
   <iq type='set'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='2'>
      <register xmlns='urn:xmpp:iot:discovery' selfOwned='true'>
          <str name='SN' value='394872348732948723'/>
          <str name='MAN' value='www.ktc.se'/>
          <str name='MODEL' value='IMC'/>
          <num name='V' value='1.2'/>
          <str name='KEY' value='4857402340298342'/>
      </register>
   </iq>
   
   <iq type='result'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='2'/>]]>
			</example>
		</section2>
		<section2 topic='Register Thing behind Concentrator' anchor='registerconcentrator'>
			<p>
				A Thing might reside behind a gateway or concentrator and might not be directly connected to the XMPP network itself, as is described in &xep0326;. In these cases, there are three optional
				attributes that can be used to identify the Thing behind the JID: The <strong>nodeId</strong> attribute gives the ID of the Thing (a.k.a. "Node"). The Node might reside in
				specific Data Source (large systems might have multiple sources of nodes). In this case, the data source is specified in the <strong>sourceId</strong> attribute. Normally, the Node ID
				is considered to be unique within the concentrator. If multiple data sources are available, the Node ID is unique within the data source. However, a third attribute allows the uniqueness
				to be restricted to a given <strong>cacheType</strong>. Finally, it is the triple (<strong>nodeId</strong>, <strong>sourceId</strong>, <strong>cacheType</strong>) which guarantees
				uniqueness within the concentrator.
			</p>
			<p>
				For a Thing controlled by a concentrator to register itself in the Thing Registry, it simply adds the optional attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> as appropriate to the registration request, as follows:
			</p>
			<example caption='Register Thing behind Concentrator'>
				<![CDATA[
   <iq type='set'
       from='rack@example.org/plcs'
       to='discovery.example.org'
       id='3'>
      <register xmlns='urn:xmpp:iot:discovery' nodeId='imc1' sourceId='MeteringTopology'>
          <str name='SN' value='394872348732948723'/>
          <str name='MAN' value='www.ktc.se'/>
          <str name='MODEL' value='IMC'/>
          <num name='V' value='1.2'/>
          <str name='KEY' value='4857402340298342'/>
      </register>
   </iq>
   
   <iq type='result'
       from='discovery.example.org'
       to='rack@example.org/plcs'
       id='3'/>]]>
			</example>
			<p>
				If the Thing behind the concentrator is self-owned, it simply adds the <strong>selfOwned</strong> attribute to the request and sets it to <strong>true</strong>.
			</p>
		</section2>
		<section2 topic='Claiming Ownership of a Thing' anchor='claim'>
			<p>
				As mentioned above, the owner of the Thing must provide the information provided by the Thing to the Registry, in order to claim ownership over it. To avoid the
				possibility that somebody can guess the information, the information must necessarily be long. This creates the problem of transfer of information. One method to solve this
				is through the use of QR-codes. Such codes can be either printed on a sticker and put on the Thing itself, its wrapping, or displayed on its display when not claimed.
				This QR-code can then be photographed by a smart phone or tablet, decoded and the information retrieved can be used in the ownership claim call.
			</p>
			<p>
				If QR-codes are used to transfer Thing meta data for ownership claims, it must be generated as follows: To the string "IoTDisco" is appended all meta tags in order.
				Each tag name is prefixed by a semi-colon (;), and if the tag is numeric, the tag is prefixed by an additional hash sign (#). Each tag value is prefixed by a colon (:). 
				If the meta value contains semi-colons or back-slashes, each one is prefixed by a back-slash. When decoding the string, this allows the decoder to correctly differ 
				between tag delimiters and characters belonging to tag values. A tag name must never contain colon, hash sign or white space characters.
			</p>
			<p>
				The above meta data would therefore generate the string:
			</p>
			<example caption='String to encode as a QR-code'>
				<![CDATA[
   IoTDisco;SN:394872348732948723;MAN:www.ktc.se;MODEL:IMC;#V:1.2;KEY:4857402340298342]]>
			</example>
			<p>
				Using UTF-8 encoding when generating the QR-code, this string returns the following QR-code:
			</p>
			<p>
				<img src='https://chart.googleapis.com/chart?cht=qr&amp;chs=200x200&amp;chl=IoTDisco;SN:394872348732948723;MAN:www.ktc.se;MODEL:IMC;%23V:1.2;KEY:4857402340298342'/>
			</p>
			<p>
				To generate a QR-code, Google Chart API can be used:
				<link url='https://chart.googleapis.com/chart?cht=qr&amp;chs=200x200&amp;chl=IoTDisco;SN:394872348732948723;MAN:www.ktc.se;MODEL:IMC;%23V:1.2;KEY:4857402340298342'>https://chart.googleapis.com/chart?cht=qr&amp;chs=200x200&amp;chl=IoTDisco;SN:394872348732948723;MAN:www.ktc.se;MODEL:IMC;%23V:1.2;KEY:4857402340298342</link>
			</p>
			<p>
				<strong>Note:</strong> The hash sign (#) has been URL encoded to <strong>%23</strong> in the URL.
			</p>
			<p>
				Once the client has the required meta information about the Thing to claim ownership, it sends itself the following request to the Thing Registry:
			</p>
			<example caption='Claim Ownership of public Thing'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/phone'
       to='discovery.example.org'
       id='4'>
      <mine xmlns='urn:xmpp:iot:discovery'>
          <str name='SN' value='394872348732948723'/>
          <str name='MAN' value='www.ktc.se'/>
          <str name='MODEL' value='IMC'/>
          <num name='V' value='1.2'/>
          <str name='KEY' value='4857402340298342'/>
      </mine>
   </iq>]]>
			</example>
			<p>
				If this claim is successful, the Thing is marked as a public claimed Thing. The thing can always be removed later, but after the claim, the Thing is public. If you want to claim
				a private Thing, you can add the <strong>public</strong> attribute with value <strong>false</strong> to the claim, as follows:
			</p>
			<example caption='Claim Ownership of private Thing'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/phone'
       to='discovery.example.org'
       id='4'>
      <mine xmlns='urn:xmpp:iot:discovery' public='false'>
          <str name='SN' value='394872348732948723'/>
          <str name='MAN' value='www.ktc.se'/>
          <str name='MODEL' value='IMC'/>
          <num name='V' value='1.2'/>
          <str name='KEY' value='4857402340298342'/>
      </mine>
   </iq>]]>
			</example>
			<p>
				In this case, if the claim is successful, the Thing will not be made public in the Thing Registry, after the claim.
			</p>
			<p>
				If a claim is successful, i.e. there's a Thing that has not been claimed with EXACTLY the same meta data (however, the order is not important), the Thing is marked in the
				Registry as CLAIMED, and as public or private depending on the <strong>public</strong> attribute, and an empty result is returned as follows. If there's a claimed Thing with
				exactly the same meta data, and the JID of the claimant (without resource) matches the JID of the claimer (without resource), a success response is also returned, containing
				the resource-less JID of the Thing, as follows:
			</p>
			<example caption='Ownership claim successful'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='4'>
      <claimed xmlns='urn:xmpp:iot:discovery' jid='thing@example.org'/>
   </iq>]]>
			</example>
			<p>
				If the Thing that has been claimed resides behind a concentrator, the result will contain those of the attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> that are required to access the Thing in calls made using &xep0323;, &xep0324;, &xep0325; and &xep0326;. The following example illustrates
				a response where a Thing behind a Concentrator has been claimed:
			</p>
			<example caption='Ownership claim of a Thing behind a concentrator successful'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='4'>
      <claimed xmlns='urn:xmpp:iot:discovery' jid='rack@example.org/plcs' nodeId='imc1' sourceId='MeteringTopology'/>
   </iq>]]>
			</example>
			<p>
				If, on the other hand, no such Thing was found, or if such a Thing was found, but it is already claimed by somebody else, a failure response is returned. This response
				should avoid to inform the client in detail why the claim failed, as follows:
			</p>
			<example caption='Ownership claim failure'>
				<![CDATA[
   <iq type='error'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='4'>
      <error type='cancel'>
         <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
      </error>
   </iq>]]>
			</example>
			<p>
				When the Thing has been successfully claimed, the Registry sends information about this to the Thing, to inform it that it has been claimed and the resource-less JID of owner.
				After receiving this information, it doesn't need to register itself with the Registry anymore.
			</p>
			<example caption='Ownership claimed'>
				<![CDATA[
   <iq type='set'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='5'>
      <claimed xmlns='urn:xmpp:iot:discovery' jid='owner@example.org'/>
   </iq>]]>
			</example>
			<p>
				If the Thing was claimed as a private Thing, this is shown using the <strong>public</strong> attribute in the response, as follows:
			</p>
			<example caption='Ownership claim of private Thing successful'>
				<![CDATA[
   <iq type='set'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='5'>
      <claimed xmlns='urn:xmpp:iot:discovery' jid='owner@example.org' public='false'/>
   </iq>]]>
			</example>
			<p>
				If the <strong>public</strong> attribute is present and has value <strong>false</strong>, it means no further meta data updates are necessary, since
				the device is not searchable through the Thing Registry.
			</p>
			<p>
				If the Thing resides behind a concentrator, the request must contain those of the attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> that are required to access the Thing, as follows:
			</p>
			<example caption='Ownership of Thing behind concentrator claimed'>
				<![CDATA[
   <iq type='set'
       from='discovery.example.org'
       to='rack@example.org/plcs'
       id='5'>
      <claimed xmlns='urn:xmpp:iot:discovery' jid='owner@example.org' nodeId='imc1' sourceId='MeteringTopology'/>
   </iq>]]>
			</example>
			<p>
				The Thing simply returns an empty response to acknowledge the receipt of the information, as follows:
			</p>
			<example caption='Ownership claimed acknowledged'>
				<![CDATA[
   <iq type='result'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='5'/>]]>
			</example>
			<p>
				After receiving this, the thing knows it can accept friendship requests from the corresponding owner. It can also safely send a friendship request to the owner.
			</p>
			<p>
				<strong>Note:</strong> Meta Tag names are case insensitive. In this document, all tag names have been written using upper case letters.
			</p>
		</section2>
		<section2 topic='Removing Thing from Registry' anchor='remove'>
			<p>
				After a Thing has been claimed and is registed as a PUBLIC CLAIMED Thing in the Registry, it implies the Thing is available in searches. The owner can choose to remove
				the Thing from the Registry, to avoid that the Thing appears in searches. To remove a Thing from the Registry the owner simply sends a removal request to the Registry
				with the resource-less JID of the Thing to remove, as follows:
			</p>
			<example caption='Remove Thing'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/phone'
       to='discovery.example.org'
       id='6'>
      <remove xmlns='urn:xmpp:iot:discovery' jid='thing@example.org'/>
   </iq>]]>
			</example>
			<p>
				If the Thing resides behind a concentrator, the request must contain those of the attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> that are required to access the Thing, as follows:
			</p>
			<example caption='Remove Thing behind concentrator'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/phone'
       to='discovery.example.org'
       id='6'>
      <remove xmlns='urn:xmpp:iot:discovery' jid='rack@example.org/plcs' nodeId='imc1' sourceId='MeteringTopology'/>
   </iq>]]>
			</example>
			<p>
				If such a Thing is found and is owned by the caller, it is removed from the Registry, and an empty response is returned, to acknowledge the removal of the Thing
				from the registry, as follows:
			</p>
			<example caption='Thing removed'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='6'/>]]>
			</example>
			<p>
				However, if such a thing is not found, or if the thing is owned by another, an <strong>item-not-found</strong> error is returned, as follows:
			</p>
			<example caption='Removal failure'>
				<![CDATA[
   <iq type='error'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='6'>
      <error type='cancel'>
         <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
      </error>
   </iq>]]>
			</example>
			<p>
				After successfully removing a Thing from the Registry, and if the Thing is friend to the Registry, the Registry informs the Thing it has been removed from the Registry.
				It does this, so the Thing can remove the friendship and stop any meta data updates to the Registry.
			</p>
			<example caption='Thing removed from registry by owner'>
				<![CDATA[
   <iq type='set'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='7'>
      <removed xmlns='urn:xmpp:iot:discovery'/>
   </iq>
   
   <iq type='result'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='7'/>]]>
			</example>
			<p>
				If the Thing lies behind a concentrator, the removal request would look as follows:
			</p>
			<example caption='Thing behind concentrator removed from registry by owner'>
				<![CDATA[
   <iq type='set'
       from='discovery.example.org'
       to='rack@example.org/plcs'
       id='7'>
      <removed xmlns='urn:xmpp:iot:discovery' nodeId='imc1' sourceId='MeteringTopology'/>
   </iq>]]>
			</example>
			<p>
				The Thing acknowledges the removal request by returning an empty response, as follows:
			</p>
			<example caption='Removal acknowledgement'>
				<![CDATA[
   <iq type='result'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='7'/>]]>
			</example>
		</section2>
		<section2 topic='Finding Provisioning Server' anchor='findingprovisioning'>
			<p>
				Up to this point only basic configuration and ownership and visibility of a Thing has been covered. For more advanced operations, a Thing might be required to
				use a Provisioning Server to whom it can delegate trust and allow making decisions, controlling access rights and privileges for the Thing, as described in &xep0324;.
				If a Provisioning Server is not preconfigured, one must be found. The following lists methods to obtaining the JID for the Provisioning Server.
			</p>
			<ol>
				<li>
					Preconfigured Component Address of Provisioning Server. A Component address is normally a subdomain to the domain of the XMPP Server that hosts the component.
				</li>
				<li>
					Preconfigured bare JID of Provisioning Server.
				</li>
				<li>
					Preconfigured subdomain part of Component Address. This will be added to the domain of the XMPP Server used to connet to.
				</li>
				<li>
					Preconfigured user name of JID. This will be added to the domain of the XMPP Server used to connected to.
				</li>
				<li>
					The Thing Registry itself can be a Provisioning Server. This can be found out by sending a discovery request to the Thing Registry,
					as described in <link url='#support'>Determining Support</link>.
				</li>
				<li>
					The Owner itself can be a Provisioning Server. This can be found out by sending a discovery request to the Owner,
					as described in <link url='#support'>Determining Support</link>.
				</li>
				<li>
					Searching through Server Components on the XMPP Server currently connected to, as described in <link url='#support'>Determining Support</link>.
				</li>
			</ol>
		</section2>
		<section2 topic='Delegating Trust' anchor='delegate'>
			<p>
				Once a Provisioning Server has been found and been befriended, the Thing can delegate its trust to it, according to &xep0324;.
			</p>
		</section2>
		<section2 topic='Update Meta Information about Thing in Registry' anchor='update'>
			<p>
				Once a Thing has been claimed and chooses to reside as a public Thing in the registry, it can update its meta information at any time. This meta information
				will be available in searches made to the registry by third parties and is considered public. However, the Thing should be connected to a provisioning server
				at this point, so that correct decisions can be made regarding to friendship, readout and control requests made by parties other than the owner.
			</p>
			<p>
				Meta information updated in this way will only overwrite tags provided in the request, and leave other tags previously reported as is. To remove a string-valued tag,
				it should be updated with an empty value. It is also recommended that key meta information required to claim ownership of the Thing after a factory reset is
				either removed, truncated or otherwise modified after it has been claimed so that third parties with physical access to a public Thing cannot hijack it by searching
				for it, extracting its meta information from the registry, then resetting it and then claiming ownership of it.
			</p>
			<p>
				To update meta data about itself, a Thing simply sends a request to the Thing Registry, as follows:
			</p>
			<example caption='Update Meta Data request'>
				<![CDATA[
   <iq type='set'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='8'>
      <update xmlns='urn:xmpp:iot:discovery'>
          <str name='KEY' value=''/>
          <str name='CLASS' value='PLC'/>
          <num name='LON' value='-71.519722'/>
          <num name='LAT' value='-33.008055'/>
      </update>
   </iq>]]>
			</example>
			<p>
				If the Thing resides behind a concentrator, the request must contain those of the attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> that are required to access the Thing, as follows:
			</p>
			<example caption='Update Meta Data of Thing behind concentrator'>
				<![CDATA[
   <iq type='set'
       from='rack@example.org/plcs'
       to='discovery.example.org'
       id='8'>
      <update xmlns='urn:xmpp:iot:discovery' nodeId='imc1' sourceId='MeteringTopology'>
          <str name='KEY' value=''/>
          <str name='CLASS' value='PLC'/>
          <num name='LON' value='-71.519722'/>
          <num name='LAT' value='-33.008055'/>
      </update>
   </iq>]]>
			</example>
			<p>
				If the Thing is found in the registry and it is claimed, the registry simply acknowledges the update as follows:
			</p>
			<example caption='Update Meta Data request acknowledgement'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='8'/>]]>
			</example>
			<p>
				However, if the Thing is not found in the registry, probably because the owner has removed it from the registry, an error response is returned. When receiving
				such a response, the Thing should assume it is the owner who has removed it from the registry, and that further meta data updates are not desired. The Thing
				can then unfriend the registry and stop further meta data updates. The error response from the registry would look as follows:
			</p>
			<example caption='Update Meta Data request failure'>
				<![CDATA[
   <iq type='error'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='8'>
      <error type='cancel'>
         <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
      </error>
   </iq>]]>
			</example>
			<p>
				If the Thing on the other hand is found in the Registry, but is not claimed, the registry must not update any meta data in the registry, and instead
				respond with the following response. When the thing receives this, the Thing can assume it has been disowned, and perform a new registration in the Registry so
				that it can be re-claimed.
			</p>
			<example caption='Update Meta Data response to request from disowned Thing'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='8'>
      <disowned xmlns='urn:xmpp:iot:discovery'/>
   </iq>]]>
			</example>
			<p>
				<strong>Note:</strong> Meta Tag names are case insensitive. In this document, all tag names have been written using upper case letters.
			</p>
		</section2>
		<section2 topic='Owner updating Meta Information about Thing in Registry' anchor='ownerupdate'>
			<p>
				An owner of a thing can also update the meta-data of a thing it has claimed. To do this, you simply add a <strong>jid</strong> attribute containing the JID of the thing to the
				<strong>update</strong> element. (If this attribute is not present, the JID is assumed to be that of the sender of the message.)
			</p>
			<example caption='Owner requests an update of Meta Data of Thing'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/1234'
       to='discovery.example.org'
       id='8'>
      <update xmlns='urn:xmpp:iot:discovery' jid='thing@example.org'>
          <str name='ROOM' value='...'/>
          <str name='APT' value='...'/>
          <str name='BLD' value='...'/>
          <str name='STREET' value='...'/>
          <str name='STREETNR' value='...'/>
          <str name='AREA' value='...'/>
          <str name='CITY' value='...'/>
          <str name='REGION' value='...'/>
          <str name='COUNTRY' value='...'/>
      </update>
   </iq>]]>
			</example>
			<p>
				The owner can update meta-data of things behind concentrators also. To do this, the corresponding attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> must be used to identify the thing, as follows:
			</p>
			<example caption='Owner requests an update of Meta Data of Thing behind concentrator'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/1234'
       to='discovery.example.org'
       id='8'>
      <update xmlns='urn:xmpp:iot:discovery' jid='rack@example.org' nodeId='imc1' sourceId='MeteringTopology'>
          <str name='ROOM' value='...'/>
          <str name='APT' value='...'/>
          <str name='BLD' value='...'/>
          <str name='STREET' value='...'/>
          <str name='STREETNR' value='...'/>
          <str name='AREA' value='...'/>
          <str name='CITY' value='...'/>
          <str name='REGION' value='...'/>
          <str name='COUNTRY' value='...'/>
      </update>
   </iq>]]>
			</example>
			<p>
				If the Thing is found in the registry and it is claimed by the sender of the current message (i.e. owner is the sender), the registry simply acknowledges the update as follows:
			</p>
			<example caption='Owner updating thing Meta Data request acknowledgement'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='owner@example.org/1234'
       id='8'/>]]>
			</example>
			<p>
				But if the owner is not the sender of the current message (i.e. owner is somebody else), or if the thing is not found at all, the server must report the node as 
				<strong>not existing</strong> (i.e. not existing among the set of things claimed by the owner).
			</p>
			<example caption='Owner updating thing Meta Data request failure'>
				<![CDATA[
   <iq type='error'
       from='discovery.example.org'
       to='owner@example.org/1234'
       id='8'>
      <error type='cancel'>
         <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
      </error>
   </iq>]]>
			</example>
		</section2>
		<section2 topic='Search for Public Things in Registry' anchor='search'>
			<p>
				It is possible for anyone with access to the Thing Registry to search for public Things that have been claimed, including self-owned Things. Such searches
				will never return things that have not been claimed or have been removed from the registry.
			</p>
			<p>
				A search is performed by providing one or more comparison operators in a search request to the registry. If more than one comparison operator is provided, the
				search is assumed to be performed on the intersection (i.e. AND) of all operators. If the union (i.e. OR) of different conditions is desired, multiple consecutive
				searches have to be performed.
			</p>
			<p>
				The following table lists available search operators, their element names and meanings:
			</p>
			<table caption='Search operators'>
				<tr>
					<th>Element</th>
					<th>Type</th>
					<th>Operator</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>strEq</td>
					<td>String</td>
					<td>tag = c</td>
					<td>Searches for string values tags with values equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>strNEq</td>
					<td>String</td>
					<td>tag &lt;&gt; c</td>
					<td>Searches for string values tags with values not equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>strGt</td>
					<td>String</td>
					<td>tag &gt; c</td>
					<td>Searches for string values tags with values greater than a provided constant value.</td>
				</tr>
				<tr>
					<td>strGtEq</td>
					<td>String</td>
					<td>tag &gt;= c</td>
					<td>Searches for string values tags with values greater than or equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>strLt</td>
					<td>String</td>
					<td>tag &lt; c</td>
					<td>Searches for string values tags with values lesser than a provided constant value.</td>
				</tr>
				<tr>
					<td>strLtEq</td>
					<td>String</td>
					<td>tag &lt;= c</td>
					<td>Searches for string values tags with values lesser than or equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>strRange</td>
					<td>String</td>
					<td>min &lt;(=) tag &lt;(=) max</td>
					<td>Searches for string values tags with values within a specified range of values. The endpoints can be included or excluded in the search.</td>
				</tr>
				<tr>
					<td>strNRange</td>
					<td>String</td>
					<td>tag &lt;(=) min OR tag &gt;(=) max</td>
					<td>Searches for string values tags with values outside of a specified range of values. The endpoints can be included or excluded in the range (and therefore correspondingly excluded or included in the search).</td>
				</tr>
				<tr>
					<td>strMask</td>
					<td>String</td>
					<td>tag LIKE c</td>
					<td>Searches for string values tags with values similar to a provided constant value including wildcards.</td>
				</tr>
				<tr>
					<td>numEq</td>
					<td>Numeric</td>
					<td>tag = c</td>
					<td>Searches for numerical values tags with values equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>numNEq</td>
					<td>Numeric</td>
					<td>tag &lt;&gt; c</td>
					<td>Searches for numerical values tags with values not equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>numGt</td>
					<td>Numeric</td>
					<td>tag &gt; c</td>
					<td>Searches for numerical values tags with values greater than a provided constant value.</td>
				</tr>
				<tr>
					<td>numGtEq</td>
					<td>Numeric</td>
					<td>tag &gt;= c</td>
					<td>Searches for numerical values tags with values greater than or equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>numLt</td>
					<td>Numeric</td>
					<td>tag &lt; c</td>
					<td>Searches for numerical values tags with values lesser than a provided constant value.</td>
				</tr>
				<tr>
					<td>numLtEq</td>
					<td>Numeric</td>
					<td>tag &lt;= c</td>
					<td>Searches for numerical values tags with values lesser than or equal to a provided constant value.</td>
				</tr>
				<tr>
					<td>numRange</td>
					<td>Numeric</td>
					<td>min &lt;(=) tag &lt;(=) max</td>
					<td>Searches for numerical values tags with values within a specified range of values. The endpoints can be included or excluded in the search.</td>
				</tr>
				<tr>
					<td>numNRange</td>
					<td>Numeric</td>
					<td>tag &lt;(=) min OR tag &gt;(=) max</td>
					<td>Searches for numerical values tags with values outside of a specified range of values. The endpoints can be included or excluded in the range (and therefore correspondingly excluded or included in the search).</td>
				</tr>
			</table>
			<p>
				The following example shows how a search for specific devices within a specific geographic area can be found. More precisely, it searches for a certain kind of PLC
				produced by a certain manufacturer, but only versions 1.0 &lt;= v &lt; 2.0 and with serial numbers beginning with 39487. The PLCs must also lie within latitude 33 ad 34
				degrees south and between longitude 70 and 72 west.
			</p>
			<example caption='Searching for Things'>
				<![CDATA[
   <iq type='get'
       from='curious@example.org/client'
       to='discovery.example.org'
       id='9'>
      <search xmlns='urn:xmpp:iot:discovery' offset='0' maxCount='20'>
          <strEq name='MAN' value='www.ktc.se'/>
          <strEq name='MODEL' value='IMC'/>
          <strMask name='SN' value='39487*' wildcard='*'/>
          <numRange name='V' min='1' minIncluded='true' max='2' maxIncluded='false'/>
          <numRange name='LON' min='-72' minIncluded='true' max='-70' maxIncluded='true'/>
          <numRange name='LAT' min='-34' minIncluded='true' max='-33' maxIncluded='true'/>
      </search>
   </iq>]]>
			</example>
			<p>
				The <strong>offset</strong> attribute tells the registry the number of responses to skip before returning found things. It provides a mechanism to page result sets
				that are too large to return in one response. the <strong>maxCount</strong> attribute contains the desired maximum number of things to return in the response. The
				registry can lower this value, if it decides the requested maximum number is too large.
			</p>
			<p>
				If tag names are not found corresponding to the names provided in the search, the result set will always be empty. There's a reserved tag named <strong>KEY</strong>
				that can be used to provide information shared only between things and their owners. If a search contains an operator referencing this tag name, the result set
				must also always be empty. Searches on <strong>KEY</strong> MUST never find things. Furthermore, search results must never return <strong>KEY</strong> tags.
			</p>
			<p>
				The registry returns any things found in a response similar to the following:
			</p>
			<example caption='Search result'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='curious@example.org/client'
       id='9'>
      <found xmlns='urn:xmpp:iot:discovery' more='false'>
          <thing owner='owner@example.org' jid='thing@example.org'>
             <str name='SN' value='394872348732948723'/>
             <str name='MAN' value='www.ktc.se'/>
             <str name='MODEL' value='IMC'/>
             <num name='V' value='1.2'/>
             <str name='CLASS' value='PLC'/>
             <num name='LON' value='-71.519722'/>
             <num name='LAT' value='-33.008055'/>
          </thing>
          ...
      </found>
   </iq>]]>
			</example>
			<p>
				If a Thing resides behind a concentrator, the response must contain those of the attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> that are required to access the Thing, as follows:
			</p>
			<example caption='Search result containing Thing behind a concentrator'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='curious@example.org/client'
       id='9'>
      <found xmlns='urn:xmpp:iot:discovery' more='false'>
          <thing owner='owner@example.org' jid='rack@example.org' nodeId='imc1' sourceId='MeteringTopology'>
             <str name='SN' value='394872348732948723'/>
             <str name='MAN' value='www.ktc.se'/>
             <str name='MODEL' value='IMC'/>
             <num name='V' value='1.2'/>
             <str name='CLASS' value='PLC'/>
             <num name='LON' value='-71.519722'/>
             <num name='LAT' value='-33.008055'/>
          </thing>
          ...
      </found>
   </iq>]]>
			</example>
			<p>
				If more results are available in the search (accessible by using the <strong>offset</strong> attribute in a new search), the <strong>more</strong> attribute is
				present with value <strong>true</strong>.
			</p>
			<p>
				<strong>Note:</strong> Meta Tag names are case insensitive. In this document, all tag names have been written using upper case letters.
			</p>
		</section2>
		<section2 topic='Unregistering Thing from Registry' anchor='unregister'>
			<p>
				A thing can unregister itself from the Registry. This can be done in an uninstallation procedure for instance. To unregister from the registry, it simply sends
				an un-registration request to the registry as follows.
			</p>
			<example caption='Unregister Thing'>
				<![CDATA[
   <iq type='set'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='10'>
      <unregister xmlns='urn:xmpp:iot:discovery'/>
   </iq>]]>
			</example>
			<p>
				If the Thing resides behind a concentrator, the request must contain those of the attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> that are required to access the Thing, as follows:
			</p>
			<example caption='Unregistring Thing behind concentrator'>
				<![CDATA[
   <iq type='set'
       from='rack@example.org/plcs'
       to='discovery.example.org'
       id='10'>
      <unregister xmlns='urn:xmpp:iot:discovery' nodeId='imc1' sourceId='MeteringTopology'/>
   </iq>]]>
			</example>
			<p>
				The registry always returns an empty response, simply to acknowledge the receipt of the request.
			</p>
			<example caption='Unregister Thing acknowledgement'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='10'/>]]>
			</example>
		</section2>
		<section2 topic='Disowning Thing' anchor='disown'>
			<p>
				The owner of a Thing can disown the Thing, returning it to a state without owner. This is done by sending the following request to the Thing Registry:
			</p>
			<example caption='Disowning Thing'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/phone'
       to='discovery.example.org'
       id='11'>
      <disown xmlns='urn:xmpp:iot:discovery' jid='thing@example.org'/>
   </iq>]]>
			</example>
			<p>
				If the Thing resides behind a concentrator, the request must contain those of the attributes <strong>nodeId</strong>, <strong>sourceId</strong>
				and <strong>cacheType</strong> that are required to access the Thing, as follows:
			</p>
			<example caption='Disowning Thing behind concentrator'>
				<![CDATA[
   <iq type='set'
       from='owner@example.org/phone'
       to='discovery.example.org'
       id='11'>
      <disown xmlns='urn:xmpp:iot:discovery' jid='rack@example.org/plcs' nodeId='imc1' sourceId='MeteringTopology'/>
   </iq>]]>
			</example>
			<p>
				If such a Thing is not found, or if the thing is not owned by the caller, an <strong>item-not-found</strong> error is returned, as follows:
			</p>
			<example caption='Failure to disown Thing - Not Found'>
				<![CDATA[
   <iq type='error'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='11'>
      <error type='cancel'>
         <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
      </error>
   </iq>]]>
			</example>
			<p>
				If such a Thing is found, and it is owned by the caller, but not online as a friend, the Thing cannot be disowned, since it would put the Thing in a state from which
				it cannot be re-claimed. Therefore, the Thing Registry must respond in the following manner:
			</p>
			<example caption='Failure to disown Thing - Offline'>
				<![CDATA[
   <iq type='error'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='11'>
      <error type='cancel'>
         <not-allowed xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
      </error>
   </iq>]]>
			</example>
			<p>
				Before returning a response to the caller, the Thing Registry informs the Thing it has been disowned.
				It does this, so the Thing can remove the friendship to the owner, and perform a new registration.
			</p>
			<example caption='Thing disowned in registry by owner'>
				<![CDATA[
   <iq type='set'
       from='discovery.example.org'
       to='thing@example.org/imc'
       id='12'>
      <disowned xmlns='urn:xmpp:iot:discovery'/>
   </iq>]]>
			</example>
			<p>
				If the Thing lies behind a concentrator, the disowned request would look as follows:
			</p>
			<example caption='Thing behind concentrator disowned in registry by owner'>
				<![CDATA[
   <iq type='set'
       from='discovery.example.org'
       to='rack@example.org/plcs'
       id='12'>
      <disowned xmlns='urn:xmpp:iot:discovery' nodeId='imc1' sourceId='MeteringTopology'/>
   </iq>]]>
			</example>
			<p>
				The Thing acknowledges that it has been disowned by returning an empty response, as follows:
			</p>
			<example caption='Acknowledging disownment'>
				<![CDATA[
   <iq type='result'
       from='thing@example.org/imc'
       to='discovery.example.org'
       id='12'/>]]>
			</example>
			<p>
				When receiving the acknowledgement from the Thing, the Thing is set as an unclaimed Thing in the Registry. Furthermore, all tags corresponding to the Thing are removed from the
				registry, and a random KEY tag is added of sufficient complexity to make sure other clients cannot claim the Thing by guessing. Finally, an empty response is returned, to 
				acknowledge that the Thing has been disowned, as follows:
			</p>
			<example caption='Thing disowned'>
				<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='owner@example.org/phone'
       id='11'/>]]>
			</example>
			<p>
				If for any reason, the Thing does not acknowledge the disowned request, or an error occurs, the Registry returns the same error as if the Thing would have been offline.
			</p>
		</section2>
	</section1>
	<section1 topic='Determining Support' anchor='support'>
		<p>
			If an entity is a Thing Registry and supports the protocol specified herein, it MUST advertise that fact by returning a feature of "urn:xmpp:iot:discovery" in response
			to &xep0030; information requests.
		</p>
		<example caption="Service discovery information request">
			<![CDATA[
   <iq type='get'
       from='device@example.org/device'
       to='provisioning@example.org'
       id='13'>
      <query xmlns='http://jabber.org/protocol/disco#info'/>
   </iq>]]>
		</example>
		<example caption="Service discovery information response">
			<![CDATA[
   <iq type='result'
       from='provisioning@example.org'
       to='device@example.org/device'
       id='13'>
     <query xmlns='http://jabber.org/protocol/disco#info'>
        ...
        <feature var='urn:xmpp:iot:discovery'/>
        ...
     </query>
   </iq>]]>
		</example>
		<p>
			To search for a Thing Registry hosted as a component on an XMPP Server, you first request a list of available components, as follows: 
		</p>
		<example caption="Checking if server supports components">
			<![CDATA[
   <iq from='device@example.org/device' to='example.org' type='get' id='14'>
      <query xmlns="http://jabber.org/protocol/disco#info"/>
   </iq>]]>
		</example>
		<example caption="Response confirming support for components">
			<![CDATA[
   <iq type="result" id="14" from="example.org" to="device@example.org/device">
      <query xmlns="http://jabber.org/protocol/disco#info">
         ...
         <feature var="http://jabber.org/protocol/disco#items"/>
         ...
      </query>
   </iq>]]>
		</example>
		<p>
			If components (items) are supported, a request for available components is made:
		</p>
		<example caption="Requesting list of server components">
			<![CDATA[
   <iq from='device@example.org/device' to='example.org' type='get' id='15'>
      <query xmlns="http://jabber.org/protocol/disco#items"/>
   </iq>]]>
		</example>
		<example caption="Response containing list of server components">
			<![CDATA[
   <iq type="result" id="15" from="example.org" to="995fab3dd759452ca9c370647323af0c@example.org/ebe2348e">
      <query xmlns="http://jabber.org/protocol/disco#items">
       ...
         <item jid="discovery.example.org" name="Registro de cosas"/>
       ...
      </query>
   </iq>]]>
		</example>
		<p>
			The client then loops through all components (items) and checks what features they support, until a Thing Registry is found:
		</p>
		<example caption="Service discovery information request made to each component">
			<![CDATA[
   <iq type='get'
       from='device@example.org/device'
       to='discovery.example.org'
       id='16'>
      <query xmlns='http://jabber.org/protocol/disco#info'/>
   </iq>]]>
		</example>
		<example caption="Service discovery information response from each component">
			<![CDATA[
   <iq type='result'
       from='discovery.example.org'
       to='device@example.org/device'
       id='16'>
      <query xmlns='http://jabber.org/protocol/disco#info'>
         ...
         <feature var='urn:xmpp:iot:discovery'/>
         ...
      </query>
   </iq>]]>
		</example>
	</section1>
	<section1 topic='Implementation Notes' anchor='impl'>
		<section2 topic='JID vs Component Thing Registries' anchor='jidvscomponent'>
			<p>
				A client must treat the connection between a Thing Registry differently if it is hosted as a client, having a JID, or if it is hosted as a Jabber Server Component.
				If it is hosted as a server component, there's no need for the thing to become friends with the Thing Registry. Messages and requests can be made directly to the
				server component without having to add it to the roster or request presence subscriptions. If the Thing Registry is hosted as a client, having a JID (@ in the address),
				the Thing Registry must be added to the roster of the client before the client can communicate with the Thing Registry.
			</p>
		</section2>
		<section2 topic='Meta Tags' anchor='tags'>
			<p>
				This document does not limit the number or names of tags used by Things to register meta information about themselves. However, it provides some general limits and defines
				the meaning of a few tags that must have the meanings specified herein.
			</p>
			<p>
				The maximum length of a tag name is <strong>32</strong> characters. Tag names must not include colon (:), hash sign (#) or white space characters. String tag values
				must not exceed 128 characters in length.
			</p>
			<p>
				The following table lists predefined tag names and their corresponding meanings.
			</p>
			<table caption='Predefined tags'>
				<tr>
					<th>Tag Name</th>
					<th>Type</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>ALT</td>
					<td>Numeric</td>
					<td>Altitude (meters)</td>
				</tr>
				<tr>
					<td>APT</td>
					<td>String</td>
					<td>Apartment associated with the Thing</td>
				</tr>
				<tr>
					<td>AREA</td>
					<td>String</td>
					<td>Area associated with the Thing</td>
				</tr>
				<tr>
					<td>BLD</td>
					<td>String</td>
					<td>Building associated with the Thing</td>
				</tr>
				<tr>
					<td>CITY</td>
					<td>String</td>
					<td>City associated with the Thing</td>
				</tr>
				<tr>
					<td>CLASS</td>
					<td>String</td>
					<td>Class of Thing</td>
				</tr>
				<tr>
					<td>COUNTRY</td>
					<td>String</td>
					<td>Country associated with the Thing</td>
				</tr>
				<tr>
					<td>KEY</td>
					<td>String</td>
					<td>Key, shared between thing and owner.</td>
				</tr>
				<tr>
					<td>LAT</td>
					<td>Numeric</td>
					<td>Latitude (degrees)</td>
				</tr>
				<tr>
					<td>LON</td>
					<td>Numeric</td>
					<td>Longitude (degrees)</td>
				</tr>
				<tr>
					<td>MAN</td>
					<td>String</td>
					<td>Domain name owned by the Manufacturer</td>
				</tr>
				<tr>
					<td>MLOC</td>
					<td>String</td>
					<td>Meter Location ID</td>
				</tr>
				<tr>
					<td>MNR</td>
					<td>String</td>
					<td>Meter Number</td>
				</tr>
				<tr>
					<td>MODEL</td>
					<td>String</td>
					<td>Name of Model</td>
				</tr>
				<tr>
					<td>NAME</td>
					<td>String</td>
					<td>Name associated with the Thing</td>
				</tr>
				<tr>
					<td>PURL</td>
					<td>String</td>
					<td>URL to product information for the Thing.</td>
				</tr>
				<tr>
					<td>REGION</td>
					<td>String</td>
					<td>Region associated with the Thing</td>
				</tr>
				<tr>
					<td>ROOM</td>
					<td>String</td>
					<td>Room associated with the Thing</td>
				</tr>
				<tr>
					<td>SN</td>
					<td>String</td>
					<td>Serial Number</td>
				</tr>
				<tr>
					<td>STREET</td>
					<td>String</td>
					<td>Street Name</td>
				</tr>
				<tr>
					<td>STREETNR</td>
					<td>String</td>
					<td>Street Number</td>
				</tr>
				<tr>
					<td>V</td>
					<td>Numeric</td>
					<td>Version Number</td>
				</tr>
			</table>
			<p>
				It is up to the Thing Registry to choose which tags it persists and which tags it doesn't. To avoid the possibility of malicious reporting of tags, some limit should be
				imposed on what tags are supported. As a minimum, a Thing Registry must support all predefined tags, as listed above.
			</p>
			<p>
				<strong>Note:</strong> Meta Tag names are case insensitive. In this document, all tag names have been written using upper case letters.
			</p>
		</section2>
		<section2 topic='Friendships between Things and Registry' anchor='friendships'>
			<p>
				In the case the Thing Registry is not the XMPP Server to which the Thing is connected, a friendship relationship between the Thing and the Thing Registry needs to be handled.
				To minimize the number of concurrent friends the Thing Registry needs to maintain, a Thing must only maintain an active friendship with the registry if it needs to
				communicate with the registry. This means that unless updating meta data frequently, the Thing must unfriend the Registry when done with its communication. If only
				updating meta data intermittently, the friendship can be reestablished when needed, and removed when done.
			</p>
		</section2>
	</section1>
	<section1 topic='Security Considerations' anchor='security'>
		<section2 topic='Jabber Components Protocol' anchor='jcp'>
			<p>
				The &xep0114; provides an elegant way to introduce external services as server components using a third port into the server (the first two being the client-to-server port
				and the server-to-server port). But since XEP-0114 is historical, meaning it is not guaranteed to conform to v1.0 of the XMPP specification, it has some serious security
				issues:
			</p>
			<ol>
				<li>It lacks SSL/TLS support, or the starttls element to switch to TLS after connecting. This makes it possible to sniff traffic in this port.</li>
				<li>It lacks SASL authentication. Instead a simple handshake is performed</li>
				<li>There is no way to actually verify that the server is the server. This makes it possible to create a simple Man-in-the-middle attack.</li>
			</ol>
			<p>
				For these reasons, it is not recommended that a Thing Registry service, publishing itself as a Jabber Server Component, does so from outside of the network. Instead, 
				the Thing Registry should be installed on the same server or on a server in the same local area network, so that the Jabber Component protocol port is closed to the
				Internet.
			</p>
			<p>
				Since it is not guaranteed that an XMPP Server operator allows installation of third party products (such as a Thing Registry), the option to host a Thing Registry using
				a normal JID is still available. It can be used in proof of concepts, etc. For scalability issues it is recommended that the Thing Registry be hosted as a Jabber Server
				Component when the population of Things grows.
			</p>
		</section2>
		<section2 topic='Hijacking predefined JIDs' anchor='hijackingjids'>
			<p>
				If using predefined user names when searching for a Thing Registry or Provisioning Server, care must be taken to which XMPP Server things connect.
				It might be possible for third parties to register these predefined account names, and pretend to be a Thing Registry or Provisioning Server and in this way hijack 
				unsuspecting Things. If installing things using this method of finding a Thing Registry or Provisioning Server, these accounts must be registered beforehand, to make 
				sure the things cannot be hijacked.
			</p>
		</section2>
		<section2 topic='Hijacking things in public areas' anchor='hijackingthings'>
			<p>
				The combination of visible key meta information (perhaps in a visible QR-code) and a factory default reset button on a Thing, opens up the possibility to hijack the Thing.
				To avoid this, at least one of the two should be removed after successful installation. Either the key meta information (QR-code) should be placed on the package or separate
				paper and not on the thing itself, or the factory default reset button should be sealed or hidden and only accessible by licensed maintenance personell. If using an electronic
				means to present the key meta information (for instance by displayed a QR-code on a display on the thing), care should be taken so that the information cannot be displayed
				without breaking a seal, or other means to protect the Thing.
			</p>
			<p>
				Regardless the above security measures, a Thing can be hijacked by a third party in the time window between successful installation of the device and until the correct owner
				has claimed ownership of the device. Minimizing this time window, and using a shared secret (KEY tag) between the Thing and its owner, decreases the possibility of getting the
				thing hijacked.
			</p>
		</section2>
		<section2 topic='Key meta information in searches' anchor='keysearch'>
			<p>
				Care should be taken what key meta information is used to accept an ownership claim. After a successful claim, this meta information is still available in the registry,
				at least until the Thing is removed from the registry. While public in the registry, the meta information can be searched and presented to third parties. Access to this
				information can help third parties to hijack Things, if they can reset them to factory default settings.
			</p>
			<p>
				To avoid this, the Thing can do three things after a successful ownership claim:
			</p>
			<ul>
				<li>
					Including a <strong>KEY</strong> tag in the key meta information. The <strong>KEY</strong> tag is not searchable nor presented in search results.
				</li>
				<li>
					Remove, truncate or change some key meta information after a successful ownership claim. Partial information is not sufficient for a successful ownership claim.
				</li>
				<li>
					Remove the Thing from the registry.
				</li>
			</ul>
		</section2>
		<section2 topic='KEY tag' anchor='key'>
			<p>
				The <strong>KEY</strong> tag is unique in that it is not searchable nor available is search results. For this reason it is ideal for providing secrets shared only
				between the Thing and the owner. By providing a sufficiently long KEY value in the key meta information required to claim the Thing, guessing the information even though
				the other meta information is available, will be sufficiently hard to make it practically impossible.
			</p>
			<p>
				Even though the <strong>KEY</strong> tag is not searchable or available in search results, it should be emptied by the Thing after a successful claim, just to make sure
				the key cannot be learned by looking into the database of the registry, or by some other means.
			</p>
		</section2>
		<section2 topic='Tag name spam' anchor='tagspam'>
			<p>
				This document does not limit tag names or the number of tags that can be used by Things. This opens up the possibility of tag spam. Malicious things could fill the database
				of the registry by reporting random tag names until the database is full.
			</p>
			<p>
				To prevent such malicious attacks, the registry could limit the tags it allows to be stored in the database. The registry must however allow the storage of the predefined
				tag names defined in this document. If it has a configurable list of approved tags that can be stored, or if it allows any tags is an implementation decision.
			</p>
		</section2>
		<section2 topic='External services for creating QR-codes' anchor='externalqr'>
			<p>
				If using external services when creating QR-codes, like the Google Charts API used in this document, make sure HTTPS is used and certificates validated. If HTTP is used,
				meta-data tags used in Thing Registry registrations can be found out by sniffing the network, making it possible to hijack the corresponding devices.
			</p>
		</section2>
		<section2 topic='DHCP Security Considerations' anchor='dhcpsec'>
			<p>TBD</p>
			<!-- TODO -->
		</section2>
		<section2 topic='DNS Security Considerations' anchor='dnssec'>
			<p>TBD</p>
			<!-- TODO -->
		</section2>
		<section2 topic='UPnP Security Considerations' anchor='upnpsec'>
			<p>TBD</p>
			<!-- TODO -->
		</section2>
	</section1>
	<section1 topic='IANA Considerations' anchor='iana'>
		<p>This document requires no interaction with &IANA;.</p>
	</section1>
	<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
		<p>
			The <link url="#schema">protocol schema</link> needs to be added to the list of <link url="http://xmpp.org/resources/schemas/">XMPP protocol schemas</link>.
		</p>
	</section1>
	<section1 topic='XML Schema' anchor='schema'>
		<code>
			<![CDATA[
<?xml version='1.0' encoding='UTF-8'?>
<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:iot:discovery'
    xmlns='urn:xmpp:iot:discovery'
    elementFormDefault='qualified'>
 
    <xs:element name='register' type='Register'/>
    <xs:element name='mine' type='Mine'/>
    <xs:element name='update' type='Update'/>
 
    <xs:element name='claimed' type='Claimed'/>
    <xs:element name='remove' type='Jid'/>
    <xs:element name='removed' type='NodeInfo'/>
    <xs:element name='unregister' type='NodeInfo'/>
    <xs:element name='disown' type='Jid'/>
    <xs:element name='disowned' type='NodeInfo'/>
 
    <xs:element name='search'>
        <xs:complexType>
            <xs:choice minOccurs='1' maxOccurs='unbounded'>
                <xs:element name='strEq' type='StrTag'/>
                <xs:element name='strNEq' type='StrTag'/>
                <xs:element name='strGt' type='StrTag'/>
                <xs:element name='strGtEq' type='StrTag'/>
                <xs:element name='strLt' type='StrTag'/>
                <xs:element name='strLtEq' type='StrTag'/>
                <xs:element name='strRange' type='StrRange'/>
                <xs:element name='strNRange' type='StrRange'/>
                <xs:element name='strMask'>
                    <xs:complexType>
                        <xs:attribute name='name' type='xs:string' use='required'/>
                        <xs:attribute name='value' type='xs:string' use='required'/>
                        <xs:attribute name='wildcard' type='xs:string' use='required'/>
                    </xs:complexType>
                </xs:element>
                <xs:element name='numEq' type='NumTag'/>
                <xs:element name='numNEq' type='NumTag'/>
                <xs:element name='numGt' type='NumTag'/>
                <xs:element name='numGtEq' type='NumTag'/>
                <xs:element name='numLt' type='NumTag'/>
                <xs:element name='numLtEq' type='NumTag'/>
                <xs:element name='numRange' type='NumRange'/>
                <xs:element name='numNRange' type='NumRange'/>
            </xs:choice>
            <xs:attribute name='offset' type='xs:nonNegativeInteger' use='optional' default='0'/>
            <xs:attribute name='maxCount' type='xs:positiveInteger' use='optional'/>
        </xs:complexType>
    </xs:element>
 
    <xs:element name='found'>
        <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                <xs:element name='thing'>
                    <xs:complexType>
                        <xs:choice minOccurs='0' maxOccurs='unbounded'>
                            <xs:element name='str' type='StrTag'/>
                            <xs:element name='num' type='NumTag'/>
                        </xs:choice>
                        <xs:attribute name='owner' type='xs:string' use='required'/>
                        <xs:attribute name='jid' type='xs:string' use='required'/>
                        <xs:attributeGroup ref='nodeInfo'/>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name='more' type='xs:boolean' use='optional' default='false'/>
        </xs:complexType>
    </xs:element>
 
    <xs:attributeGroup name='nodeInfo'>
        <xs:attribute name='nodeId' type='xs:string' use='optional'/>
        <xs:attribute name='sourceId' type='xs:string' use='optional'/>
        <xs:attribute name='cacheType' type='xs:string' use='optional'/>
    </xs:attributeGroup>
     
    <xs:complexType name='MetaData'>
        <xs:choice minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='str' type='StrTag'/>
            <xs:element name='num' type='NumTag'/>
        </xs:choice>
    </xs:complexType>
 
    <xs:complexType name='MetaDataNodeInfo'>
        <xs:complexContent>
            <xs:extension base='MetaData'>
                <xs:attributeGroup ref='nodeInfo'/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='Register'>
        <xs:complexContent>
            <xs:extension base='MetaDataNodeInfo'>
                <xs:attribute name='selfOwned' type='xs:boolean' use='optional' default='false'/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='Mine'>
        <xs:complexContent>
            <xs:extension base='MetaDataNodeInfo'>
                <xs:attribute name='public' type='xs:boolean' use='optional' default='true'/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='Update'>
        <xs:complexContent>
            <xs:extension base='MetaDataNodeInfo'>
                <xs:attribute name='jid' type='xs:string' use='optional'/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='Claimed'>
        <xs:complexContent>
            <xs:extension base='Jid'>
                <xs:attribute name='public' type='xs:boolean' use='optional' default='false'/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='Jid'>
        <xs:attribute name='jid' type='xs:string' use='required'/>
        <xs:attributeGroup ref='nodeInfo'/>
    </xs:complexType>
 
    <xs:complexType name='NodeInfo'>
        <xs:attributeGroup ref='nodeInfo'/>
    </xs:complexType>
 
    <xs:complexType name='StrTag'>
        <xs:attribute name='name' type='xs:string' use='required'/>
        <xs:attribute name='value' type='xs:string' use='required'/>
    </xs:complexType>
 
    <xs:complexType name='NumTag'>
        <xs:attribute name='name' type='xs:string' use='required'/>
        <xs:attribute name='value' type='xs:double' use='required'/>
    </xs:complexType>
 
    <xs:complexType name='StrRange'>
        <xs:attribute name='name' type='xs:string' use='required'/>
        <xs:attribute name='min' type='xs:string' use='required'/>
        <xs:attribute name='minIncluded' type='xs:boolean' use='optional' default='true'/>
        <xs:attribute name='max' type='xs:string' use='required'/>
        <xs:attribute name='maxIncluded' type='xs:boolean' use='optional' default='true'/>
    </xs:complexType>
 
    <xs:complexType name='NumRange'>
        <xs:attribute name='name' type='xs:string' use='required'/>
        <xs:attribute name='min' type='xs:double' use='required'/>
        <xs:attribute name='minIncluded' type='xs:boolean' use='optional' default='true'/>
        <xs:attribute name='max' type='xs:double' use='required'/>
        <xs:attribute name='maxIncluded' type='xs:boolean' use='optional' default='true'/>
    </xs:complexType>
 
</xs:schema>]]>
		</code>
	</section1>
	<section1 topic='For more information' anchor='moreinfo'>
		<p>
			For more information, please see the following resources:
		</p>
		<ul>
			<li>
				<p>
					The <link url='http://wiki.xmpp.org/web/Tech_pages/SensorNetworks'>Sensor Network section of the XMPP Wiki</link> contains further information about the
					use of the sensor network XEPs, links to implementations, discussions, etc.
				</p>
			</li>
			<li>
				<p>
					The XEP's and related projects are also available on <link url='https://github.com/joachimlindborg/'>github</link>, thanks to Joachim Lindborg.
				</p>
			</li>
			<li>
				<p>
					A presentation giving an overview of all extensions related to Internet of Things can be found here:
					<link url='http://prezi.com/esosntqhewhs/iot-xmpp/'>http://prezi.com/esosntqhewhs/iot-xmpp/</link>.
				</p>
			</li>
		</ul>
	</section1>
	<section1 topic='Acknowledgements' anchor='ack'>
		<p>
			Thanks to Eelco Cramer, Henrik Svedlund, Ivan Vučica, Joachim Lindborg, Joakim Eriksson, Joakim Ramberg, Johannes Hund, Karin Forsell, Kevin Smith, Lance Stout, Lars Åkerskog, 
			Olof Zandrén, Philipp Hancke, Steffen Larsen, Teemu Väisänen and Yusuke Doi for all valuable feedback.
		</p>
	</section1>
</xep>
