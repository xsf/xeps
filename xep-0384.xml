<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM "xep.ent">
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
  <title>OMEMO Encryption</title>
  <abstract>This specification defines a protocol for end-to-end encryption in one-on-one chats that may have multiple clients per account.</abstract>
  &LEGALNOTICE;
  <number>0384</number>
  <status>Experimental</status>
  <type>Standards Track</type>
  <sig>Standards</sig>
  <approver>Council</approver>
  <dependencies>
    <spec>XMPP Core</spec>
    <spec>XEP-0163</spec>
  </dependencies>
  <supersedes/>
  <supersededby/>
  <shortname>OMEMO</shortname>
  <author>
    <firstname>Andreas</firstname>
    <surname>Straub</surname>
    <email>andy@strb.org</email>
    <jid>andy@strb.org</jid>
  </author>
  <revision>
    <version>0.2</version>
    <date>2017-03-25</date>
    <initials>as</initials>
    <remark>
      <p>Use Double Ratchet and X3DH</p>
      <p>Describe use-cases more precisely</p>
      <p>Add clarifying business rules</p>
      <p>Use kebab-case throughout</p>
    </remark>
  </revision>
  <revision>
    <version>0.1</version>
    <date>2016-12-07</date>
    <initials>XEP Editor: ssw</initials>
    <remark><p>Initial version approved by the council.</p></remark>
  </revision>
  <revision>
    <version>0.0.2</version>
    <date>2016-09-22</date>
    <initials>ssw, dg</initials>
    <remark><p>Depend on Olm instead of Axolotl.</p></remark>
  </revision>
  <revision>
    <version>0.0.1</version>
    <date>2015-10-25</date>
    <initials>as</initials>
    <remark><p>First draft.</p></remark>
  </revision>
</header>
<section1 topic='Introduction' anchor='intro'>
  <section2 topic='Motivation' anchor='intro-motivation'>
    <p>
      There are two main end-to-end encryption schemes in common use in the XMPP
      ecosystem, Off-the-Record (OTR) messaging (&xep0364;) and OpenPGP
      (&xep0027;). OTR has significant usability drawbacks for inter-client
      mobility. As OTR sessions exist between exactly two clients, the chat
      history will not be synchronized across other clients of the involved
      parties. Furthermore, OTR chats are only possible if both participants are
      currently online, due to how the rolling key agreement scheme of OTR
      works. OpenPGP, while not suffering from these mobility issues, does not
      provide any kind of forward secrecy and is vulnerable to replay attacks.
      Additionally, PGP over XMPP uses a custom wireformat which is defined by
      convention rather than standardization, and involves quite a bit of
      external complexity.
    </p>
    <p>
      This XEP defines a protocol that leverages &double-ratchet; encryption
      with &x3dh; Key Agreement to provide
      multi-end to multi-end encryption, allowing messages to be synchronized
      securely across multiple clients, even if some of them are offline. &double-ratchet;
      and &x3dh; are cryptographic protocols designed by Trevor Perrin
      and Moxie Marlinspike and were first published under the name Axolotl.
    </p>
  </section2>
  <section2 topic='Overview' anchor='intro-overview'>
    <p>
      The general idea behind this protocol is to maintain separate,
      long-standing &double-ratchet; sessions with each device of each contact
      (as well as with each of our own other devices), which are used as secure key
      transport channels. In this scheme, each message is encrypted with a
      fresh, randomly generated encryption key. An encrypted header is added to
      the message for each device that is supposed to receive it. These headers
      simply contain the key that the payload message is encrypted with, and
      they are separately encrypted using the session corresponding to the
      counterpart device. The encrypted payload is sent together with the
      headers as a &lt;message&gt; stanza. Individual recipient devices can
      decrypt the header item intended for them, and use the contained payload
      key to decrypt the payload message.
    </p>
    <p>
      As the encrypted payload is common to all recipients, it only has to be
      included once, reducing overhead. Furthermore, &double-ratchet;'s transparent handling
      of messages that were lost or received out of order, as well as those sent
      while the recipient was offline, is maintained by this protocol. As a
      result, in combination with &xep0280; and &xep0313;, the desired property
      of inter-client history synchronization is achieved.
    </p>
    <p>
      The cryptographic algorithms used by OMEMO are collectively referred to as
      the OMEMO Double Ratchet (ODR). In order to make the protocol independent
      from specific server-side support, &xep0163; (PEP) is used to fill the 'server'
      role of &x3dh;.
    </p>
  </section2>
</section1>
<section1 topic='Requirements' anchor='reqs'>
    <ul>
      <li>Provide forward secrecy</li>
      <li>Ensure chat messages can be deciphered by all (capable) clients of both parties</li>
      <li>Be usable regardless of the participants' online statuses</li>
      <li>Provide a method to exchange auxilliary keying material. This could for example be used to secure encrypted file transfers.</li>
    </ul>
</section1>
<section1 topic='Glossary' anchor='glossary'>
  <section2 topic='General Terms' anchor='glossary-general'>
    <dl>
      <di>
        <dt>
          Device
        </dt><dd>
          A communication end point, i.e. a specific client instance
        </dd>
      </di>
      <di>
        <dt>
          OMEMO element
        </dt><dd>
          An &lt;encrypted&gt; element in the urn:xmpp:omemo:1 namespace. Can be
          either MessageElement or a KeyTransportElement
        </dd>
      </di>
      <di>
        <dt>
          OMEMO Message Element
        </dt><dd>
          An OMEMO Element that contains a chat message. Its &lt;payload&gt;,
          when decrypted, corresponds to a &lt;message&gt;'s &lt;body&gt;.
        </dd>
      </di>
      <di>
        <dt>
          OMEMO Key Transport Element
        </dt><dd>
        An OMEMO Element that does not have a &lt;payload&gt;. It contains a
          fresh encryption key, which can be used for purposes external to this
          XEP.
        </dd>
      </di>
      <di>
        <dt>
          OMEMO Ratchet Update Message
        </dt><dd>
          A &lt;message&gt; containing an OMEMO Key Transport Element but no
          other payload or reference to a payload.
        </dd>
      </di>
      <di>
        <dt>
          matching element
        </dt><dd>
          An &lt;envelope&gt; or &lt;init-envelope&gt; element with an rid matching our own
          device ID
        </dd>
      </di>
      <di>
        <dt>
          Bundle
        </dt><dd>
          A collection of publicly accessible data that can be used to build a
          session with a device, namely its public Identity-key, a signed-pre-key
          with corresponding signature, and a list of (single use) pre-keys.
        </dd>
      </di>
      <di>
        <dt>
          active device
        </dt><dd>
          Any device whose ID is currently announced in the devicelist
        </dd>
      </di>
      <di>
        <dt>
          inactive device
        </dt><dd>
          Any device whose ID is NOT currently announced in the devicelist
        </dd>
      </di>
      <di>
        <dt>
          rid
        </dt><dd>
          The device id of the intended recipient of the containing envelope
        </dd>
      </di>
      <di>
        <dt>
          sid
        </dt><dd>
          The device id of the sender of the containing OMEMO element
        </dd>
      </di>
    </dl>
  </section2>
  <section2 topic='ODR-specific' anchor='glossary-odr'>
    <p>
      The terminology of ODR is chosen to be analogous to the &double-ratchet;
      and &x3dh; specifications wherever possible. ODR protocol messages are
      referred to as envelopes in order to distinguish them from XMPP
      &lt;message&gt;s.
    </p>
    <dl>
      <di>
        <dt>
          identity-key
        </dt><dd>
          Per-device public/private key pair used to authenticate communications
        </dd>
      </di>
      <di>
        <dt>
          pre-key
        </dt><dd>
          A Diffie-Hellman public key, published in bulk and ahead of time
        </dd>
      </di>
      <di>
        <dt>
          signed-pre-key
        </dt><dd>
          A Diffie-Hellman public key and a signature on this key (using the
          identity-key), published ahead of time and regularly rotated
        </dd>
      </di>
      <di>
        <dt>
          omemo-envelope
        </dt><dd>
          An ODR-encrypted envelope containing key material
        </dd>
      </di>
      <di>
        <dt>
          init-omemo-envelope
        </dt><dd>
          An ODR-encrypted envelope containing key material. This envelope
          includes the initial key exchange which is used to transparently build
          sessions with the first exchanged envelope.
        </dd>
      </di>
      <di>
        <dt>
          pkid
        </dt><dd>
          The ID of the counterpart's pre-key that was selected for an
          init-omemo-envelope
        </dd>
      </di>
      <di>
        <dt>
          spkid
        </dt><dd>
          The ID of the counterpart's signed-pre-key that was selected for an
          init-omemo-envelope
        </dd>
      </di>
      <di>
        <dt>
          ek
        </dt><dd>
          The own ephemeral key that was used for the init-omemo-envelope
        </dd>
      </di>
      <di>
        <dt>
          ik
        </dt><dd>
          The own identity-key
        </dd>
      </di>
      <di>
        <dt>
          dhs
        </dt><dd>
          The own sending ratchet DH public key
        </dd>
      </di>
      <di>
        <dt>
          pn
        </dt><dd>
          The previous chain length for a (init-)omemo-envelope
        </dd>
      </di>
      <di>
        <dt>
          n
        </dt><dd>
          The envelope number of a (init-)omemo-envelope
        </dd>
      </di>
    </dl>
  </section2>
</section1>

<section1 topic='OMEMO Double Ratchet' anchor='odr'>
  <p>
    The OMEMO Double Ratchet (ODR) uses the &double-ratchet; algorithm (WITHOUT
    header encryption) with &x3dh; key agreement. For details on these, see the
    respective specifications.
  </p>

  <section2 topic='Parameters' anchor='odr-parameters'>
    <p>
      ODR uses &curve25519;, SHA-256, HKDF, and AES-256-CBC-HMAC as suggested in
      Section 5.2 of the &double-ratchet; specification. The same primitives are
      used for &x3dh; where applicable. The info string for the key agreement is
      'OMEMO X3DH' and the info string for the ratchet is 'OMEMO Double
      Ratchet'.
    </p>
  </section2>

  <section2 topic='Wire format' anchor='odr-wire'>

    <p>
      ODR envelopes are serialized into an XML structure. These make up the
      headers of OMEMO messages.
    </p>

    <example caption='An ODR element for an omemo-envelope'><![CDATA[
<envelope rid='123' n='2' pn='1' dhs='BASE64ENCODED...'>BASE64ENCODED</envelope>
]]></example>

    <p>
      Init-omemo-envelopes include additional attributes for pkid, spkid, ek,
      and ik.
    </p>

    <example caption='An ODR element for a init-omemo-envelope'><![CDATA[
<init-envelope rid='123' pkid='1' spkid='1' ek='BASE64ENCODED...' ik='BASE64ENCODED' n='2' pn='0' dhs='BASE64ENCODED...'>BASE64ENCODED</init-envelope>
]]></example>

  </section2>
</section1>

<section1 topic='Use Cases' anchor='usecases'>
  <section2 topic='Setup' anchor='usecases-setup'>
    <p>
      The first thing that needs to happen if a client wants to start using
      OMEMO is they need to generate an IdentityKey and a Device ID. The
      IdentityKey is a &curve25519; public/private Key pair. The Device ID is a
      randomly generated integer between 1 and 2^31 - 1.
    </p>
  </section2>
  <section2 topic='Discovering peer support' anchor='usecases-discovering'>
    <p>
      In order to determine whether a given contact has devices that support
      OMEMO, the devicelist node in PEP is consulted. Devices MUST subscribe to
      'urn:xmpp:omemo:1:devicelist' via PEP, so that they are informed whenever
      their contacts add a new device. They MUST cache the most up-to-date
      version of the devicelist.
    </p>
    <example caption='Devicelist update received by subscribed clients'><![CDATA[
<message from='juliet@capulet.lit'
         to='romeo@montague.lit'
         type='headline'
         id='update_01'>
  <event xmlns='http://jabber.org/protocol/pubsub#event'>
    <items node='urn:xmpp:omemo:1:devicelist'>
      <item>
        <list xmlns='urn:xmpp:omemo:1'>
          <device id='12345' />
          <device id='4223' />
        </list>
      </item>
    </items>
  </event>
</message>]]></example>
  </section2>
  <section2 topic='Announcing support' anchor='usecases-announcing'>
    <p>
      In order for other devices to be able to initiate a session with a given
      device, it first has to announce itself by adding its device ID to the
      devicelist PEP node.
    </p>
    <example caption='Adding the own device ID to the list'><![CDATA[
<iq from='juliet@capulet.lit' type='set' id='announce1'>
  <pubsub xmlns='http://jabber.org/protocol/pubsub'>
    <publish node='urn:xmpp:omemo:1:devicelist'>
      <item>
        <list xmlns='urn:xmpp:omemo:1'>
          <device id='12345' />
          <device id='4223' />
          <device id='31415' />
        </list>
      </item>
    </publish>
  </pubsub>
</iq>]]></example>
    <p>
      Furthermore, a device MUST announce it's identity-key, a signed-pre-key,
      and a list of pre-keys in a separate, per-device PEP node.
    </p>
    <example caption='Announcing bundle information'><![CDATA[
<iq from='juliet@capulet.lit' type='set' id='announce2'>
  <pubsub xmlns='http://jabber.org/protocol/pubsub'>
    <publish node='urn:xmpp:omemo:1:bundles:31415'>
      <item>
        <bundle xmlns='urn:xmpp:omemo:1'>
          <signed-pre-key-public spkid='1'>
            BASE64ENCODED...
          </signed-pre-key-public>
          <signed-pre-key-signature>
            BASE64ENCODED...
          </signed-pre-key-signature>
          <identity-key>
            BASE64ENCODED...
          </identity-key>
          <pre-keys>
            <pre-key-public pkid='1'>
              BASE64ENCODED...
            </pre-key-public>
            <pre-key-public pkid='2'>
              BASE64ENCODED...
            </pre-key-public>
            <pre-key-public pkid='3'>
              BASE64ENCODED...
            </pre-key-public>
            <!-- ... -->
          </pre-keys>
        </bundle>
      </item>
    </publish>
  </pubsub>
</iq>]]></example>
  </section2>
  <section2 topic='Building a session' anchor='usecases-building'>
    <p>In order to build a session with a device, their bundle information is fetched.</p>
    <example caption="Fetching a device's bundle information"><![CDATA[
<iq type='get'
    from='romeo@montague.lit'
    to='juliet@capulet.lit'
    id='fetch1'>
  <pubsub xmlns='http://jabber.org/protocol/pubsub'>
    <items node='urn:xmpp:omemo:1:bundles:31415'/>
  </pubsub>
</iq>]]></example>
    <p>
      A random pre-key-public entry is selected, and used to build an ODR session.
    </p>
  </section2>
  <section2 topic='Sending a message' anchor='usecases-messagesend'>
    <p>
      In order to send a chat message, its &lt;body&gt; first has to be
      encrypted. The client MUST generate a fresh 32-byte secret. This secret is
      used in an AES-256-CBC and HMAC-SHA-256 based AEAD scheme identical to the
      encryption in the ODR. The HKDF info string is 'OMEMO Payload'. For
      details see Section 5.2 of the &double-ratchet; specification. However the
      HMAC output is NOT appended to the ciphertext.  Rather, the HMAC output is
      appended to the 32-byte secret. For each intended recipient device, i.e.
      both own trusted devices as well as trusted devices associated with the
      contact, this secret/HMAC combination is encrypted using the
      corresponding long-standing ODR session. Each encrypted secret/HMAC
      combination is tagged with the recipient device's ID. This is all
      serialized into an OMEMO Message Element, which is transmitted in a
      &lt;message&gt; as follows:
    </p>
    <example caption="Sending a message"><![CDATA[
<message to='juliet@capulet.lit' from='romeo@montague.lit' id='send1'>
  <encrypted xmlns='urn:xmpp:omemo:1'>
    <header sid='27183'>`
      <envelope rid='31415' n='20' pn='5' dhs='BASE64ENCODED...'>BASE64ENCODED</envelope>
      <init-envelope rid='12321' pkid='1' spkid='1' ek='BASE64ENCODED...' ik='BASE64ENCODED' n='2' pn='0' dhs='BASE64ENCODED...'>BASE64ENCODED</init-enveope>
      <!-- ... -->
      <iv>BASE64ENCODED...</iv>
    </header>
    <payload>BASE64ENCODED</payload>
  </encrypted>
  <store xmlns='urn:xmpp:hints'/>
</message>]]></example>
  </section2>
  <section2 topic='Sending a key' anchor='usecases-keysend'>
    <p>
      The client may wish to transmit keying material to the contact for
      external use (e.g. file transfer). This works analogously to sending a
      regular message. A secret is generated and keys are derived (using the
      info string 'OMEMO Payload') as before.  The externally transmitted data
      is encrypted and authenticated using the same CBC-HMAC AEAD scheme.  The
      HMAC is then appended to the secret, and they are separately encrypted
      for each intended recipient device using the corresponding long-standing
      ODR sessions and tagged with the respective rids.  The resulting
      collection of envelopes is serialized into a OMEMO Key Transport Element
      which omits the &lt;payload&gt;.
    </p>
    <example caption="Sending a key"><![CDATA[
<encrypted xmlns='urn:xmpp:omemo:1'>
  <header sid='27183'>
    <envelope rid='31415' n='21' pn='5' dhs='BASE64ENCODED...'>BASE64ENCODED</envelope>
    <init-envelope rid='12321' pkid='1' spkid='1' ek='BASE64ENCODED...' ik='BASE64ENCODED' n='3' pn='0' dhs='BASE64ENCODED...'>BASE64ENCODED</init-envelope>
    <!-- ... -->
    <iv>BASE64ENCODED...</iv>
  </header>
</encrypted>]]></example>
    <p>This OMEMO Key Transport Element can then be sent over any applicable transport mechanism.</p>
  </section2>
  <section2 topic='Receiving a message' anchor='usecases-receiving'>
    <p>
      When an OMEMO element is received, the client first processes the
      &lt;header&gt;. It MUST check whether there is at least one envelope with
      an rid attribute matching its own device ID ("matching elements"). If
      this is not the case, the element MUST be silently discarded. There might
      also be more than one matching element, as device IDs are only unique on
      a per-account basis, so the recipient MUST perform the following steps
      for each matching element until one has been processed successfully.
    </p>
    <section3 topic='Processing the matching elements' anchor='usecase-receiving-keys'>
      <p>
        If the element is an init-omemo-envelope, a new session is built from
        this received element. If this fails (e.g. because the pkid is not
        valid), the client MUST try to continue with the next matching element.
        If it succeeds, the client SHOULD then republish their bundle
        information, replacing the used pre-key, such that it won't be used
        again by a different client. The client MUST delete the private key
        belonging to the pre-key after use.  If the client already had an ODR
        session with the sender's device, it MUST replace this session with the
        newly built session.
      </p>
      <p>
        If the element is an omemo-envelope, and the client has a session
        with the sender's device, it tries to decrypt the omemo-envelope using this
        session. If the decryption fails, the client MUST try to continue with the
        next matching element.
      </p>
      <p>
        If there are no more matching elements left to try, the OMEMO element
        MUST be silently discarded.
      </p>
    </section3>
    <p>
      After having successfully processed one matching element, the client
      extracts the secret and HMAC. It then derives 32-byte authentication and
      encryption keys as well as the 16-byte IV from the secret using
      HKDF-SHA-256 as before. It is now done processing the &lt;header&gt;, and
      can continue with the rest of the OMEMO element.
    </p>
    <p>
      If the OMEMO element contains a &lt;payload&gt;, it is an OMEMO Message
      Element. The client MUST first try to verify the HMAC on the base64 encoded
      contents with HMAC-SHA-256 using the authentication key. If this is
      successful, the client can then attempt to decrypt the contents with
      AES-256-CBC using the IV and encryption key. If either authentication or
      decryption fails, the client MUST silently discard the OMEMO Message
      Element.  If both succeed, the decrypted contents are treated as the
      &lt;body&gt; of the received message.
    </p>
    <p>
      If the OMEMO element does not contain a &lt;payload&gt;, the client has
      received a OMEMO Key Transport Element. The key material derived from the
      matching element can then be used for other purposes (e.g. encrypted
      file transfer).  If the OMEMO Key Transport Element was received in an
      otherwise empty &lt;message&gt;, i.e. this is an OMEMO Ratchet Update
      Message, and therefore is of no use by itself, the client MUST ensure
      that the ODR header is neverthelesss processed locally before the Omemo
      element is silently discarded. This ensures that the ratchet is still
      advanced (or, in the case of a init-omemo-envelope, the session
      replaced entirely).
    </p>
  </section2>
  <section2 topic='Removing OMEMO support' anchor='uninstall'>
    <p>
      If a device wishes to remove OMEMO support, e.g. because the user is
      removing the account from the client, it MUST remove itself from the
      devicelist and SHOULD remove its bundle. This will turn it into an
      inactive device, which implicitly notifies all counterparts not to address
      messages to it any more.
    </p>
  </section2>
</section1>
<section1 topic='Business Rules' anchor='rules'>
  <p>
    Before publishing a freshly generated Device ID for the first time, a client
    MUST check whether that Device ID already exists for this account by
    consulting its own devicelist, and if so, generate a new one.
  </p>
  <p>
    A client MUST ensure that its bundle information is correct at least every time
    it logs in. To this end, it SHOULD simply re-publish the entire bundle, as it would
    otherwise have to query the node and then also verify all the information contained
    within.
  </p>
  <p>
    The announcement step presents the risk of introducing a race condition: Two
    devices might simultaneously try to announce themselves in the device list,
    unaware of the other's existence. The second device would overwrite the
    first one. To mitigate this, devices MUST check that their own device ID is
    contained in the list whenever they receive a PEP update from their own
    account. If they have been removed, they MUST reannounce themselves.
    Furthermore, devices MAY also want to re-publish their own bundle at this
    point in order to deal with cases where PEP was purged entirely (either
    accidentally or maliciously). This part is OPTIONAL, however, as the
    additional overhead in traffic caused by this mechanism might be undesirable
    for constrained devices (e.g. mobile).
  </p>
  <p>
    If the device is repeatedly removed from the devicelist, or its bundle is
    repeatedly removed or corrupted, the client SHOULD notify the user of this fact.
    It MAY also stop attempting to correct the PEP records in order to conserve
    resources on constrained devices.
  </p>
  <p>
    The size of the list of pre-keys in the bundle is a tradeoff between
    preventing potential collisions and reducing overhead. If the list is very
    small, multiple contacts have a higher chance of selecting the same pre-key
    to initiate a session with this client (e.g. if they both build sessions
    simultaneously, before the client has a chance to replace the used pre-keys,
    or if the client is offline for a prolonged period of time). However, as the
    bundle has to be re-published regularly, a large list of pre-keys would
    increase the overhead, which might be disadvantageous for constrained
    devices. The impact of pre-key collisions can further be reduced by
    postponing removal of pre-key private keys during &xep0313; catch-up phases
    as described further down. It is therefore RECOMMENDED to include 20
    pre-keys in the list, but implementors should make their own determination
    in light of the targeted use-case of their client.
  </p>
  <p>
    Clients MUST ensure that their signed-pre-key is replaced regularly, e.g. by
    publishing a new one once a week. It is RECOMMENDED to (additionally)
    replace it every time a bundle is published, i.e. after log-ins and having
    received init-omemo-envelopes. The reason for this is that the client has
    to transmit its signed-pre-key anyway, so it might as well push a new one.
  </p>
  <p>
    Clients SHOULD NOT immediately fetch the bundle and build a session as soon
    as a new device is announced. Before the first message is exchanged, the
    recipient does not know which pre-key has been used (or, in fact, that any
    pre-key was used at all). As they have not had a chance to remove the used
    pre-key from their bundle announcement, this could lead to collisions where
    two (or more) different other devices pick the same pre-key to build a
    session with a specific device. As each pre-key SHOULD only be used once,
    the party that sends their initial init-omemo-envelope later loses this
    race condition. This means that they think they have a valid session with
    the contact, when in reality their messages MAY be ignored by the other
    end. By postponing building sessions, the chance of such issues occurring
    can be drastically reduced. It is RECOMMENDED to construct new sessions only
    immediately before sending a message.
  </p>
  <p>
    As there are no explicit error messages in this protocol, if a client does
    receive a init-omemo-envelope using an invalid pre-key, they SHOULD
    respond with an OMEMO Ratchet Update Message using a
    init-omemo-envelope.  By building a new session with the original sender
    this way, the invalid session of the original sender will be overwritten on
    their end with this newly created, valid session.
  </p>
  <p>
    If a init-omemo-envelope is received as part of a &xep0313; catch-up and
    used to establish a new session with the sender, the client SHOULD postpone
    deletion of the private key corresponding to the used pre-key until after
    MAM catch-up is completed. After completing catch-up, the client MUST then
    also send an OMEMO Ratchet Update Message using a init-omemo-envelope
    before sending any payloads using this session, to trigger re-keying. (as
    above) This practice can mitigate the previously mentioned race condition
    by preventing message loss.
  </p>
  <p>
    As the asynchronous nature of OMEMO enables currently offline devices to
    decrypt received messages at a later time, clients MUST include a &xep0334;
    &lt;store /&gt; hint in their OMEMO messages. Otherwise, server
    implementations of &xep0313; will generally not retain OMEMO messages,
    since they do not contain a &lt;body /&gt;
  </p>
  <p>
    When sending messages, clients SHOULD only add envelopes for active
    devices. They MAY also include devices that have only "recently" (e.g.  the
    past 24 hours or the past week) been marked as inactive in order to give
    those devices a chance to reannounce themselves and not lose any history in
    the meantime. Clients SHOULD retain ODR sessions for inactive devices, but
    they SHOULD eventually delete them after a certain period of inactivity
    (e.g. a month). Additionally, clients MAY regard devices from which they
    have not received any envelopes, including OMEMO Ratchet Update Messages
    ("heartbeats"), in a long time as inactive.
  </p>
  <p>
    Clients MAY offer the functionality of removing other devices from the PEP
    devicelist to the user. This could be used to clean up the devicelist
    periodically, as all active devices would reannounce themselves, while stale
    entries belonging to devices that are not in use anymore would not reappear.
    However, clients MUST NOT interfere with other devices' bundles.
  </p>
</section1>
<section1 topic='Implementation Notes' anchor='impl'>
  <p>
    The OMEMO Double Ratchet deliberately uses mostly identical parameters for
    its &double-ratchet; and &x3dh; as the Signal protocol does so that Signal
    protocol implementations can be reused with only minor modifications. Most
    notably, the HKDF info strings are different for ODR. Additionally, as ODR
    has its own, XML-based wire format, the protobuf serialization of the Signal
    protocol can be removed. Thus, implementors will most likely want to fork an
    implementation of the Signal protocol if one exists for their platform and
    make the necessary changes. Reusing well-known code should reduce the
    amount of work needed to implement OMEMO drastically, while also bolstering
    security.
  </p>
  <p>
    The payload key derivation and encryption schemes employed by OMEMO are
    identical to the ones employed by ODR, and therefore also identical to the
    ones in the Signal protocol. Implementors that make use of existing Signal
    protocol libraries SHOULD re-use the relevant library-internal code if at
    all possible. In some cases this might necessitate some refactoring of the
    code in order to expose an interface to these primitives, but it is worth
    the effort, because it reduces the attack surface and limits the risk of
    critical errors slipping in during re-implementation.
  </p>
  <p>
    The trust handling that is carried out internally by the Signal protocol
    reference implementations (and presumably ports thereof to various other
    platforms) doesn't mesh very well with the multi-end paradigm of OMEMO. For
    this reason it may be desirable to have the library consider all keys
    trusted, effectively disabling its internal trust management. This in turn
    of course makes it necessary to implement trust handling oneself.
  </p>
  <p>
    If implementors using Signal protocol implementations for ODR choose to
    implement the RECOMMENDED mechanism postponing deletion of pre-key private
    keys until after &xep0313; catch-up, they need to be aware of the fact that
    these libraries generally take care of removing pre-key private keys
    themselves after they were used. Therefore, implementors may wish to suspend
    this mechanism in their implementation of the backing PreKeyStore, create a
    copy of the PreKeyStore contents to draw from during catch-up, or devise
    their own scheme to preseve the pre-key private keys during this phase. In any
    case, implementors MUST ensure that the pre-key private keys are nonetheless
    deleted after catch-up is completed.
  </p>
</section1>
<section1 topic='Security Considerations' anchor='security'>
  <p>
    Clients MUST NOT include themselves in the list of recipients for outgoing
    OMEMO messages as this would result in an ODR session where only one of the
    two chains would ever be used for sending, leading to a complete loss of
    forward secrecy.
  </p>
  <p>
    Clients MUST NOT use a newly built session to transmit data without user
    consent. If a client were to opportunistically start using new sessions for
    sending without the user's knowledge, an attacker could publish a fake
    device for this user, which would then silently receive copies of all
    messages sent by/to this user. It is RECOMMENDED to apply Blind Trust
    Before Verification (BTBV)
        <note>Blind Trust Before Verification
            &lt;<link url='https://gultsch.de/trust.html'>https://gultsch.de/trust.html</link>&gt;
        </note>, but more conservative clients may instead e.g. choose to
    prompt the user for a trust decision on every new key.
  </p>
  <p>
    A client MAY use "not (yet) trusted" sessions for decryption of received
    messages, but in that case it SHOULD indicate the untrusted nature of such
    messages to the user.
  </p>
  <p>
    When prompting the user for a trust decision regarding a key, the client
    SHOULD present the user with a fingerprint in the form of a hex string, QR
    code, or other unique representation, such that it can be compared by the
    user.
  </p>
  <p>
    While it is RECOMMENDED that clients postpone private key deletion until
    after MAM catch-up and this standards mandates that clients MUST NOT use
    duplicate-pre-key sessions for sending, clients MAY delete such keys
    immediately for security reasons. For additional information on potential
    security impacts of this decision, refer to
        <note> Menezes, Alfred, and Berkant Ustaoglu. "On reusing ephemeral
        keys in Diffie-Hellman key agreement protocols." International Journal
        of Applied Cryptography 2, no.  2 (2010): 154-158.  </note>.
  </p>
  <p>
    Clients SHOULD send OMEMO Ratchet Update Messages in regular intervals. These
    act as "heartbeats", ensuring that the ratchet is advanced even during
    prolonged periods of inactivity of the sending chain.
  </p>
  <p>
    Conversely, if a client has not received any (valid) ODR envelopes in a
    session, the client MAY suspend sending on this specific session until an
    envelope that advances this ratchet is received. This way clients can enforce a
    certain bare minimum of forward secrecy. This is however NOT RECOMMENDED for
    typical use, as it will cause very noticeable service degradation.
  </p>
  <p>
    In order to be able to handle out-of-order messages, the ODR stack has to
    cache the keys belonging to "skipped" messages that have not been seen yet.
    It is up to the implementor to decide how long and how many of such keys to
    keep around.
  </p>
</section1>
<section1 topic='IANA Considerations' anchor='iana'>
  <p>This document requires no interaction with the Internet Assigned Numbers Authority (IANA). </p>
</section1>
<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
  <section2 topic='Protocol Namespaces' anchor='namespaces'>
    <p>This specification defines the following XMPP namespaces:</p>
    <ul>
      <li>urn:xmpp:omemo:1</li>
    </ul>
    <p>The &REGISTRAR; shall include the foregoing namespace in its registry at &NAMESPACES;, as goverened by &xep0053;.</p>
  </section2>
  <section2 topic='Protocol Versioning' anchor='versioning'>
    &NSVER;
  </section2>
</section1>
<section1 topic='XML Schema' anchor='schema'>
  <code><![CDATA[
<xml version="1.0" encoding="utf8">
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    targetNamespace="urn:xmpp:omemo:1"
    xmlns="urn:xmpp:omemo:1">

  <xs:element name="encrypted">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="header">
          <xs:complexType>
            <xs:sequence>
              <xs:choice maxOccurs="unbounded">
                <xs:element name="envelope" type="xs:base64Binary">
                  <xs:attribute name="rid" type="xs:integer" use="required"/>
                  <xs:attribute name="n" type="xs:integer" use="required"/>
                  <xs:attribute name="pn" type="xs:integer" use="required"/>
                  <xs:attribute name="dhs" type="xs:base64Binary" use="required"/>
                </xs:element>
                <xs:element name="init-envelope" type="xs:base64Binary">
                  <xs:attribute name="rid" type="xs:integer" use="required"/>
                  <xs:attribute name="n" type="xs:integer" use="required"/>
                  <xs:attribute name="pn" type="xs:integer" use="required"/>
                  <xs:attribute name="dhs" type="xs:base64Binary" use="required"/>
                  <xs:attribute name="pkid" type="xs:integer" use="required"/>
                  <xs:attribute name="spkid" type="xs:integer" use="required"/>
                  <xs:attribute name="ek" type="xs:base64Binary" use="required"/>
                  <xs:attribute name="ik" type="xs:base64Binary" use="required"/>
                </xs:element>
              </xs:choice>
              <xs:element name="iv" type="xs:base64Binary" maxOccurs="1"/>
            </xs:sequence>
            <xs:attribute name="sid" type="xs:integer"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="payload" type="xs:base64Binary" minOccurs="0"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="list">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="device" maxOccurs="unbounded">
          <xs:attribute name="id" type="integer" use="required"/>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="bundle">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="signed-pre-key-public" type="base64Binary">
          <xs:attribute name="spkid" type="integer" use="required"/>
        </xs:element>
        <xs:element name="signed-pre-key-signature" type="base64Binary"/>
        <xs:element name="identity-key" type="base64Binary"/>
        <xs:element name="pre-keys">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="pre-key-public" type="base64Binary" maxOccurs="unbounded">
                <xs:attribute name="pkid" type="integer" use="required"/>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

</xs:schema>
]]></code>
</section1>

<section1 topic='Acknowledgements' anchor='ack'>
  <p>
    Big thanks to Daniel Gultsch for mentoring me during the development of this
    protocol. Thanks to Thijs Alkemade and Cornelius Aschermann for talking
    through some of the finer points of the protocol with me, and to Sebastian
    Verschoor for auditing a previous version of the standard and giving valuable
    recommendations towards improving it. Lastly I would also like to thank Sam
    Whited, Holger Weiss, Florian Schmaus, René Calles, Germán Márquez Mejía,
    Paul Schaub, and Richard Bayerle for their input on the standard.
  </p>
</section1>
</xep>
